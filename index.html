<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PennantSim Lite Web v12 â€” Training Plus</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
  <style>
    :root{
      --bg:#f0f4f8;--card-bg:#ffffff;--card-header-bg:#e4e9f2;
      --card-border:#d1d9e6;--text-primary:#1e293b;--text-secondary:#475569;--border:#b8c1d1;
      --accent:#ff477e;--primary:#00a8f3;--primary-hover:#0082c1;
      --good:#00c47b;--bad:#ff5c5c;--warn:#ffc23d;
      --shadow-color: #9fb3c8;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:'Inter','Noto Sans JP',sans-serif;background:var(--bg);color:var(--text-primary);
      background-image: linear-gradient(rgba(0,0,0, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0, 0.03) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    header{padding:16px 24px;border-bottom:2px solid var(--border);position:sticky;top:0;background:rgba(240, 244, 248, .8);backdrop-filter:saturate(180%) blur(10px);z-index:1000}
    h1{margin:0;font-family: 'Press Start 2P', cursive; font-size:16px;letter-spacing:0;display:flex;align-items:center;gap:12px;font-weight:400; text-shadow: 2px 2px 0px rgba(0,0,0,0.05);}
    h1 .logo-icon{color:var(--accent)}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:24px;padding:24px;max-width:1600px;margin:0 auto}
    .sidebar{display:flex;flex-direction:column;gap:24px}
    .main{display:flex;flex-direction:column;gap:24px}
    .dashboard-overview{display:flex;flex-direction:column;gap:20px}
    .dashboard-overview-header{font-size:13px;font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:0.08em}
    .dashboard-overview-grid{display:grid;grid-template-columns:repeat(4,minmax(180px,1fr));gap:16px}
    .dashboard-overview-grid::-webkit-scrollbar{height:6px}
    .dashboard-overview-grid::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.45);border-radius:999px}
    .dashboard-tabs{display:flex;gap:8px;margin-bottom:16px;border-bottom:2px solid var(--border);flex-wrap:wrap}
    .dashboard-tab{border:none;background:transparent;padding:10px 16px;border-radius:10px 10px 0 0;font-weight:600;color:var(--text-secondary);cursor:pointer;display:inline-flex;align-items:center;gap:8px;position:relative;transition:color .2s ease, background .2s ease}
    .dashboard-tab::after{content:"";position:absolute;left:0;right:0;bottom:-2px;height:3px;background:transparent;transition:background .2s ease}
    .dashboard-tab:hover{color:var(--text-primary)}
    .dashboard-tab:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
    .dashboard-tab.active{color:var(--primary);background:rgba(0,168,243,0.12)}
    .dashboard-tab.active::after{background:var(--primary)}
    .dashboard-panels{display:flex;flex-direction:column;gap:16px}
    .dashboard-panel{display:none}
    .dashboard-panel.active{display:block}
    .dashboard-panel-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .dashboard-panel-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.95);box-shadow:0 6px 0 0 var(--shadow-color);display:flex;flex-direction:column;min-height:0}
    .dashboard-panel-card-header{display:flex;align-items:center;gap:8px;padding:12px 16px;font-weight:700;font-size:14px;background:var(--card-header-bg);border-bottom:2px solid var(--card-border)}
    .dashboard-panel-card-body{padding:16px;overflow:auto;max-height:100%;position:relative}
    .dashboard-panel-card-body table{background:transparent}
    .training-top { display: flex; gap: 16px; flex-wrap: wrap; align-items: stretch; margin-bottom: 16px; }
    .training-top .training-steps { flex: 1 1 320px; }
    .training-top .controls { flex: 1 1 320px; justify-content: flex-end; }
    .training-steps { list-style: none; margin: 0; padding: 12px 16px; display: flex; gap: 12px; flex-wrap: wrap; border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.92); box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.15); }
    .training-step { display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; border-radius: 999px; border: 1px solid var(--card-border); background: rgba(226,232,240,0.6); color: var(--text-secondary); font-weight: 600; font-size: 12px; letter-spacing: 0.05em; text-transform: uppercase; }
    .training-step-number { width: 24px; height: 24px; border-radius: 999px; display: flex; align-items: center; justify-content: center; background: var(--card-header-bg); color: var(--text-secondary); font-weight: 700; font-size: 12px; }
    .training-step.active { color: var(--primary); background: rgba(0,168,243,0.12); border-color: var(--primary); }
    .training-step.active .training-step-number { background: var(--primary); color: #fff; }
    .training-sections { display: flex; flex-direction: column; gap: 20px; }
    .training-section { border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.95); box-shadow: 0 8px 0 0 var(--shadow-color); overflow: hidden; }
    .training-section summary { list-style: none; cursor: pointer; display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 16px 20px; font-weight: 700; font-size: 15px; background: var(--card-header-bg); border-bottom: 2px solid var(--card-border); }
    .training-section summary .mini { font-size: 12px; color: var(--text-secondary); letter-spacing: 0.05em; }
    .training-section summary::-webkit-details-marker { display: none; }
    .training-section[open] summary { background: var(--card-header-bg); }
    .training-section .summary-icon { display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease; }
    .training-section[open] .summary-icon { transform: rotate(180deg); }
    .training-section-body { padding: 20px; display: flex; flex-direction: column; gap: 16px; }
    .training-role-group { border: 1px dashed var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); overflow: hidden; }
    .training-role-group summary { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 14px 18px; font-weight: 600; font-size: 14px; cursor: pointer; background: rgba(226,232,240,0.6); }
    .training-role-group summary .mini { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.05em; }
    .training-role-group summary::-webkit-details-marker { display: none; }
    .training-role-group[open] summary { background: rgba(226,232,240,0.9); }
    .training-role-group .summary-icon { display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease; }
    .training-role-group[open] .summary-icon { transform: rotate(180deg); }
    .player-card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; padding: 18px; }
    .player-card { border: 1px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.96); padding: 16px; display: flex; flex-direction: column; gap: 12px; box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.12); }
    .player-card.injured { opacity: 0.6; }
    .player-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .player-card-title { display: flex; flex-direction: column; gap: 6px; }
    .player-name-button { background: none; border: none; padding: 0; font: inherit; font-weight: 700; color: var(--primary); text-align: left; cursor: pointer; }
    .player-name-button:hover, .player-name-button:focus { text-decoration: underline; outline: none; }
    .player-card-role { font-size: 12px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(148,163,184,0.15); color: var(--text-secondary); font-weight: 600; letter-spacing: 0.04em; }
    .player-card-meta { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .sparkline-pair { display: flex; flex-direction: column; gap: 6px; }
    .sparkline-item { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-secondary); }
    .player-card-controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: flex-start; }
    .player-card-control { display: flex; flex-direction: column; gap: 6px; min-width: 140px; }
    .player-card-control label { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.06em; text-transform: uppercase; font-weight: 600; }
    .player-card-actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .training-filter-bar { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 16px; align-items: flex-end; }
    .training-filter { display: flex; flex-direction: column; gap: 6px; min-width: 140px; }
    .training-filter label { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.06em; text-transform: uppercase; font-weight: 600; }
    .training-progress-block { display: flex; flex-direction: column; gap: 8px; padding: 12px; border: 1px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.85); }
    .training-progress-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; font-size: 12px; color: var(--text-secondary); }
    .training-progress-meta { display: flex; flex-wrap: wrap; gap: 10px; font-size: 11px; color: var(--text-secondary); }
    .training-progress-bar { position: relative; height: 8px; border-radius: 999px; background: rgba(148,163,184,0.25); overflow: hidden; border: 1px solid rgba(148,163,184,0.4); }
    .training-progress-bar span { position: absolute; left: 0; top: 0; bottom: 0; border-radius: 999px; background: linear-gradient(90deg, var(--primary), var(--accent)); transition: width .3s ease; }
    .training-progress-spark { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .training-progress-spark span { font-size: 11px; color: var(--text-secondary); }
    .condition-badge { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 999px; display: inline-flex; align-items: center; gap: 4px; border: 1px solid transparent; }
    .condition-badge.warn { background: rgba(255,194,61,0.18); color: #b45309; border-color: rgba(255,194,61,0.5); }
    .condition-badge.danger { background: rgba(239,68,68,0.18); color: #b91c1c; border-color: rgba(239,68,68,0.5); }
    .condition-badge.good { background: rgba(34,197,94,0.18); color: #047857; border-color: rgba(34,197,94,0.4); }
    .boost-chip { font-size: 12px; font-weight: 600; padding: 4px 10px; border-radius: 999px; border: 1px solid rgba(255,71,126,0.4); background: rgba(255,71,126,0.12); color: var(--accent); }
    .training-empty { padding: 18px; font-size: 12px; color: var(--text-secondary); }
    @media (max-width: 1024px){
      .player-card-grid{grid-template-columns: repeat(auto-fit, minmax(240px,1fr));}
    }
    @media (max-width: 768px){
      .training-top{flex-direction:column; align-items:stretch;}
      .training-steps{width:100%; justify-content:flex-start;}
      .controls{width:100%; justify-content:flex-start;}
      .training-top .controls{justify-content:flex-start;}
    }
    @media (max-width: 640px){
      .player-card-grid{grid-template-columns:1fr;}
      .player-card-controls{flex-direction:column; align-items:stretch;}
      .player-card-control{width:100%;}
      .player-card-actions{width:100%; justify-content:flex-start;}
    }
    #dashboard-highlights{max-height:320px;overflow:auto}
    .summary-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.92);padding:16px 18px;display:flex;flex-direction:column;gap:10px;box-shadow:inset 0 2px 0 0 rgba(148,163,184,0.12)}
    .summary-card-header{display:flex;align-items:center;gap:8px;font-weight:700;font-size:13px;color:var(--text-secondary);letter-spacing:0.06em;text-transform:uppercase}
    .summary-card-value{font-size:26px;font-weight:700;color:var(--text-primary)}
    .summary-card-value.positive{color:var(--good)}
    .summary-card-value.negative{color:var(--bad)}
    .summary-card-meta{display:flex;flex-direction:column;gap:4px;font-size:12px;line-height:1.45;color:var(--text-secondary)}
    .summary-trend{font-weight:600}
    .summary-trend.positive{color:var(--good)}
    .summary-trend.negative{color:var(--bad)}
    .draft-view{display:flex;flex-direction:column;gap:18px}
    .draft-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .draft-card{border:2px solid var(--card-border);border-radius:14px;background:rgba(255,255,255,0.96);box-shadow:0 8px 0 0 var(--shadow-color);display:flex;flex-direction:column}
    .draft-card-header{display:flex;justify-content:space-between;align-items:center;padding:14px 18px;border-bottom:2px solid var(--card-border);background:var(--card-header-bg);gap:12px}
    .draft-card-header h3{margin:0;font-size:15px;font-weight:700;display:flex;align-items:center;gap:8px;color:var(--text-primary)}
    .draft-card-body{padding:16px 18px;display:flex;flex-direction:column;gap:12px}
    .draft-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px}
    .draft-summary-item{border:1px solid var(--card-border);border-radius:12px;background:rgba(248,250,252,0.9);padding:10px 14px;display:flex;flex-direction:column;gap:6px;min-height:72px}
    .draft-summary-label{font-size:11px;color:var(--text-secondary);letter-spacing:0.08em;font-weight:700;text-transform:uppercase}
    .draft-summary-value{font-size:22px;font-weight:700;color:var(--text-primary)}
    .draft-pending-list{display:flex;flex-wrap:wrap;gap:6px;align-items:center;min-height:24px}
    .draft-pending-pill{padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(148,163,184,0.18);font-size:12px;font-weight:600;color:var(--text-secondary)}
    .draft-pending-pill.user{border-color:var(--accent);background:rgba(255,71,126,0.12);color:var(--accent)}
    .draft-controls-body{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-start}
    .draft-controls-body>button{min-width:150px;justify-content:center}
    .draft-controls-body .draft-qa-note{flex:1 1 100%; margin-top:4px;}
    .draft-stage-badge{font-size:12px;font-weight:600;color:var(--text-secondary);padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(226,232,240,0.5)}
    .draft-log{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px}
    .draft-log-entry{border:1px solid var(--card-border);border-radius:12px;background:rgba(226,232,240,0.45);padding:10px 12px;display:flex;flex-direction:column;gap:4px;opacity:0;transform:translateY(8px);animation:draftLogEnter .25s ease forwards}
    .draft-log-entry.lottery{border-color:var(--accent);background:rgba(255,71,126,0.1)}
    .draft-log-entry.snake{border-color:var(--primary);background:rgba(0,168,243,0.08)}
    .draft-log-headline{display:flex;justify-content:space-between;align-items:center;font-weight:700;font-size:13px}
    .draft-log-title{color:var(--text-primary)}
    .draft-log-team{color:var(--text-secondary);font-size:12px}
    .draft-log-body{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--text-secondary)}
    .draft-log-meta{font-weight:600;color:var(--text-secondary)}
    .draft-log-footer{font-size:11px;color:var(--text-secondary);text-align:right}
    .draft-log-empty{font-size:12px;color:var(--text-secondary);line-height:1.6}
    .draft-log-filters{display:flex;gap:8px;flex-wrap:wrap}
    .draft-log-filters .active{background:rgba(0,168,243,0.12);border-color:var(--primary);color:var(--primary)}
    .draft-qa-note{font-size:12px;color:var(--text-secondary);line-height:1.6}
    .draft-empty-note{font-size:13px;color:var(--text-secondary);padding:12px 0}
    .draft-table-card{border:2px solid var(--card-border);border-radius:14px;background:rgba(255,255,255,0.96);box-shadow:0 8px 0 0 var(--shadow-color);padding:18px}
    .draft-table-card>.table-scroll{margin-top:12px;border-radius:12px; scrollbar-gutter: stable; padding-bottom: 10px;}
    .draft-summary-body{gap:16px}
    @keyframes draftLogEnter{to{opacity:1;transform:translateY(0)}}
    .season-timeline-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.92);padding:18px 20px;display:flex;flex-direction:column;gap:16px}
    .timeline-header{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px}
    .timeline-title{display:flex;align-items:center;gap:8px;font-size:15px;font-weight:700;color:var(--text-primary)}
    .timeline-sparkline{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .timeline-sparkline span{font-size:12px;color:var(--text-secondary)}
    .timeline-events{display:flex;gap:12px;overflow-x:auto;padding-bottom:4px}
    .timeline-events::-webkit-scrollbar{height:6px}
    .timeline-events::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.5);border-radius:999px}
    .timeline-event{min-width:200px;border:1px dashed var(--card-border);border-radius:10px;background:rgba(226,232,240,0.45);padding:12px 14px;display:flex;flex-direction:column;gap:6px}
    .timeline-event-title{display:flex;align-items:center;gap:6px;font-weight:600;font-size:13px;color:var(--text-primary)}
    .timeline-event-detail{font-size:12px;color:var(--text-secondary);line-height:1.45;white-space:normal}
    .timeline-event-meta{font-size:11px;color:var(--text-secondary);text-align:right}
    .timeline-empty{font-size:12px;color:var(--text-secondary)}
    .card{background:var(--card-bg);border:2px solid var(--card-border);border-radius:12px;box-shadow: 0 8px 0 0 var(--shadow-color);overflow:hidden; transition: transform .2s ease, box-shadow .2s ease;}
    .card:hover { transform: translateY(-2px); box-shadow: 0 10px 0 0 var(--shadow-color); }
    .card-header{background:var(--card-header-bg);padding:12px 20px;border-bottom:2px solid var(--card-border);display:flex;justify-content:space-between;align-items:center}
    .card-header h2{margin:0;font-size:16px;font-weight:700;display:flex;align-items:center;gap:8px; color: var(--text-primary);}
    .card-content{padding:20px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    button,select,input{font-family:inherit;background:#fff;border:2px solid var(--border);color:var(--text-primary);padding:8px 14px;border-radius:10px;cursor:pointer;transition:all .15s ease-out;display:inline-flex;align-items:center;gap:6px;font-size:14px;font-weight:600; box-shadow: 0 4px 0 0 var(--shadow-color);}
    select{appearance:none;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem}
    button:hover,select:hover,input:hover{background:#f8fafc;border-color:var(--text-secondary); transform: translateY(-1px); box-shadow: 0 5px 0 0 var(--shadow-color);}
    button:active,select:active,input:active{transform: translateY(2px); box-shadow: 0 2px 0 0 var(--shadow-color);}
    button:focus,select:focus,input:focus{outline:3px solid var(--accent);outline-offset:2px}
    button.primary{background:var(--primary);color:#fff;border-color:var(--primary-hover)}
    button.primary:hover{background:var(--primary-hover)}
    button.ghost{background:transparent; box-shadow: none;}
    button:disabled{opacity:.6;cursor:not-allowed;background:#e2e8f0; transform: translateY(0); box-shadow: 0 4px 0 0 var(--shadow-color);}
    .toast-container{position:fixed;top:84px;right:24px;display:flex;flex-direction:column;gap:10px;z-index:2000;pointer-events:none;max-width:320px;}
    .toast{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.96);box-shadow:0 12px 30px rgba(15,23,42,0.16);padding:14px 16px;display:flex;flex-direction:column;gap:6px;min-width:240px;opacity:0;transform:translateY(-6px);transition:opacity .2s ease, transform .2s ease;pointer-events:auto;}
    .toast.visible{opacity:1;transform:translateY(0);}
    .toast.error{border-color:var(--bad);background:rgba(255,92,92,0.12);}
    .toast.warn{border-color:var(--warn);background:rgba(255,194,61,0.16);}
    .toast-title{font-size:13px;font-weight:700;color:var(--text-primary);}
    .toast-desc{font-size:12px;color:var(--text-secondary);line-height:1.5;}
    .roster-compliance-banner{border:2px solid var(--border);border-radius:12px;padding:12px 16px;margin-bottom:12px;display:flex;flex-direction:column;gap:8px;background:rgba(255,255,255,0.92);}
    .roster-compliance-banner.error{border-color:var(--bad);background:rgba(255,92,92,0.12);}
    .roster-compliance-banner.warning{border-color:var(--warn);background:rgba(255,194,61,0.12);}
    .roster-compliance-banner .banner-header{display:flex;align-items:center;gap:8px;font-weight:700;font-size:14px;color:var(--text-primary);}
    .roster-compliance-banner.error .banner-header{color:var(--bad);}
    .roster-compliance-banner.warning .banner-header{color:#b45309;}
    .roster-compliance-banner .banner-body{font-size:13px;color:var(--text-secondary);line-height:1.6;}
    .roster-compliance-banner ul{margin:0;padding-left:18px;font-size:12px;color:var(--text-secondary);}
    .roster-compliance-banner li{line-height:1.5;}
    .foreign-badge{display:inline-flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;padding:2px 6px;border-radius:999px;border:1px solid var(--accent);color:var(--accent);background:rgba(255,71,126,0.12);}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{border-bottom:2px solid var(--border);padding:10px 4px;text-align:left;vertical-align:middle;white-space:nowrap}
    th{color:var(--text-secondary);font-weight:700;font-size:12px;text-transform:uppercase;text-align:center; background: #f1f5f9;}
    tbody tr:nth-child(odd){ background-color: rgba(255,255,255,0.5); }
    tbody tr:hover{background-color:rgba(255, 71, 126, .1)}
    td:first-child,th:first-child{text-align:left;padding-left:12px}
    td{text-align:center}
    .stat{font-weight:700;border-radius:6px;padding:3px 6px;color:white; font-size: 13px; border: 2px solid rgba(0,0,0,0.1); text-shadow: 1px 1px 0 rgba(0,0,0,0.1);}
    .stat .margin{font-size:11px;margin-left:4px;color:rgba(255,255,255,0.85);background:rgba(0,0,0,0.15);padding:1px 4px;border-radius:999px;display:inline-block;}
    .stat-s{background:#8b5cf6}.stat-a{background:#3b82f6}.stat-b{background:#16a34a}.stat-c{background:#ca8a04}.stat-d{background:#e11d48}.stat-f{background:#71717a}
    .pill{padding:4px 12px;background:#e2e8f0;border:2px solid var(--border);border-radius:999px;color:var(--text-secondary);font-size:14px;font-weight:600}
    .pill.farm{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .pill.farm-fatigue{background:#0f766e;color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .pill.farm-trait{background:#c026d3;color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .farm-log{list-style:none;padding:0;margin:8px 0 0;display:flex;flex-direction:column;gap:4px;font-size:11px;color:var(--text-secondary)}
    .farm-log li{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .farm-log-time{font-weight:600;color:var(--text-secondary);font-size:10px;letter-spacing:0.05em;text-transform:uppercase}
    .scout-unknown span{display:inline-flex;align-items:center;justify-content:center;font-weight:700;padding:3px 8px;border-radius:8px;border:2px dashed var(--border);color:var(--text-secondary);background:rgba(148,163,184,0.15);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;}
    .scout-progress{height:8px;background:rgba(148,163,184,0.25);border-radius:6px;border:1px solid rgba(148,163,184,0.4);overflow:hidden;position:relative;min-width:120px;}
    .scout-progress>span{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(90deg,var(--primary),var(--accent));border-radius:6px;transition:width .3s ease;}
    .scout-progress-label{font-size:11px;color:var(--text-secondary);margin-top:4px;text-align:right;letter-spacing:0.08em;}
    .scout-button-group{display:flex;flex-direction:column;gap:6px;}
    .scout-button-group button{width:100%;justify-content:center;}
    .scout-pill{font-size:12px;padding:4px 8px;border-radius:8px;background:rgba(0,168,243,0.12);border:1px solid var(--primary);color:var(--primary);font-weight:600;display:inline-flex;align-items:center;gap:4px;}
    .scout-summary{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:12px;}
    .mini{font-size:12px;color:var(--text-secondary)}
    .table-scroll{max-height:360px;overflow:auto;border:2px solid var(--border);border-radius:12px; background: #fff; scrollbar-gutter: stable; padding-bottom: 10px;}
    .table-scroll::-webkit-scrollbar{width:8px}
    .table-scroll::-webkit-scrollbar-thumb{background:#a0aec0;border-radius:4px; border: 2px solid #f0f4f8;}
    .tabs{display:flex;gap:4px;margin:0 20px;border-bottom:2px solid var(--card-border)}
    .tab{padding:10px 16px;border:none;cursor:pointer;background:transparent;color:var(--text-secondary);font-weight:600;transition:all .2s ease;border-bottom:4px solid transparent; transform: translateY(2px);}
    .tab:hover{color:var(--text-primary)}.tab.active{color:var(--accent);border-bottom-color:var(--accent)}
    .squad{padding:2px 8px;border-radius:6px;font-size:12px;font-weight:600}
    .squad.ichi{border:1px solid #38bdf8;background:#0c2a4d;color:#7dd3fc}
    .squad.ni{border:1px solid #6b7280;background:#374151;color:#d1d5db}
    .bar{height:8px;background:#e2e8f0;border-radius:6px;position:relative;overflow:hidden; border: 1px solid var(--border);}
    .bar>span{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(90deg,var(--accent),var(--warn));border-radius:6px}
    .tag{font-size:11px;border:1px solid #475569;padding:2px 6px;border-radius:6px;margin-right:4px}
    .good{color:var(--good)}.bad{color:var(--bad)}.warn{color:var(--warn)}
    tr.injured { opacity: 0.5; text-decoration: line-through; }
    tr.injured:hover { background: transparent; }
    .mini-icon { width: 14px; height: 14px; stroke-width: 2.5; }
    .stats-tab-bar { display:flex; gap:8px; margin:0 20px 16px; border-bottom:2px solid var(--card-border); flex-wrap:wrap; padding-bottom:4px; }
    .stats-tab { background:none; border:none; padding:10px 16px; cursor:pointer; font-weight:600; color:var(--text-secondary); border-bottom:3px solid transparent; display:inline-flex; align-items:center; gap:8px; border-radius:10px 10px 0 0; transition:color .2s ease, background .2s ease; }
    .stats-tab:hover { color:var(--text-primary); background:rgba(0,168,243,0.08); }
    .stats-tab.active { color:var(--primary); border-bottom-color:var(--primary); background:rgba(0,168,243,0.12); }
    .stats-panels { display:flex; flex-direction:column; gap:20px; padding:0 20px 20px; }
    .stats-panel { display:none; flex-direction:column; gap:16px; }
    .stats-panel.active { display:flex; }
    .stats-period-filter { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .stats-period-filter button { padding:6px 12px; font-size:12px; border-radius:999px; border:1px solid var(--border); background:rgba(226,232,240,0.6); color:var(--text-secondary); cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.05em; transition:all .2s ease; }
    .stats-period-filter button.active { background:var(--primary); color:#fff; border-color:var(--primary-hover); }
    .stats-period-filter button:hover { background:rgba(0,168,243,0.15); color:var(--text-primary); }
    .stats-section-title { font-size:13px; font-weight:700; color:var(--text-secondary); letter-spacing:0.06em; text-transform:uppercase; margin:8px 0 4px; display:flex; align-items:center; gap:8px; }
    .stats-table-wrapper { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.95); box-shadow:inset 0 2px 0 rgba(148,163,184,0.12); overflow:hidden; }
    .stats-table-wrapper table { margin:0; }
    .stats-table-wrapper .table-header { padding:12px 16px; font-weight:700; background:var(--card-header-bg); border-bottom:2px solid var(--card-border); display:flex; align-items:center; gap:8px; }
    .stats-table-wrapper .table-body { padding:12px 16px; overflow:auto; max-height:360px; }
    .heatmap-table { width:100%; border-collapse:collapse; font-size:13px; }
    .heatmap-table th, .heatmap-table td { border-bottom:1px solid rgba(148,163,184,0.35); padding:8px 10px; text-align:center; }
    .heatmap-table th { background:rgba(226,232,240,0.65); color:var(--text-secondary); font-size:11px; letter-spacing:0.05em; }
    .heatmap-table tbody tr:nth-child(odd) { background:rgba(248,250,252,0.6); }
    .heatmap-table td[data-heat] { position:relative; }
    .heatmap-table td[data-heat]::before { content:""; position:absolute; inset:2px; border-radius:6px; background:linear-gradient(90deg, rgba(0,168,243,0.18) var(--heat-level,0%), transparent var(--heat-level,0%)); z-index:-1; }
    .sparkline-hover { position:relative; display:inline-flex; align-items:center; justify-content:center; padding:4px 0; }
    .sparkline-tooltip { position:absolute; background:#0f172a; color:#fff; font-size:11px; padding:4px 8px; border-radius:6px; pointer-events:none; transform:translate(-50%, -100%); white-space:nowrap; opacity:0; transition:opacity .1s ease; z-index:10; }
    .sparkline-tooltip::after { content:""; position:absolute; bottom:-4px; left:50%; transform:translateX(-50%); border:4px solid transparent; border-top-color:#0f172a; }
    .stats-trend-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    .stats-trend-card { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.94); padding:14px 16px; display:flex; flex-direction:column; gap:10px; box-shadow:0 6px 0 0 var(--shadow-color); }
    .stats-trend-card h4 { margin:0; font-size:15px; display:flex; align-items:center; gap:8px; }
    .trend-meta { display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--text-secondary); }
    .stats-compare-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
    .stats-compare-controls select { min-width:220px; }
    .stats-compare-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    .stats-compare-card { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.94); padding:16px; box-shadow:0 6px 0 0 var(--shadow-color); display:flex; flex-direction:column; gap:12px; }
    .stats-compare-card header { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
    .stats-compare-card header h4 { margin:0; font-size:15px; }
    .stats-compare-metrics { display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:8px 12px; font-size:13px; }
    .stats-compare-metrics span { display:flex; justify-content:space-between; }
    .stats-split-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(240px,1fr)); gap:16px; }
    .stats-empty { font-size:12px; color:var(--text-secondary); padding:8px 0; }

    .feed-item { display: flex; padding: 12px 16px; gap: 12px; border-bottom: 2px solid var(--border); align-items: flex-start; }
    .feed-item:last-child { border-bottom: none; }
    .feed-icon { flex-shrink: 0; width: 32px; height: 32px; border-radius: 999px; display: flex; align-items: center; justify-content: center; background: var(--card-header-bg); }
    .feed-icon .mini-icon { color: var(--text-secondary); }
    .feed-content p { margin: 0; font-size: 13px; line-height: 1.5; white-space: normal; text-align: left;}
    .feed-content .mini { margin-top: 4px; text-align: right; }

    .recent-game-row { cursor: pointer; transition: background 0.2s ease; }
    .recent-game-row:hover td { background: rgba(0, 168, 243, 0.12); }
    .recent-game-row:focus-visible { outline: 3px solid var(--accent); outline-offset: 2px; }
    .recent-game-row.disabled { cursor: not-allowed; opacity: 0.5; }
    .recent-game-row.disabled td { background: transparent !important; }

    .highlight-link { margin-top: 8px; display: inline-flex; align-items: center; gap: 6px; font-size: 12px; padding: 6px 10px; }

    .daily-digest { padding: 16px; display: flex; flex-direction: column; gap: 12px; background: rgba(248, 250, 252, 0.92); border-bottom: 2px solid var(--card-border); }
    .daily-digest-header { display: flex; align-items: center; gap: 8px; font-weight: 700; font-size: 13px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
    .daily-digest-list { display: flex; flex-direction: column; gap: 10px; }
    .digest-day { border: 1px solid var(--card-border); border-radius: 10px; background: rgba(255, 255, 255, 0.9); padding: 10px 12px; display: flex; flex-direction: column; gap: 8px; }
    .digest-day-header { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600; color: var(--text-secondary); }
    .digest-moment-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
    .digest-moment { display: flex; flex-direction: column; gap: 4px; padding: 6px 0; border-bottom: 1px dashed rgba(148, 163, 184, 0.4); }
    .digest-moment:last-child { border-bottom: none; }
    .digest-moment-score { font-weight: 700; font-size: 13px; color: var(--text-primary); }
    .digest-moment-desc { font-size: 12px; color: var(--text-secondary); line-height: 1.45; white-space: normal; }
    .digest-moment-hero { font-size: 11px; color: var(--accent); }
    .digest-empty { padding: 16px; text-align: center; color: var(--text-secondary); font-size: 12px; }

    .narrative-feed-summary { padding: 16px 20px; border-bottom: 2px solid var(--card-border); background: rgba(248,250,252,0.9); display: flex; flex-direction: column; gap: 12px; }
    .narrative-tag { font-size: 10px; padding: 2px 8px; border-radius: 999px; background: rgba(255, 71, 126, 0.15); border: 1px solid rgba(255, 71, 126, 0.4); color: var(--accent); font-weight: 700; letter-spacing: 0.05em; }
    .morale-timeline { display: flex; align-items: center; gap: 12px; }
    .morale-timeline span { font-size: 12px; color: var(--text-secondary); }
    .narrative-log-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
    .narrative-log-item { font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
    .narrative-log-item strong { color: var(--text-primary); }
    .narrative-log-empty { font-size: 12px; color: var(--text-secondary); }
    .narrative-detail-button { align-self: flex-end; }

    .management-narrative-panel { border: 2px dashed var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.92); padding: 16px 20px; display: flex; flex-direction: column; gap: 16px; margin-bottom: 16px; }
    .management-narrative-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .management-narrative-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; }
    .narrative-subcard { border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 14px; background: rgba(248,250,252,0.85); display: flex; flex-direction: column; gap: 10px; }
    .narrative-subcard h4 { margin: 0; font-size: 13px; display: flex; align-items: center; gap: 6px; }
    .narrative-subcard .narrative-log-list { max-height: 180px; overflow: auto; }
    .narrative-subcard .narrative-log-list::-webkit-scrollbar { width: 6px; }
    .narrative-subcard .narrative-log-list::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.6); border-radius: 999px; }

    .narrative-modal-entry { border-bottom: 1px solid var(--card-border); padding-bottom: 12px; margin-bottom: 12px; display: flex; flex-direction: column; gap: 6px; }
    .narrative-modal-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .narrative-modal-entry h4 { margin: 0; font-size: 14px; display: flex; align-items: center; gap: 8px; }
    .narrative-modal-entry p { margin: 0; font-size: 12px; color: var(--text-secondary); line-height: 1.6; }
    .narrative-modal-entry .narrative-tag { align-self: flex-start; }
    .narrative-modal-entry .meta-line { font-size: 11px; color: var(--text-secondary); display: flex; gap: 8px; flex-wrap: wrap; }

    .modal-content.game-recap { max-width: 960px; width: 95%; }
    .modal-body.game-recap { padding: 24px; display: flex; flex-direction: column; gap: 20px; }
    .modal-content.scout-report { max-width: 760px; width: 95%; }
    .modal-body.scout-report { padding: 24px; display: flex; flex-direction: column; gap: 18px; }
    .scout-report-section { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.15); }
    .scout-report-section h4 { margin: 0; padding: 12px 16px; background: var(--card-header-bg); border-bottom: 2px solid var(--card-border); font-size: 14px; }
    .scout-report-body { padding: 16px; display: flex; flex-direction: column; gap: 12px; }
    .scout-metric-list { display: grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap: 10px; }
    .scout-metric { border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; background: rgba(255,255,255,0.85); display: flex; flex-direction: column; gap: 4px; }
    .scout-metric strong { font-size: 13px; }
    .scout-metric span { font-size: 12px; color: var(--text-secondary); }
    .scout-tournament-item { border: 1px dashed rgba(148,163,184,0.7); border-radius: 10px; padding: 12px; background: rgba(241,245,249,0.9); display: flex; flex-direction: column; gap: 6px; }
    .scout-tournament-item strong { font-size: 13px; color: var(--text-primary); }
    .scout-note { font-size: 12px; color: var(--text-secondary); line-height: 1.6; }
    .game-recap-header { display: flex; justify-content: space-between; flex-wrap: wrap; gap: 16px; align-items: center; }
    .game-recap-header .scoreline { font-size: 20px; font-weight: 700; }
    .game-recap-meta { display: flex; gap: 12px; flex-wrap: wrap; color: var(--text-secondary); font-size: 13px; }
    .game-recap-highlights ul { margin: 0; padding-left: 20px; }
    .game-recap-highlights li { margin-bottom: 6px; font-size: 13px; }
    .game-recap-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .game-recap-section { border: 2px solid var(--card-border); border-radius: 10px; background: rgba(248,250,252,0.8); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.18); }
    .game-recap-section h4 { margin: 0; padding: 12px 16px; border-bottom: 2px solid var(--card-border); background: var(--card-header-bg); font-size: 14px; }
    .game-recap-section .section-body { padding: 12px 16px; overflow-x: auto; }
    .game-recap-keyplay { font-size: 14px; font-weight: 600; background: rgba(0, 200, 123, 0.1); border: 2px solid rgba(0, 200, 123, 0.3); border-radius: 10px; padding: 12px 16px; color: var(--good); }

    .key-moment-list { display: flex; flex-direction: column; gap: 6px; font-size: 12px; }
    .key-moment-item { padding: 6px 8px; border-left: 3px solid var(--accent); background: rgba(255, 71, 126, 0.08); border-radius: 6px; }
    .play-log-list { max-height: 220px; overflow: auto; display: flex; flex-direction: column; gap: 6px; font-size: 12px; }
    .play-log-item { padding: 6px 8px; border-left: 3px solid var(--primary); background: rgba(226, 232, 240, 0.75); border-radius: 6px; }
    .game-recap-timeline { display: flex; flex-direction: column; gap: 12px; }
    .timeline-entry { border: 1px solid var(--card-border); border-radius: 8px; padding: 8px 10px; background: rgba(148, 163, 184, 0.12); font-size: 12px; }
    .timeline-entry strong { display: block; font-size: 13px; margin-bottom: 4px; }
    .timeline-entry span { display: block; margin-bottom: 2px; }

    .game-recap-table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .game-recap-table th { background: rgba(226, 232, 240, 0.7); font-size: 11px; text-transform: uppercase; }
    .game-recap-table td, .game-recap-table th { border-bottom: 1px solid var(--border); padding: 8px 6px; text-align: center; white-space: nowrap; }
    .game-recap-table td:first-child, .game-recap-table th:first-child { text-align: left; }

    @media (max-width: 1200px){
        .dashboard-overview-grid{grid-template-columns:repeat(2,minmax(200px,1fr));}
    }
    @media (max-width: 900px) {
        .game-recap-grid { grid-template-columns: 1fr; }
        .dashboard-overview-grid{grid-template-columns:1fr;}
    }

    @media (max-width: 640px) {
        .modal-body { grid-template-columns: 1fr; }
        .modal-body.game-recap { padding: 20px; }
        .dashboard-overview-grid{display:flex;overflow-x:auto;gap:12px;padding-bottom:4px;}
        .dashboard-overview-grid .summary-card{flex:0 0 220px;}
        .timeline-events{gap:10px;}
        .stats-tab-bar{margin:0 12px 12px;}
        .stats-panels{padding:0 12px 16px;}
        .stats-period-filter{gap:6px;}
        .stats-table-wrapper .table-body{padding:8px 12px;}
        .stats-compare-controls select{min-width:160px; width:100%;}
        .stats-compare-metrics{grid-template-columns:1fr;}
    }

    @media (max-width: 720px){
        .stats-table-wrapper table .col-secondary{display:none;}
        .stats-table-wrapper table th.col-secondary{display:none;}
    }

    .playoffs-wrapper { display: flex; flex-direction: column; gap: 16px; padding: 16px; }
    .playoff-stage { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.9); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.2); }
    .playoff-stage-header { padding: 12px 16px; border-bottom: 2px solid var(--card-border); background: var(--card-header-bg); font-weight: 700; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
    .playoff-stage.done .playoff-stage-header { color: var(--good); }
    .playoff-stage.upcoming .playoff-stage-header { color: var(--text-secondary); }
    .playoff-series { padding: 16px; display: flex; flex-direction: column; gap: 10px; border-bottom: 2px solid var(--card-border); }
    .playoff-series:last-child { border-bottom: none; }
    .playoff-series h4 { margin: 0; font-size: 15px; font-weight: 700; display: flex; align-items: center; gap: 6px; }
    .series-status { font-size: 12px; color: var(--text-secondary); }
    .series-teams { display: grid; gap: 8px; }
    .series-team { display: flex; justify-content: space-between; align-items: center; background: rgba(226, 232, 240, 0.7); border: 2px solid var(--card-border); border-radius: 10px; padding: 8px 12px; font-weight: 600; }
    .series-team .wins { font-size: 12px; color: var(--text-secondary); }
    .series-games { list-style: none; margin: 0; padding: 0; font-size: 12px; color: var(--text-secondary); display: flex; flex-direction: column; gap: 4px; }
    .series-games li { padding: 6px 8px; background: rgba(248, 250, 252, 0.9); border: 1px solid var(--card-border); border-radius: 8px; }
    .series-action { display: flex; gap: 8px; align-items: center; }
    .series-action button { flex-shrink: 0; }
    .playoffs-empty { padding: 24px; text-align: center; font-size: 13px; color: var(--text-secondary); }
    .champion-banner { padding: 20px; border: 2px dashed var(--accent); border-radius: 12px; background: rgba(255, 71, 126, 0.05); text-align: center; font-weight: 700; font-size: 16px; display: flex; flex-direction: column; gap: 8px; }

    .finance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; }
    .finance-card { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.9); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.18); padding: 16px; display: flex; flex-direction: column; gap: 10px; }
    .finance-card h3 { margin: 0; font-size: 14px; font-weight: 700; display: flex; align-items: center; gap: 8px; color: var(--text-primary); }
    .front-office-view { display: flex; flex-direction: column; gap: 20px; }
    .front-office-card { border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.95); box-shadow: 0 8px 0 0 var(--shadow-color); padding: 18px; display: flex; flex-direction: column; gap: 16px; }
    .front-office-card-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .front-office-card-header h3 { margin: 0; font-size: 15px; display: flex; align-items: center; gap: 8px; font-weight: 700; color: var(--text-primary); }
    .front-office-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; }
    .staff-slider-row, .facility-slider-row { display: flex; flex-direction: column; gap: 10px; padding: 12px; border: 1px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); }
    .staff-slider-header, .facility-slider-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .staff-slider-name, .facility-slider-name { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-primary); }
    .staff-slider-value, .facility-slider-value { font-weight: 700; font-size: 14px; color: var(--text-primary); }
    .staff-slider-meta, .facility-slider-meta { font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
    .staff-slider-input, .facility-slider-input { width: 100%; accent-color: var(--primary); }
    .staff-slider-footer, .facility-slider-footer { display: flex; justify-content: flex-end; color: var(--text-secondary); }
    .facility-slider-effects { list-style: none; margin: 0; padding-left: 16px; display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: var(--text-secondary); }
    .front-office-empty { padding: 12px; border: 1px dashed var(--border); border-radius: 12px; background: rgba(248,250,252,0.6); }
    @media (max-width: 640px){ .front-office-grid{ grid-template-columns:1fr; } }
    .finance-stat { display: flex; justify-content: space-between; font-size: 13px; color: var(--text-secondary); }
    .finance-stat strong { color: var(--text-primary); }
    .finance-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .finance-tag { font-size: 10px; padding: 2px 6px; border-radius: 999px; background: rgba(0,168,243,0.12); border: 1px solid var(--primary); color: var(--primary); text-transform: uppercase; letter-spacing: 0.04em; }
    .budget-slider { width: 100%; accent-color: var(--primary); }
    .finance-section { margin-top: 20px; display: flex; flex-direction: column; gap: 12px; }
    .finance-section h3 { margin: 0; font-size: 15px; font-weight: 700; display: flex; gap: 8px; align-items: center; }
    .contract-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .contract-table th, .contract-table td { border-bottom: 1px solid var(--border); padding: 6px 4px; text-align: left; white-space: nowrap; }
    .contract-table th { background: rgba(241,245,249,0.7); text-transform: uppercase; font-size: 11px; color: var(--text-secondary); }
    .contract-table tbody tr:hover { background: rgba(0,168,243,0.08); }
    .contract-negotiation { display: flex; flex-direction: column; gap: 12px; }
    .contract-negotiation .table-scroll { max-height: 360px; }
    .contract-negotiation .offer-cell { display: grid; grid-template-columns: auto 1fr; gap: 4px 8px; align-items: center; }
    .contract-negotiation .offer-cell input { width: 120px; }
    .contract-negotiation .negotiation-table td { vertical-align: top; white-space: nowrap; }
    .contract-negotiation .negotiation-table td.result-cell { white-space: normal; }
    .contract-negotiation .negotiation-text { margin-bottom: 4px; line-height: 1.5; }
    .contract-negotiation .negotiation-actions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .contract-negotiation .negotiation-actions button.danger { color: var(--warn); border-color: rgba(239, 68, 68, 0.4); }
    .contract-negotiation .negotiation-actions button.danger:hover { background: rgba(239, 68, 68, 0.08); }
    .finance-badge { font-size: 11px; padding: 2px 6px; border-radius: 6px; background: rgba(0,200,123,0.12); border: 1px solid rgba(0,200,123,0.4); color: var(--good); font-weight: 600; }
    .finance-forecast { display: flex; flex-direction: column; gap: 4px; font-size: 12px; }
    .finance-forecast span { display: flex; justify-content: space-between; }

    #debug-panel {
      position: fixed;
      top: 80px;
      right: 16px;
      width: 280px;
      background: rgba(15, 23, 42, 0.9);
      color: #e2e8f0;
      border: 1px solid #334155;
      border-radius: 12px;
      z-index: 9900;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.2s ease-out;
    }
    @media (max-width: 1200px) {
      #debug-panel {
        width: 240px;
      }
    }
    @media (max-width: 900px) {
      #debug-panel {
        width: auto;
        left: 16px;
        right: 16px;
        top: auto;
        bottom: 10px;
      }
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(30, 41, 59, 0.8);
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }
    .modal-content {
        background: var(--card-bg);
        padding: 0;
        border-radius: 12px;
        border: 2px solid var(--card-border);
        box-shadow: 0 12px 0 0 var(--shadow-color);
        width: 90%;
        max-width: 600px;
        position: relative;
    }
    .modal-header {
      padding: 16px 24px;
      border-bottom: 2px solid var(--card-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-header-bg);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 18px;
    }
    .modal-body {
        padding: 24px;
        display: grid;
        grid-template-columns: 1fr 220px;
        gap: 24px;
        align-items: flex-start;
    }
    .modal-body.finance { display: flex; flex-direction: column; gap: 16px; }
    .close-button {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 24px;
        padding: 0;
        line-height: 1;
        box-shadow: none;
    }
    @media (max-width: 640px) {
        .modal-body {
            grid-template-columns: 1fr;
        }
    }

    /* Jules' Debug Console */
    #jules-debug-console {
      position: fixed;
      width: 450px;
      max-height: 50vh;
      background: rgba(15, 23, 42, 0.95);
      color: #e2e8f0;
      border: 1px solid #475569;
      border-radius: 12px;
      z-index: 9999;
      display: none; /* Initially hidden */
      flex-direction: column;
      font-size: 13px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.4);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    #jules-debug-console.active {
      display: flex;
    }
    #jules-debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(30, 41, 59, 0.8);
      border-bottom: 1px solid #334155;
      cursor: move;
      user-select: none;
    }
    #jules-debug-header h4 {
      margin: 0;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #jules-debug-body {
      padding: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .jules-debug-section h5 {
      margin: 0 0 6px;
      font-size: 11px;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    #jules-debug-log-output, #jules-debug-error-output, #jules-debug-state-output {
      background: #0f172a;
      border-radius: 6px;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #334155;
    }
    #jules-debug-footer {
      padding: 8px 12px;
      border-top: 1px solid #334155;
      display: flex;
      justify-content: flex-end;
    }

    /* Accessibility */
    .skip-link {
      position: absolute;
      top: -999px;
      left: 8px;
      background: var(--primary);
      color: #fff;
      padding: 10px 16px;
      z-index: 9999;
      border-radius: 8px;
      font-weight: 700;
      transition: top 0.2s ease-out;
      box-shadow: 0 4px 0 0 var(--primary-hover);
    }
    .skip-link:focus {
      top: 8px;
    }
  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¸ã‚¹ã‚­ãƒƒãƒ—</a>
  <div id="startup-error" style="position:fixed;top:0;left:0;right:0;background:#e53e3e;color:white;padding:1em;text-align:center;z-index:9999;font-family:monospace;display:none;font-size:14px;line-height:1.6;"></div>
  <header role="banner">
    <div style="display:flex;gap:16px;align-items:center;justify-content:space-between;">
      <h1><i data-lucide="baseball" class="logo-icon"></i>PennantSim Lite Web v12</h1>
      <div style="display:flex;gap:8px;align-items:center;">
        <span id="ruleSetDisplay" class="pill" style="background-color: var(--primary); color: #fff; border-color: var(--primary-hover);">NPB (2025)</span>
        <span class="pill">è‚²æˆå¼·åŒ– / å£«æ°—ãƒ»ç–²åŠ´ãƒ»æ–½è¨­ãƒ»ç‰¹è¨“</span>
        <span class="mini" style="color:#64748b;">ä¿å­˜ã¯è‡ªå‹• / ãƒ­ãƒ¼ã‚«ãƒ«</span>
      </div>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar" role="complementary">
      <section class="card" id="skip-target-progression" tabindex="-1">
        <div class="card-header"><h2><i data-lucide="calendar-days"></i>é€²è¡Œ</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:8px;">
            <button id="btnGen" class="primary"><i data-lucide="calendar-plus"></i>æ–°ã‚·ãƒ¼ã‚ºãƒ³é–‹å§‹</button>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
              <button id="btnToday"><i data-lucide="play"></i>ä»Šæ—¥ã‚’é€²ã‚ã‚‹</button>
              <button id="btnEnd"><i data-lucide="fast-forward"></i>æœ€å¾Œã¾ã§</button>
            </div>
            <div id="advanceWarning" class="mini text-danger"></div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin:12px 0;">
            <span class="pill" id="seasonLabel"></span>
            <span class="pill" id="dayLabel">Day -</span>
            <span class="pill" id="gamesLabel">ã‚«ãƒ¼ãƒ‰ 0 ä»¶</span>
          </div>
          <div id="todayMatchups" class="table-scroll" style="max-height:140px;"></div>
        </div>
      </section>

      <section class="card" id="skip-target-settings" tabindex="-1">
        <div class="card-header"><h2><i data-lucide="sliders-horizontal"></i>è¨­å®š</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:12px;">
            <label style="display:flex;justify-content:space-between;align-items:center;">ãƒ›ãƒ¼ãƒ æœ‰åˆ©ï¼ˆ%ï¼‰<input id="homeAdv" style="width:80px;" type="number" min="0" max="15" step="1" value="5"></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">å¯¾æˆ¦å›žæ•°<select id="repeats" style="width:80px;">
              <option>2</option><option>4</option><option selected>6</option><option>8</option>
            </select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">ä¹±æ•°ã‚·ãƒ¼ãƒ‰<input id="seed" style="width:80px;" type="number" value="2025"></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">ã‚¤ãƒ™ãƒ³ãƒˆé »åº¦<select id="eventFrequency" style="width:160px;">
              <option value="low">æŽ§ãˆã‚</option>
              <option value="standard">æ¨™æº–</option>
              <option value="high">å¤šã‚</option>
            </select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">ã‚·ãƒŠãƒªã‚ªãƒ†ãƒ¼ãƒž<select id="eventTheme" style="width:160px;">
              <option value="balanced">ãƒãƒ©ãƒ³ã‚¹</option>
              <option value="heroic">ãƒ’ãƒ­ã‚¤ãƒƒã‚¯</option>
              <option value="drama">ãƒ‰ãƒ©ãƒžãƒ†ã‚£ãƒƒã‚¯</option>
              <option value="rivalry">ãƒ©ã‚¤ãƒãƒ«é‡è¦–</option>
            </select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆ<select id="ruleSet" style="width:160px;"></select></label>
            <button id="btnReset" style="margin-top:8px; background: var(--bad); color: #fff; border-color: #c53030;"><i data-lucide="rotate-cw"></i>å…¨ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–</button>
          </div>
        </div>
      </section>

      <!-- æ“ä½œè¨­å®š: è‡ªåˆ†ãƒãƒ¼ãƒ ï¼†ãƒ¢ãƒ¼ãƒ‰ -->
      <section class="card" id="skip-target-user-settings" tabindex="-1">
        <div class="card-header"><h2><i data-lucide="gamepad-2"></i>æ“ä½œè¨­å®š</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:8px;">
            <label style="display:flex;justify-content:space-between;align-items:center;">è‡ªåˆ†ã®ãƒãƒ¼ãƒ <select id="selUserTeam" style="width:220px;"></select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">ãƒ¢ãƒ¼ãƒ‰<select id="modeSelect" style="width:220px;"><option value="user">è‡ªåˆ†ãƒãƒ¼ãƒ ã®ã¿</option><option value="comm">ã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼</option></select></label>
          </div>
          <div class="mini" style="margin-top:6px;">â€» é€šå¸¸ã¯è‡ªåˆ†ã®ãƒãƒ¼ãƒ ã ã‘æ“ä½œå¯ã€‚ã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ã¯å…¨ãƒãƒ¼ãƒ æ“ä½œå¯ã€‚</div>
        </div>
      </section>

    </aside>

    <main class="main" role="main" id="main-content" tabindex="-1">
      <section class="card" id="dashboard-overview-card" aria-labelledby="dashboard-overview-heading" tabindex="-1">
        <div class="card-header">
          <h2 id="dashboard-overview-heading"><i data-lucide="gauge"></i>ã‚·ãƒ¼ã‚ºãƒ³ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h2>
        </div>
        <div class="card-content">
          <div id="dashboard-overview">
            <div class="mini">ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
            <div id="season-timeline" class="timeline-empty" style="display:none;">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’æº–å‚™ä¸­...</div>
          </div>
        </div>
      </section>
      <section class="card" id="dashboard-panels-card" aria-labelledby="dashboard-panels-heading" tabindex="-1">
        <div class="card-header">
          <h2 id="dashboard-panels-heading"><i data-lucide="layout-dashboard"></i>ã‚¯ãƒ©ãƒ–ã‚¤ãƒ³ã‚µã‚¤ãƒˆ</h2>
        </div>
        <div class="card-content">
          <div id="dashboard-tabs" class="dashboard-tabs" role="tablist">
            <button class="dashboard-tab" data-tab="season" role="tab" aria-selected="false"><i data-lucide="calendar"></i>ã‚·ãƒ¼ã‚ºãƒ³</button>
            <button class="dashboard-tab" data-tab="finance" role="tab" aria-selected="false"><i data-lucide="wallet"></i>è²¡å‹™</button>
            <button class="dashboard-tab" data-tab="development" role="tab" aria-selected="false"><i data-lucide="sprout"></i>è‚²æˆ</button>
          </div>
          <div id="dashboard-panels" class="dashboard-panels">
            <div class="dashboard-panel" data-panel="season" role="tabpanel" aria-hidden="true">
              <div class="dashboard-panel-grid">
                <section class="dashboard-panel-card" data-panel-card="standings" aria-labelledby="standings-heading">
                  <header class="dashboard-panel-card-header"><h3 id="standings-heading"><i data-lucide="bar-chart-3"></i><span>é †ä½è¡¨</span></h3></header>
                  <div class="dashboard-panel-card-body" id="dashboard-standings"></div>
                </section>
                <section class="dashboard-panel-card" data-panel-card="playoffs" data-playoff-card aria-labelledby="playoffs-heading">
                  <header class="dashboard-panel-card-header"><h3 id="playoffs-heading"><i data-lucide="trophy"></i><span>ãƒã‚¹ãƒˆã‚·ãƒ¼ã‚ºãƒ³</span></h3></header>
                  <div class="dashboard-panel-card-body" id="dashboard-playoffs"></div>
                </section>
              </div>
            </div>
            <div class="dashboard-panel" data-panel="finance" role="tabpanel" aria-hidden="true">
              <section class="dashboard-panel-card" data-panel-card="finance" aria-labelledby="finance-heading">
                <header class="dashboard-panel-card-header"><h3 id="finance-heading"><i data-lucide="factory"></i><span>ãƒ•ãƒ­ãƒ³ãƒˆã‚ªãƒ•ã‚£ã‚¹</span></h3></header>
                <div class="dashboard-panel-card-body" id="dashboard-front-office"></div>
              </section>
            </div>
            <div class="dashboard-panel" data-panel="development" role="tabpanel" aria-hidden="true">
              <div class="dashboard-panel-grid">
                <section class="dashboard-panel-card" data-panel-card="recent" aria-labelledby="recent-heading">
                  <header class="dashboard-panel-card-header"><h3 id="recent-heading"><i data-lucide="history"></i><span>ç›´è¿‘ã®çµæžœ</span></h3></header>
                  <div class="dashboard-panel-card-body" id="dashboard-recent"></div>
                </section>
                <section class="dashboard-panel-card" data-panel-card="highlights" aria-labelledby="highlights-heading">
                  <header class="dashboard-panel-card-header"><h3 id="highlights-heading"><i data-lucide="sparkles"></i><span>ãƒã‚¤ãƒ©ã‚¤ãƒˆãƒ•ã‚£ãƒ¼ãƒ‰</span></h3></header>
                  <div class="dashboard-panel-card-body" id="dashboard-highlights"></div>
                </section>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card" id="management-card" aria-labelledby="management-heading" tabindex="-1">
        <div class="card-header">
          <h2><i data-lucide="users"></i>ãƒãƒ¼ãƒ ç®¡ç† & è‚²æˆ</h2>
          <select id="selTeamManage"></select>
        </div>
        <nav class="tabs" aria-label="ãƒãƒ¼ãƒ ç®¡ç†ã‚»ã‚¯ã‚·ãƒ§ãƒ³">
          <button class="tab active" data-tab="roster">ãƒ­ã‚¹ã‚¿ãƒ¼</button>
          <button class="tab" data-tab="training">è‚²æˆ</button>
          <button class="tab" data-tab="stats">å€‹äººæˆç¸¾</button>
          <button class="tab" data-tab="draft">ãƒ‰ãƒ©ãƒ•ãƒˆ</button>
          <button class="tab" data-tab="front">ãƒ•ãƒ­ãƒ³ãƒˆ</button>
          <button class="tab" data-tab="report">è‚²æˆãƒ¬ãƒãƒ¼ãƒˆ</button>
        </nav>
        <div id="management-content" class="card-content"></div>
      </section>
    </main>
  </div>

  <!-- Player Detail Modal -->
  <div id="playerDetailModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalPlayerName">Player Name</h3>
        <button id="modalCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="modalBody" class="modal-body">
        <!-- Content will be generated by JS -->
      </div>
    </div>
  </div>

  <!-- Game Recap Modal -->
  <div id="gameRecapModal" class="modal-overlay">
    <div class="modal-content game-recap">
      <div class="modal-header">
        <h3 id="gameRecapTitle">è©¦åˆè©³ç´°</h3>
        <button id="gameRecapCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="gameRecapBody" class="modal-body game-recap">
        <!-- Filled dynamically -->
      </div>
    </div>
  </div>

  <!-- Finance Modal -->
  <div id="financeModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="financeModalTitle">ãƒ•ãƒ­ãƒ³ãƒˆã‚ªãƒ•ã‚£ã‚¹æ“ä½œ</h3>
        <button id="financeModalCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="financeModalBody" class="modal-body finance"></div>
    </div>
  </div>

  <!-- Roster Violation Modal -->
  <div id="rosterViolationModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="rosterViolationModalTitle">ç™»éŒ²åˆ¶é™ã‚¢ãƒ©ãƒ¼ãƒˆ</h3>
        <button id="rosterViolationCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="rosterViolationBody" class="modal-body" style="gap:16px;"></div>
    </div>
  </div>

  <!-- Scout Report Modal -->
  <div id="scoutReportModal" class="modal-overlay">
    <div class="modal-content scout-report">
      <div class="modal-header">
        <h3 id="scoutReportTitle">ã‚¹ã‚«ã‚¦ãƒˆãƒ¬ãƒãƒ¼ãƒˆ</h3>
        <button id="scoutReportCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="scoutReportBody" class="modal-body scout-report"></div>
    </div>
  </div>

  <!-- Narrative Log Modal -->
  <div id="narrativeLogModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="narrativeLogTitle">å£«æ°—ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</h3>
        <button id="narrativeLogCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="narrativeLogBody" class="modal-body" style="display:flex; flex-direction:column; gap:16px; padding:24px;"></div>
    </div>
  </div>


<button id="error-trigger-btn" style="position: absolute; left: -9999px; top: -9999px;" onclick="setTimeout(() => { throw new Error('Controlled test error'); }, 50);">Trigger Error</button>
<script>
  // Global helper to create elements
  const el = (t, a = {}, ...c) => {
    const n = document.createElement(t);
    for (const [k, v] of Object.entries(a)) {
      if (k === "class") n.className = v;
      else if (k === "html") n.innerHTML = v;
      else n.setAttribute(k, v);
    }
    for (const x of c) n.append(x);
    return n;
  };

  // Global toast notification system
  let toastContainer = null;
  function ensureToastContainer() {
    if (toastContainer && document.body.contains(toastContainer)) return toastContainer;
    toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = el('div', { class: 'toast-container' });
      document.body.append(toastContainer);
    }
    return toastContainer;
  }

  function showToast(message, options = {}) {
    if (!message) return null;
    const opts = options || {};
    const container = ensureToastContainer();
    const type = opts.type || 'info';
    const duration = Math.max(1500, opts.duration || 3200);
    const toast = el('div', { class: `toast ${type}` });
    toast.append(el('div', { class: 'toast-title' }, document.createTextNode(message)));
    if (opts.description) {
      toast.append(el('div', { class: 'toast-desc' }, document.createTextNode(opts.description)));
    }
    container.append(toast);
    requestAnimationFrame(() => toast.classList.add('visible'));
    const remove = () => {
      toast.classList.remove('visible');
      setTimeout(() => { if (toast.parentElement) toast.remove(); }, 180);
    };
    const timer = setTimeout(remove, duration);
    toast.addEventListener('click', () => { clearTimeout(timer); remove(); });
    return toast;
  }
</script>
<script type="module">
import { focusTrap } from './src/utils/accessibility.js';
import { logUserAction } from './src/utils/action_logger.js';
import LeagueRules from './src/core/rules.js';
import { getAllRulesets, getRulesetById } from './src/rulesets.js';
import { generateSchedule } from './src/systems/schedule_generator.js';
import rulesStore from './src/state/rules_store.js';
import { valuePlayerContract, normalizeContractTerms, negotiateContractOffer as evaluateNegotiation } from './src/systems/contracts.js';
import { determineFreeAgencyEligibility, rankFreeAgent, ensureFreeAgencyState, processFreeAgentSigning } from './src/systems/free_agency.js';
import {
  ensureDraftState as ensureDraftStateRecord,
  initializeDraft as initializeDraftState,
  submitBid as submitDraftBid,
  resolveFirstRound as resolveDraftFirstRound,
  selectProspect as selectDraftProspect,
  getOnClockTeamId as getDraftOnClockTeamId,
  getPendingFirstRoundTeams as getDraftPendingTeams,
  shouldResolveFirstRound as shouldResolveDraftFirstRound,
  isDraftOver as isDraftComplete,
  calculateTeamNeeds as calculateDraftTeamNeeds,
  getProspectNeedCategory as getDraftProspectNeedCategory,
} from './src/systems/draft.js';
import { validateForeignPlayerLimits } from './src/systems/roster_rules.js';
import { applyFarmEffects } from './src/systems/farm.js';
import {
  computeStaffAdjustments,
  ensureTeamStaff
} from './src/systems/staff.js';
import {
  computeFacilityAdjustments,
  ensureTeamFacilities,
  updateTeamFacilities
} from './src/systems/facilities.js';
import { applyAging as applyAgingSystem, progressPlayerAging, ensurePlayerAgingProfile } from './src/systems/aging.js';

const SupportSystems = {
  staff: { computeStaffAdjustments, ensureTeamStaff },
  facilities: { computeFacilityAdjustments, ensureTeamFacilities }
};

const AgingSystem = {
  applyAging: applyAgingSystem,
  progressPlayerAging,
  ensurePlayerAgingProfile
};

if (typeof window !== 'undefined') {
  window.PennantSimSupportSystems = SupportSystems;
  window.PennantSimAging = AgingSystem;
}
import {
  getSpecialById,
  normalizePlayerSpecials,
  playerHasSpecial,
  collectPlayerEffects,
  loadSpecials,
  getPlayerEffects,
  findSpecialId,
  createPlateAppearanceSpecialEngine,
} from './src/systems/specials.js';
import SeasonSimulator, {
  describeStage as describeSeasonStage,
  getSeasonCalendar as getSeasonCalendarFromState,
  getCalendarEntry as getCalendarEntryFromState,
  updateSeasonStage as updateSeasonStageInState,
  maxDay as computeMaxDayForState,
  applyRestDayRecovery as applyRestDayRecoveryEngine,
  tickDay as tickSeasonDay,
  applyAllStarBreakDay as applyAllStarBreakDayEngine
} from './src/engine/sim_season.js';
import * as DebugPanel from './src/ui/debug_panel.js';
import createScheduleView from './src/ui/views/ScheduleView.js';
import createContractsView from './src/ui/views/ContractsView.js';
import createDraftView from './src/ui/views/DraftView.js';
import createFAView from './src/ui/views/FAView.js';
import createStaffView from './src/ui/views/StaffView.js';
import createFacilitiesView from './src/ui/views/FacilitiesView.js';
import createFinanceView from './src/ui/views/FinanceView.js';
import { ensureTeamFans as ensureTeamFansState } from './src/systems/fans.js';
import { ensureSponsorDeals as ensureSponsorDealsState } from './src/systems/sponsors.js';
import teamSelectionStore from './src/state/team_selection_store.js';
import {
  chooseBestProspectForTeam as chooseBestProspectForTeamLogic,
  autoDraftStep as autoDraftStepLogic,
  autoUntilUserTurn as autoUntilUserTurnLogic,
  getNextDraftActor,
  evaluateProspectForTeam,
  prospectNeedBucket,
  evaluateProspectBase
} from './src/systems/draft_simulation.js';
// ====== Helpers & State ======
let activeFocusTrap = null;
const $=(s)=>document.querySelector(s); const $$=(s)=>[...document.querySelectorAll(s)];
const refreshIcons = () => { if (window.lucide) { window.lucide.createIcons(); } };
function resolveTarget(target, fallback){
  if(target instanceof HTMLElement) return target;
  if(typeof target==='string') return document.querySelector(target);
  if(fallback) return document.querySelector(fallback);
  return null;
}
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
function hashString(str){ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h>>>0; }
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const SAVE_KEY="pennantsim-lite-web-v12-training-plus";
const gameRecapKey=(day,home,away)=>`${day}-${home}-${away}`;
function parseGameRecapKey(key){ if(!key) return null; const [day,home,away]=key.split('-').map(Number); return {day,home_id:home,away_id:away}; }
function formatInnings(ip){ if(ip==null || Number.isNaN(Number(ip))) return '-'; return (Math.round(Number(ip)*10)/10).toFixed(1); }
const yenFormatter = new Intl.NumberFormat('ja-JP');
const millionFormatter = value => `Â¥${(value/1000000).toFixed(1)}M`;

const describeStage = describeSeasonStage;

function maxDay(){
  return computeMaxDayForState(State);
}

function getSeasonCalendar(){
  return getSeasonCalendarFromState(State);
}

function getCalendarEntry(day){
  return getCalendarEntryFromState(State, day);
}

function updateSeasonStage(stage, day){
  updateSeasonStageInState(State, stage, day);
}

function applyRestDayRecovery(){
  applyRestDayRecoveryEngine(State, { ensureTeamMeta, hasTrait, clamp, getPlayerEffects });
}

function tickDay(){
  return tickSeasonDay(State, {
    logHighlight,
    getCalendarEntry: (s, day) => getCalendarEntryFromState(s, day),
    maxDay: (s) => computeMaxDayForState(s),
    updateSeasonStage: (s, stage, day) => updateSeasonStageInState(s, stage, day),
    applyRestDayRecovery: (s) => applyRestDayRecoveryEngine(s, { ensureTeamMeta, hasTrait, clamp, getPlayerEffects }),
    handleAllStarBreak: (s, context) => applyAllStarBreakDayEngine(s, context, {
      ensureNarrativeState,
      logHighlight,
      ensureTeamMeta,
      ensureTeamFinances
    }),
    applyAging: (s, opts) => applyAgingSystem(s, opts)
  });
}

// ====== Sound Engine ======
let soundReady = false;
let soundFailed = false;
let synth;

async function setupSound() {
    if (soundReady || soundFailed) {
        return;
    }
    if (!window.Tone) {
        console.warn('Tone.js not available; sound disabled.');
        soundFailed = true;
        return;
    }
    try {
        await Tone.start();
        synth = new Tone.Synth({
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).toDestination();
        soundReady = true;
    } catch (err) {
        soundFailed = true;
        console.warn('Failed to initialize sound; continuing without audio.', err);
    }
}

function playSound(note, len = '16n') {
    if (soundReady && synth) {
        synth.triggerAttackRelease(note, len);
    }
}


const POSITIONS=["C","1B","2B","3B","SS","LF","CF","RF","DH"];
const INJURY_TYPES = [
    { name: 'è»½åº¦ã®æ‰“æ’²', min: 3, max: 7, chance: 0.6 },
    { name: 'æ»æŒ«', min: 10, max: 21, chance: 0.3 },
    { name: 'è‚‰é›¢ã‚Œ', min: 20, max: 40, chance: 0.08 },
    { name: 'éª¨æŠ˜', min: 50, max: 90, chance: 0.02 }
];

const baseTeams=[["èª­å£²ã‚¸ãƒ£ã‚¤ã‚¢ãƒ³ãƒ„","Central"],["é˜ªç¥žã‚¿ã‚¤ã‚¬ãƒ¼ã‚¹","Central"],["åºƒå³¶æ±æ´‹ã‚«ãƒ¼ãƒ—","Central"],["ä¸­æ—¥ãƒ‰ãƒ©ã‚´ãƒ³ã‚º","Central"],["æ¨ªæµœDeNAãƒ™ã‚¤ã‚¹ã‚¿ãƒ¼ã‚º","Central"],["æ±äº¬ãƒ¤ã‚¯ãƒ«ãƒˆã‚¹ãƒ¯ãƒ­ãƒ¼ã‚º","Central"],["ã‚ªãƒªãƒƒã‚¯ã‚¹ãƒ»ãƒãƒ•ã‚¡ãƒ­ãƒ¼ã‚º","Pacific"],["ç¦å²¡ã‚½ãƒ•ãƒˆãƒãƒ³ã‚¯ãƒ›ãƒ¼ã‚¯ã‚¹","Pacific"],["åŒ—æµ·é“æ—¥æœ¬ãƒãƒ ãƒ•ã‚¡ã‚¤ã‚¿ãƒ¼ã‚º","Pacific"],["æ±åŒ—æ¥½å¤©ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¤ãƒ¼ã‚°ãƒ«ã‚¹","Pacific"],["åƒè‘‰ãƒ­ãƒƒãƒ†ãƒžãƒªãƒ¼ãƒ³ã‚º","Pacific"],["åŸ¼çŽ‰è¥¿æ­¦ãƒ©ã‚¤ã‚ªãƒ³ã‚º","Pacific"]].map((t,i)=>({team:t[0],league:t[1],team_id:i,popularity:SeasonSimulator?.DEFAULT_TEAM_POPULARITY||60}));
function randHand(rng){ return (rng()<0.3)?"L":"R"; }
function randPos(rng){ const list=[["C",.1],["1B",.12],["2B",.13],["3B",.13],["SS",.13],["LF",.12],["CF",.14],["RF",.13]]; let r=rng(); for(const[p,w] of list){ if((r-=w)<=0) return p;} return "LF"; }

// ====== Name Generator (fictional) ======
const JP_SURNAMES = ["ä½è—¤","éˆ´æœ¨","é«˜æ©‹","ç”°ä¸­","ä¼Šè—¤","æ¸¡è¾º","å±±æœ¬","ä¸­æ‘","å°æž—","åŠ è—¤","å‰ç”°","å±±ç”°","ä½ã€…æœ¨","å±±å£","æ–Žè—¤","æ¾æœ¬","äº•ä¸Š","æœ¨æ‘","æž—","æ¸…æ°´","å±±å´Ž","æ± ç”°","æ©‹æœ¬","é˜¿éƒ¨","æ£®","å±±ä¸‹","çŸ³äº•","çŸ³å·","å‰ç”°","è—¤ç”°","é’æœ¨","å¾Œè—¤","é•·è°·å·","è¿‘è—¤","æ‘ä¸Š","çŸ³ç”°","å°é‡Ž","åŽŸ","ä¸­å·","å²¡ç”°","é•·é‡Ž","æŸ´ç”°","å†…ç”°","ä¸­å³¶","é…’äº•","å®®å´Ž","ç«¹å†…","è—¤äº•","æ¾ç”°","å°å³¶","å €"];
const JP_GIVEN = ["å¤§è¼”","ç¿”å¤ª","å¥å¤ª","æ‹“ä¹Ÿ","ç›´æ¨¹","äº®","å¾¹","é™½ä»‹","æ‚ æ–—","é¢¯å¤ª","è“®","æµ·æ–—","ä¸€è¼","æ‹“æµ·","å¤§åœ°","æ‚ çœŸ","æ‚ ç”Ÿ","ä¿Šä»‹","å‰›","æ™ºä¹Ÿ","ç¥ä»‹","åœ­å¤ª","èˆª","èˆªå¤ª","æ­å¹³","èª ","å’Œä¹Ÿ","å„ª","å„ªæ–—","æ‚ äºº","åŒ ","éš¼äºº","é§¿","é­","æ¸“","ç›´äºº","å°†å¤ª","å•“å¤ª","å¼˜æ¨¹","å¤§æ™º"];
const KATA_FIRST = ["ã‚«ãƒ«ãƒ­ã‚¹","ãƒ›ã‚»","ãƒ«ã‚¤ã‚¹","ãƒŸã‚²ãƒ«","ãƒ©ã‚¦ãƒ«","ãƒ•ãƒªã‚ª","ã‚¨ãƒ‰ã‚¬ãƒ¼","ã‚ªã‚¹ã‚«ãƒ«","ãƒãƒ“ã‚¨ãƒ«","ãƒ•ã‚§ãƒ«ãƒŠãƒ³ãƒ‰","ã‚¢ãƒ¬ãƒƒã‚¯ã‚¹","ãƒ–ãƒ©ã‚¤ã‚¢ãƒ³","ãƒ‡ãƒ¼ãƒ“ãƒƒãƒ‰","ã‚¸ãƒ§ãƒ³","ãƒ˜ãƒ³ãƒªãƒ¼","ãƒ€ãƒ‹ã‚¨ãƒ«","ãƒ‹ã‚³ãƒ©ã‚¹","ã‚¢ãƒ³ãƒ‰ãƒªãƒ¥ãƒ¼","ãƒžã‚¤ã‚±ãƒ«","ãƒ•ãƒ©ãƒ³ã‚¯","ãƒžãƒ«ã‚³","ãƒ¬ã‚ªãƒŠãƒ«ãƒ‰","ã‚¯ãƒªã‚¹ãƒãƒ£ãƒ³","ã‚¸ãƒ§ãƒ«ãƒ€ãƒ³","ã‚¤ãƒãƒ³","ã‚¢ãƒ«ãƒ™ãƒ«ãƒˆ","ãƒ­ãƒ™ãƒ«ãƒˆ","ãƒ­ãƒ‰ãƒªã‚´","ã‚»ã‚µãƒ«","ãƒ‡ã‚£ã‚¨ã‚´","ã‚«ãƒŸãƒ­"];
const KATA_LAST = ["ã‚¬ãƒ«ã‚·ã‚¢","ãƒ­ãƒ‰ãƒªã‚²ã‚¹","ã‚µãƒ³ãƒã‚§ã‚¹","ã‚´ãƒ¡ã‚¹","ãƒžãƒ«ãƒ†ã‚£ãƒã‚¹","ãƒ¢ãƒ©ãƒ¬ã‚¹","ã‚«ã‚¹ãƒ†ã‚£ãƒ¼ãƒ¨","ã‚¨ãƒ«ãƒŠãƒ³ãƒ‡ã‚¹","ãƒšãƒ¬ã‚¹","ã‚´ãƒ³ã‚¶ãƒ¬ã‚¹","ãƒ–ãƒ©ã‚¦ãƒ³","ã‚¹ãƒŸã‚¹","ã‚¸ãƒ§ãƒ³ã‚½ãƒ³","ãƒªãƒ¼","ã‚­ãƒ ","ãƒ‘ã‚¯","ãƒã‚§ãƒ³","ãƒ¯ãƒ³","ãƒªã‚¦","ãƒãƒ£ãƒ³","ãƒªãƒ™ãƒ©","ã‚«ãƒ–ãƒ¬ãƒ©","ã‚½ãƒˆ","ãƒ©ãƒŸãƒ¬ã‚¹","ã‚¢ãƒ«ãƒãƒ¬ã‚¹"];
function makeFictionalIdentity(rng, used){
  function pick(arr){ return arr[Math.floor(rng()*arr.length)]; }
  const isForeign = rng() < 0.18; // 18% å¤–å›½äººé¢¨
  const origin = isForeign ? 'international' : 'domestic';
  let name;
  if(isForeign){ name = `${pick(KATA_FIRST)}ãƒ»${pick(KATA_LAST)}`; }
  else { name = `${pick(JP_SURNAMES)}${pick(JP_GIVEN)}`; }
  let tries=0; while(used.has(name) && tries<6){ if(isForeign){ name = `${pick(KATA_FIRST)}ãƒ»${pick(KATA_LAST)}`; } else { name = `${pick(JP_SURNAMES)}${pick(JP_GIVEN)}`; } tries++; }
  used.add(name);
  return { name, isForeign, origin };
}
function makeFictionalName(rng, used){
  return makeFictionalIdentity(rng, used).name;
}

function getOverall(p) {
    const isPitcher = !!p.velo;
    return isPitcher ?
        (p.velo * 0.3 + p.ctrl * 0.3 + p.mov * 0.3 + p.stam * 0.1) :
        (p.con * 0.3 + p.disc * 0.1 + p.pwr * 0.3 + p.spd * 0.15 + p.fld * 0.15);
}

function randomPersona(rng=Math.random){
  const roll=(base,spread,bias=0)=>{
    const swing=(rng()-0.5)*spread;
    const variance=(rng()-0.5)*(spread*0.6);
    return clamp(Math.round(base + swing + variance + bias),0,100);
  };
  return {
    greed: roll(52, 36),
    loyalty: roll(50, 34),
    winDesire: roll(56, 38),
  };
}

function ensurePlayerPersona(player, rng){
  if(!player || typeof player !== 'object') return null;
  if(player.persona && typeof player.persona === 'object'){
    const src=player.persona;
    const resolve=(value, fallback)=>{
      const num=Number(value);
      return clamp(Math.round(Number.isFinite(num)?num:fallback),0,100);
    };
    player.persona={
      greed: resolve(src.greed, 52),
      loyalty: resolve(src.loyalty, 50),
      winDesire: resolve(src.winDesire, 56),
    };
    return player.persona;
  }
  let generator=null;
  if(typeof rng==='function'){
    generator=rng;
  } else if(Number.isFinite(rng)){
    generator=mulberry32((rng>>>0));
  }
  if(!generator){
    const key=player.id || player.name || `${Date.now()}`;
    generator=mulberry32(hashString(String(key))>>>0);
  }
  player.persona=randomPersona(generator);
  return player.persona;
}

function mkInitialRoster(team_id, seed=2025){
  const rng = mulberry32(team_id*101 + seed);
  const bats = [], pits = [];
  const used = new Set(); // ãƒãƒ¼ãƒ å†…ã®é‡è¤‡åã‚’é¿ã‘ã‚‹
  for(let i=0;i<18;i++){
    const identity = makeFictionalIdentity(rng, used);
    const player = {
      id:`B${team_id}-${i}`, name: identity.name, age: 20 + Math.floor(rng()*14), hand: randHand(rng),
      pos: randPos(rng),
      con: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), disc: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pwr: clamp(55 + Math.floor(rng()*20 - 10), 30, 99),
      spd: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), fld: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pot: clamp(60 + Math.floor(rng()*25 - 12), 45, 99),
      traits:[], morale:60+Math.floor(rng()*20), fatigue:20+Math.floor(rng()*10), injury: null, recentGains: [],
      farmReveal: 0, farmLog: [], farmLast: null,
      popularity: SeasonSimulator?.DEFAULT_PLAYER_POPULARITY || 55,
      isForeign: identity.isForeign,
      origin: identity.origin
    };
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale], farmReveal: [0] };
    ensurePlayerPersona(player, rng);
    bats.push(player);
  }
  for(let i=0;i<14;i++){
    const identity = makeFictionalIdentity(rng, used);
    const player = {
      id:`P${team_id}-${i}`, name: identity.name, age: 20 + Math.floor(rng()*14),
      role: (rng()<0.6?"SP":"RP"), hand: randHand(rng),
      velo: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), ctrl: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), mov: clamp(55 + Math.floor(rng()*20 - 10), 30, 99),
      stam: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pot: clamp(60 + Math.floor(rng()*25 - 12), 45, 99),
      traits:[], morale:60+Math.floor(rng()*20), fatigue:20+Math.floor(rng()*10), sub_role: null, injury: null, recentGains: [],
      farmReveal: 0, farmLog: [], farmLast: null,
      popularity: SeasonSimulator?.DEFAULT_PLAYER_POPULARITY || 55,
      isForeign: identity.isForeign,
      origin: identity.origin
    };
    if (player.role === 'RP') player.sub_role = 'ä¸­ç¶™ãŽ';
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale], farmReveal: [0] };
    ensurePlayerPersona(player, rng);
    pits.push(player);
  }
  return {bats,pits};
}

// ====== Financial Defaults & Contracts ======
const BUDGET_CATEGORIES = ["payroll", "staff", "facilities", "marketing"];
const STAFF_COSTS = { coaches: 28000000, scouts: 18000000, analysts: 16000000, marketing: 14000000 };
const DEFAULT_TICKET_PRICE = 3200;
const DEFAULT_STADIUM_CAPACITY = 42000;
const TEAM_NEGOTIATION_POSTURES = ['strong','standard','lenient'];

function defaultBudgetAllocations(){
  return { payroll: 0.55, staff: 0.18, facilities: 0.17, marketing: 0.10 };
}

function defaultTeamFinance(tid){
  return {
    team_id: tid,
    budget: { total: 12000000000, allocations: defaultBudgetAllocations(), reserves: 4200000000 },
    revenue: { ticket: 0, merch: 0, media: 0, other: 0, total: 0 },
    expenses: { payroll: 0, staff: 0, facilities: 0, marketing: 0, total: 0 },
    attendance: { capacity: DEFAULT_STADIUM_CAPACITY, seasonTotal: 0, average: 0, lastGame: 0, forecast: 0, homeGames: 0 },
    ticketPrice: DEFAULT_TICKET_PRICE,
    contracts: [],
    staff: { coaches: 3, scouts: 2, analysts: 1, marketing: 2 },
    ledger: [],
    popularity: SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60,
    negotiationPosture: 'standard'
  };
}

function estimatePlayerSalary(player){
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  return market.AAV;
}

function deriveContractLength(player, rand=Math.random){
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  let years = market.years;
  if(rand() > 0.7 && years < 6) years++;
  if(rand() < 0.12 && years > 1) years--;
  return clamp(Math.round(years), 1, 6);
}

function normalizeContract(contract, player, tid, season){
  const existing = { ...(contract || {}) };
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  const normalizedTerms = normalizeContractTerms(existing, { defaults: market });
  const startSeason = existing.startSeason ?? season;
  const normalizedYears = clamp(normalizedTerms.years ?? 1, 1, 6);
  const totalYears = clamp(existing.totalYears ?? existing.years ?? normalizedYears, 1, 6);
  const expirySeason = existing.expirySeason ?? (startSeason != null ? startSeason + totalYears - 1 : undefined);
  let yearsRemaining = existing.yearsRemaining;
  if(!Number.isFinite(yearsRemaining)){
    if(expirySeason != null && season != null){
      yearsRemaining = expirySeason - season + 1;
    } else {
      yearsRemaining = totalYears;
    }
  }
  yearsRemaining = Math.max(0, Math.min(totalYears, Math.round(yearsRemaining)));
  const status = existing.status || 'active';
  const normalized = {
    ...existing,
    playerId: player.id,
    playerName: player.name,
    team_id: tid,
    startSeason,
    totalYears,
    years: normalizedYears,
    yearsRemaining,
    expirySeason,
    status,
    type: existing.type || 'standard',
    AAV: normalizedTerms.AAV,
    salary: normalizedTerms.AAV,
    incentives: normalizedTerms.incentives,
    noTradeClause: normalizedTerms.noTradeClause,
    expectedAnnual: normalizedTerms.expectedAnnual,
    totalValue: normalizedTerms.AAV * totalYears,
  };
  if(normalized.status === 'active' && normalized.yearsRemaining <= 1 && normalized.daysRemaining == null){
    normalized.daysRemaining = 90;
  }
  return normalized;
}

function ensurePlayerContract(player, tid, season, rand=Math.random){
  let contract = player.contract;
  if(!contract || typeof contract !== 'object'){
    const market = valuePlayerContract(player, { overall: getOverall(player) });
    contract = {
      AAV: market.AAV,
      years: market.years,
      incentives: market.incentives,
      noTradeClause: market.noTradeClause,
      totalYears: market.years,
      yearsRemaining: market.years,
      startSeason: season,
      status: 'active',
      type: 'standard'
    };
  }
  if(contract.totalYears && !contract.yearsRemaining){
    contract.yearsRemaining = contract.totalYears;
  }
  if(!contract.totalYears && contract.yearsRemaining){
    contract.totalYears = contract.yearsRemaining;
  }
  if(!contract.startSeason){
    contract.startSeason = season;
  }
  contract = normalizeContract(contract, player, tid, season);
  player.contract = { ...contract };
  return contract;
}

function contractSummary(contract, player){
  const incentives = contract.incentives && typeof contract.incentives === 'object'
    ? JSON.parse(JSON.stringify(contract.incentives))
    : { playingTime: 0, performance: 0, awards: 0, total: 0, expectedPayout: 0 };
  const summary = {
    playerId: player.id,
    name: player.name,
    AAV: contract.AAV ?? 0,
    salary: contract.AAV ?? 0,
    incentives,
    expectedAnnual: contract.expectedAnnual ?? ((contract.AAV ?? 0) + (incentives.expectedPayout || 0)),
    yearsRemaining: contract.yearsRemaining ?? contract.totalYears ?? contract.years ?? 0,
    totalYears: contract.totalYears ?? contract.years ?? 0,
    status: contract.status ?? 'active',
    type: contract.type ?? 'standard',
    expirySeason: contract.expirySeason,
    daysRemaining: contract.daysRemaining ?? null,
    role: player.velo ? 'æŠ•æ‰‹' : 'é‡Žæ‰‹',
    noTradeClause: !!contract.noTradeClause,
    totalValue: contract.totalValue ?? ((contract.AAV ?? 0) * (contract.totalYears ?? contract.years ?? 1)),
  };
  return summary;
}

function normalizeFinanceObject(finance){
  if(!finance) return defaultTeamFinance(0);
  finance.budget = finance.budget || {};
  finance.budget.total = finance.budget.total || 12000000000;
  finance.budget.allocations = { ...defaultBudgetAllocations(), ...(finance.budget.allocations||{}) };
  finance.budget.reserves = finance.budget.reserves ?? Math.round(finance.budget.total * 0.35);
  const rev = finance.revenue || {};
  finance.revenue = { ticket: rev.ticket||0, merch: rev.merch||0, media: rev.media||0, other: rev.other||0, total: rev.total||0 };
  const exp = finance.expenses || {};
  finance.expenses = { payroll: exp.payroll||0, staff: exp.staff||0, facilities: exp.facilities||0, marketing: exp.marketing||0, total: exp.total||0 };
  finance.attendance = { capacity:DEFAULT_STADIUM_CAPACITY, seasonTotal:0, average:0, lastGame:0, forecast:0, homeGames:0, ...(finance.attendance||{}) };
  finance.ticketPrice = finance.ticketPrice || DEFAULT_TICKET_PRICE;
  finance.contracts = Array.isArray(finance.contracts) ? finance.contracts : [];
  finance.staff = { coaches:3, scouts:2, analysts:1, marketing:2, ...(finance.staff||{}) };
  finance.ledger = Array.isArray(finance.ledger) ? finance.ledger : [];
  finance.popularity = typeof finance.popularity === 'number'
    ? clamp(finance.popularity, 0, 100)
    : (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60);
  const postureKey = typeof finance.negotiationPosture === 'string' ? finance.negotiationPosture.toLowerCase() : 'standard';
  finance.negotiationPosture = TEAM_NEGOTIATION_POSTURES.includes(postureKey) ? postureKey : 'standard';
  if(finance.attendance.capacity < 10000) finance.attendance.capacity = DEFAULT_STADIUM_CAPACITY;
  return finance;
}

function syncFinanceContracts(finance, roster, season){
  if(!roster) return;
  const next=[];
  roster.bats.forEach(player=>{
    const c=ensurePlayerContract(player, finance.team_id, season);
    next.push(contractSummary(c, player));
  });
  roster.pits.forEach(player=>{
    const c=ensurePlayerContract(player, finance.team_id, season);
    next.push(contractSummary(c, player));
  });
  next.sort((a,b)=> (b.expectedAnnual||b.AAV||0) - (a.expectedAnnual||a.AAV||0));
  finance.contracts = next;
}

function normalizeTeamFinances(state){
  if(!state.teamFinances) state.teamFinances={};
  const season = state.season || 1;
  (state.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const finance = normalizeFinanceObject(state.teamFinances[tid] || defaultTeamFinance(tid));
    finance.team_id = tid;
    syncFinanceContracts(finance, state.rosters?.[tid], season);
    if(!finance.budget.allocations || Object.keys(finance.budget.allocations).length===0){
      finance.budget.allocations = defaultBudgetAllocations();
    }
    state.teamFinances[tid]=finance;
  });
  if(!Array.isArray(state.freeAgents)) state.freeAgents=[];
  return state.teamFinances;
}

function normalizeRosterPlayers(state){
  if(!state || typeof state !== 'object') return;
  const applyPersona=(player)=>{
    if(!player || typeof player !== 'object') return;
    if(!player.history){
      player.history={ overall:[getOverall(player)], fatigue:[player.fatigue||20], morale:[player.morale||60], farmReveal:[clamp(Math.round(player.farmReveal||0),0,100)] };
    } else {
      if(!Array.isArray(player.history.overall)) player.history.overall=[getOverall(player)];
      if(!Array.isArray(player.history.fatigue)) player.history.fatigue=[player.fatigue||20];
      if(!Array.isArray(player.history.morale)) player.history.morale=[player.morale||60];
      if(!Array.isArray(player.history.farmReveal)) player.history.farmReveal=[clamp(Math.round(player.farmReveal||0),0,100)];
    }
    if(!Number.isFinite(player.farmReveal)) player.farmReveal = 0;
    player.farmReveal = clamp(Math.round(player.farmReveal), 0, 100);
    if(!Array.isArray(player.farmLog)) player.farmLog = [];
    else if(player.farmLog.length > 8) player.farmLog.splice(0, player.farmLog.length - 8);
    if(player.farmLast && typeof player.farmLast !== 'object') player.farmLast = null;
    if(player.farmLast){
      player.farmLast.traitUnlocks = Array.isArray(player.farmLast.traitUnlocks) ? player.farmLast.traitUnlocks : [];
    }
    if(!Array.isArray(player.recentGains)) player.recentGains=[];
    if(typeof player.isForeign !== 'boolean') player.isForeign = Boolean(player.isForeign);
    if(!player.origin) player.origin = player.isForeign ? 'international' : 'domestic';
    if(player.lastSquadMoveDay !== null && player.lastSquadMoveDay !== undefined){
      const parsed=Number(player.lastSquadMoveDay);
      player.lastSquadMoveDay=Number.isFinite(parsed)?parsed:null;
    } else {
      player.lastSquadMoveDay=null;
    }
    ensurePlayerPersona(player);
  };
  Object.values(state.rosters||{}).forEach(roster=>{
    if(!roster) return;
    (roster.bats||[]).forEach(applyPersona);
    (roster.pits||[]).forEach(applyPersona);
  });
  if(Array.isArray(state.freeAgents)) state.freeAgents.forEach(applyPersona);
}

function normalizeSquadAssignments(state){
  if(!state || typeof state !== 'object') return;
  if(!state.squads || typeof state.squads !== 'object'){
    state.squads = {};
    state.squadsInit = false;
    return;
  }
  const rosters = state.rosters || {};
  const teams = Array.isArray(state.teams) ? state.teams : [];
  const normalizedSquads = {};
  let shouldResetInit = false;

  const resolveRosterIds = (tid)=>{
    const roster = rosters[tid] || {};
    const bats = Array.isArray(roster.bats) ? roster.bats : [];
    const pits = Array.isArray(roster.pits) ? roster.pits : [];
    const ids = new Set();
    [...bats, ...pits].forEach(player => {
      if(!player || typeof player !== 'object') return;
      const raw = Number.isFinite(player.id) ? player.id : Number(player.id ?? player.pid);
      if(Number.isFinite(raw)) ids.add(raw);
    });
    return ids;
  };

  const normalizeList = (list, validIds)=>{
    const seen = new Set();
    const result = [];
    (Array.isArray(list) ? list : []).forEach(entry => {
      if(entry == null) return;
      let pid;
      if(typeof entry === 'object'){
        const raw = Number(entry.id ?? entry.pid);
        if(Number.isFinite(raw)) pid = raw;
      } else {
        const raw = Number(entry);
        if(Number.isFinite(raw)) pid = raw;
      }
      if(!Number.isFinite(pid)) return;
      if(!validIds.has(pid)) return;
      if(seen.has(pid)) return;
      seen.add(pid);
      result.push(pid);
    });
    return result;
  };

  const teamIds = new Set();
  teams.forEach(team => { if(team && Number.isFinite(team.team_id)) teamIds.add(team.team_id); });
  Object.keys(state.squads).forEach(key => {
    const parsed = Number(key);
    if(Number.isFinite(parsed)) teamIds.add(parsed);
  });

  teamIds.forEach(tid => {
    const source = state.squads[tid] || state.squads[String(tid)] || {};
    const originalIchi = Array.isArray(source.ichi) ? source.ichi : [];
    const originalNi = Array.isArray(source.ni) ? source.ni : [];
    const validIds = resolveRosterIds(tid);
    const ichi = normalizeList(originalIchi, validIds);
    const ni = normalizeList(originalNi, validIds);
    if((originalIchi.length > 0 && ichi.length === 0) || (originalNi.length > 0 && ni.length === 0)){
      shouldResetInit = true;
    }
    normalizedSquads[tid] = { ichi, ni };
  });

  state.squads = normalizedSquads;
  state.squadsInit = shouldResetInit ? false : Boolean(state.squadsInit);
}

function normalizeNarrativeState(state){
  if(!state) return;
  if(!state.narrativeSettings || typeof state.narrativeSettings !== 'object'){
    state.narrativeSettings = { frequency: 'standard', theme: 'balanced' };
  } else {
    state.narrativeSettings.frequency = state.narrativeSettings.frequency || 'standard';
    state.narrativeSettings.theme = state.narrativeSettings.theme || 'balanced';
  }
  if(!state.teamNarratives || typeof state.teamNarratives !== 'object') state.teamNarratives = {};
  if(!Array.isArray(state.narrativeLog)) state.narrativeLog = [];
  (state.teams||[]).forEach(team=>{
    const tid = team.team_id;
    const bucket = state.teamNarratives[tid] || {};
    bucket.morale = Array.isArray(bucket.morale) ? bucket.morale : [];
    bucket.events = Array.isArray(bucket.events) ? bucket.events : [];
    state.teamNarratives[tid] = bucket;
  });
}

function defaultSeasonInfo(){
  return {
    calendar: [],
    stage: 'PRE',
    dayLookup: {},
    stageBounds: {},
    regularSeasonEnd: 0,
    gamesPerTeam: 0
  };
}

function computeRegularSeasonEnd(info){
  if(!info || !Array.isArray(info.calendar)) return 0;
  let maxDay = 0;
  info.calendar.forEach(entry => {
    if(!entry || typeof entry !== 'object') return;
    const day = entry.date ?? entry.day ?? 0;
    if(entry.stage === 'CS' || entry.stage === 'JS') return;
    if(entry.stage === 'AS'){
      maxDay = Math.max(maxDay, day);
      return;
    }
    const hasMatchups = Array.isArray(entry.matchups) && entry.matchups.length > 0;
    if(hasMatchups || entry.stage === 'REG' || entry.stage === 'IL'){
      maxDay = Math.max(maxDay, day);
    }
  });
  return maxDay;
}

function rebuildSeasonCalendarInfo(info){
  const data = info && typeof info === 'object' ? info : defaultSeasonInfo();
  const calendar = Array.isArray(data.calendar) ? data.calendar : [];
  const lookup = {};
  const normalized = calendar.map((entry, idx)=>{
    if(!entry || typeof entry !== 'object') return { date: idx+1, stage: 'REG', matchups: [] };
    const date = typeof entry.date === 'number' ? entry.date : (typeof entry.day === 'number' ? entry.day : idx + 1);
    const stage = entry.stage || 'REG';
    const matchups = Array.isArray(entry.matchups) ? entry.matchups : [];
    const normalizedEntry = { ...entry, date, stage, matchups };
    lookup[date] = idx;
    return normalizedEntry;
  });
  data.calendar = normalized;
  data.dayLookup = lookup;
  data.stageBounds = (data.stageBounds && typeof data.stageBounds === 'object') ? data.stageBounds : {};
  data.regularSeasonEnd = computeRegularSeasonEnd(data);
  data.stage = data.stage || (data.calendar[0]?.stage || 'PRE');
  data.gamesPerTeam = typeof data.gamesPerTeam === 'number' ? data.gamesPerTeam : 0;
  data.totalsByTeam = (data.totalsByTeam && typeof data.totalsByTeam === 'object') ? data.totalsByTeam : {};
  return data;
}

function normalizeSeasonInfo(state){
  if(!state || typeof state !== 'object') return;
  if(!state.seasonInfo || typeof state.seasonInfo !== 'object'){
    state.seasonInfo = defaultSeasonInfo();
  }
  state.seasonInfo = rebuildSeasonCalendarInfo(state.seasonInfo);
  return state.seasonInfo;
}

function defaultLeagueState(){
  return {
    name: 'NPB',
    rules: LeagueRules.createDefaultRules()
  };
}

function normalizeLeagueState(state) {
  if (!state || typeof state !== 'object') return;
  if (!state.league || typeof state.league !== 'object') {
    state.league = defaultLeagueState();
  }
  const selectedRuleset = getRulesetById(state.ruleId);
  const gameRules = selectedRuleset ? { ...selectedRuleset } : {};
  const newRules = LeagueRules.normalizeRules({ ...state.league.rules, game: gameRules });
  state.league.rules = newRules;
  state.ruleId = selectedRuleset.id;
  rulesStore.set(newRules);
  return state.league;
}

function ensureTeamFinances(){
  if(typeof State === 'undefined') return;
  return normalizeTeamFinances(State);
}

function ensureFreeAgents(){
  ensureFreeAgencyState(State);
  if(!Array.isArray(State.freeAgents)) State.freeAgents=[];
  return State.freeAgents;
}

function teamRecord(tid){
  const results = State.results || [];
  let wins=0, losses=0;
  results.forEach(res=>{
    if(res.home_id===tid || res.away_id===tid){
      if(res.winner_id===tid) wins++; else losses++;
    }
  });
  return { wins, losses, total: wins+losses };
}

function computeTeamPayroll(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return 0;
  return finance.contracts
    .filter(c=>c.status!=='expired')
    .reduce((sum,c)=>{
      const annual = c.expectedAnnual ?? ((c.AAV||0) + (c.incentives?.expectedPayout||0));
      return sum + annual;
    },0);
}

function computeAttendanceForecast(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return 0;
  const record = teamRecord(tid);
  const winPct = record.total ? record.wins / record.total : 0.5;
  const marketing = finance.budget?.allocations?.marketing ?? 0.1;
  const roster = State.rosters[tid];
  let morale = 65;
  if(roster){
    const players = [...roster.bats, ...roster.pits];
    if(players.length){
      morale = players.reduce((s,p)=>s+(p.morale||60),0)/players.length;
    }
  }
  const moraleFactor = clamp(morale/80, 0.7, 1.35);
  const base = finance.attendance?.capacity || DEFAULT_STADIUM_CAPACITY;
  const forecast = Math.round(clamp(base * (0.45 + winPct * 0.4 + marketing * 0.3) * moraleFactor, 8000, base));
  finance.attendance.forecast = forecast;
  return forecast;
}

function updateFinancialSnapshots(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  finance.expenses.payroll = computeTeamPayroll(tid);
  const staff = finance.staff || {};
  finance.expenses.staff = (staff.coaches||0)*STAFF_COSTS.coaches + (staff.scouts||0)*STAFF_COSTS.scouts + (staff.analysts||0)*STAFF_COSTS.analysts + (staff.marketing||0)*STAFF_COSTS.marketing;
  const facilityBase = finance.budget.total * (finance.budget.allocations.facilities||0) * 0.05;
  finance.expenses.facilities = Math.round(facilityBase);
  const marketingSpend = finance.budget.total * (finance.budget.allocations.marketing||0) * 0.04;
  finance.expenses.marketing = Math.round(marketingSpend);
  finance.expenses.total = finance.expenses.payroll + finance.expenses.staff + finance.expenses.facilities + finance.expenses.marketing;
  finance.revenue.total = (finance.revenue.ticket||0) + (finance.revenue.merch||0) + (finance.revenue.media||0) + (finance.revenue.other||0);
  computeAttendanceForecast(tid);
}

function estimateGameAttendance(homeTid, awayTid){
  const finance = State.teamFinances[homeTid];
  if(!finance) return 12000;
  const baseForecast = computeAttendanceForecast(homeTid) || finance.attendance.capacity;
  const awayTeam = State.teams.find(t=>t.team_id===awayTid);
  const opponentDraw = awayTeam ? clamp(((awayTeam.power||60) - 50)/200, -0.05, 0.12) : 0;
  const rivalryBoost = awayTeam && awayTeam.league === State.teams.find(t=>t.team_id===homeTid)?.league ? 0.05 : 0;
  const forecast = Math.round(clamp(baseForecast * (1 + opponentDraw + rivalryBoost), 6000, finance.attendance.capacity));
  return forecast;
}

function applyGameFinancials(res){
  ensureTeamFinances();
  const homeFin = State.teamFinances[res.home_id];
  const awayFin = State.teamFinances[res.away_id];
  if(!homeFin || !awayFin) return;
  const attendance = estimateGameAttendance(res.home_id, res.away_id);
  homeFin.attendance.lastGame = attendance;
  homeFin.attendance.seasonTotal += attendance;
  homeFin.attendance.homeGames = (homeFin.attendance.homeGames||0) + 1;
  homeFin.attendance.average = Math.round(homeFin.attendance.seasonTotal / homeFin.attendance.homeGames);
  const ticketRevenue = Math.round(attendance * (homeFin.ticketPrice || DEFAULT_TICKET_PRICE));
  const homeShare = Math.round(ticketRevenue * 0.82);
  const awayShare = ticketRevenue - homeShare;
  homeFin.revenue.ticket += homeShare;
  awayFin.revenue.ticket += awayShare;
  homeFin.budget.reserves = (homeFin.budget.reserves||0) + homeShare;
  awayFin.budget.reserves = (awayFin.budget.reserves||0) + awayShare;
  homeFin.ledger.push({ day: res.day, type:'income', amount: homeShare, label:'å…¥å ´æ–™åŽå…¥' });
  awayFin.ledger.push({ day: res.day, type:'income', amount: awayShare, label:'ãƒ“ã‚¸ã‚¿ãƒ¼é…åˆ†' });
  if(homeFin.ledger.length>200) homeFin.ledger.shift();
  if(awayFin.ledger.length>200) awayFin.ledger.shift();
  const merchBoost = Math.round(attendance * (res.winner_id===res.home_id ? 480 : 320));
  if(res.winner_id===res.home_id) homeFin.revenue.merch += merchBoost; else awayFin.revenue.merch += merchBoost;
  updateFinancialSnapshots(res.home_id);
  updateFinancialSnapshots(res.away_id);
  if(attendance >= Math.round((homeFin.attendance.capacity||DEFAULT_STADIUM_CAPACITY) * 0.95)){
    logHighlight('ticket', `ã€æº€å“¡å¾¡ç¤¼ã€‘${id2name(res.home_id)}ã®ä¸»å‚¬è©¦åˆã«${attendance.toLocaleString()}äººãŒé›†ã¾ã‚Šã¾ã—ãŸï¼`, { category:'finance', financeType:'attendance', day: res.day });
  }
}

function updateDailyFinancials(day, gamesToday, restDay){
  ensureTeamFinances();
  const teams = State.teams.map(t=>t.team_id);
  teams.forEach(tid=>{
    const finance = State.teamFinances[tid];
    if(!finance) return;
    const dailyPayroll = Math.round((finance.expenses.payroll||0) / Math.max(180, State.schedule.length||180));
    const dailyStaff = Math.round((finance.expenses.staff||0)/210);
    const dailyFacilities = Math.round((finance.expenses.facilities||0)/240);
    const dailyMarketing = Math.round((finance.expenses.marketing||0)/180);
    const dailyExpenses = dailyPayroll + dailyStaff + dailyFacilities + dailyMarketing;
    finance.budget.reserves = (finance.budget.reserves||0) - dailyExpenses;
    finance.expenses.total += dailyExpenses;
    finance.ledger.push({ day, type:'expense', amount: dailyExpenses, label:'æ—¥æ¬¡é‹å–¶è²»' });
    if(finance.ledger.length>200) finance.ledger.shift();
    if(!restDay && gamesToday.some(evt=>evt.home_id===tid)){
      // ticket revenue handled in applyGameFinancials
    } else {
      // even onä¼‘é¤Šæ—¥ marketingæ´»å‹•
      const passiveRev = Math.round((finance.ticketPrice||DEFAULT_TICKET_PRICE) * (finance.attendance.forecast||12000) * 0.05);
      finance.revenue.media += passiveRev;
      finance.budget.reserves = (finance.budget.reserves||0) + passiveRev;
      finance.ledger.push({ day, type:'income', amount: passiveRev, label:'ãƒ¡ãƒ‡ã‚£ã‚¢åŽå…¥' });
      if(finance.ledger.length>200) finance.ledger.shift();
    }
    if(finance.budget.reserves < -500000000){
      logHighlight('alert-circle', `ã€è²¡å‹™å±æ©Ÿã€‘${id2name(tid)}ã®é‹è»¢è³‡é‡‘ãŒå¤§å¹…ãªãƒžã‚¤ãƒŠã‚¹ã«è»¢è½ã—ã¾ã—ãŸã€‚`, { category:'finance', financeType:'budget', day });
    }
    updateFinancialSnapshots(tid);
  });
}

function purgeFinanceContract(tid, playerId){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  finance.contracts = finance.contracts.filter(c=>c.playerId!==playerId);
}

function upsertFinanceContract(tid, player, contract){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  const summary = contractSummary(contract, player);
  const idx = finance.contracts.findIndex(c=>c.playerId===player.id);
  if(idx>=0) finance.contracts[idx]=summary; else finance.contracts.push(summary);
  finance.contracts.sort((a,b)=> (b.expectedAnnual||b.AAV||0) - (a.expectedAnnual||a.AAV||0));
  updateFinancialSnapshots(tid);
}

function removePlayerFromRoster(tid, playerId){
  const roster = State.rosters[tid];
  if(!roster) return null;
  let removed=null;
  let idx=roster.bats.findIndex(p=>p.id===playerId);
  if(idx>=0){ removed=roster.bats.splice(idx,1)[0]; }
  else {
    idx=roster.pits.findIndex(p=>p.id===playerId);
    if(idx>=0) removed=roster.pits.splice(idx,1)[0];
  }
  if(removed){
    if(State.squads?.[tid]){
      State.squads[tid].ichi = State.squads[tid].ichi.filter(id=>id!==playerId);
      State.squads[tid].ni = State.squads[tid].ni.filter(id=>id!==playerId);
    }
    if(State.rotation?.[tid]){
      State.rotation[tid].order = (State.rotation[tid].order||[]).filter(id=>id!==playerId);
    }
  }
  evaluateRosterComplianceForTeam(tid);
  return removed;
}

function addPlayerToRoster(tid, player){
  if(!State.rosters[tid]) State.rosters[tid]={bats:[],pits:[]};
  const roster = State.rosters[tid];
  const target = player.velo!=null ? roster.pits : roster.bats;
  if(!player.history) player.history = { overall:[getOverall(player)], fatigue:[player.fatigue||20], morale:[player.morale||60] };
  if(!player.recentGains) player.recentGains = [];
  ensurePlayerPersona(player);
  target.push(player);
  if(State.squadsInit && State.squads){
    if(!State.squads[tid]) State.squads[tid]={ichi:[],ni:[]};
    if(!State.squads[tid].ni.includes(player.id) && !State.squads[tid].ichi.includes(player.id)){
      State.squads[tid].ni.push(player.id);
    }
  }
  if(typeof ensureTrainingDefaults === 'function') ensureTrainingDefaults(tid);
  evaluateRosterComplianceForTeam(tid);
  return player;
}

function ensureRosterComplianceStore(){
  if(!State.rosterCompliance || typeof State.rosterCompliance !== 'object'){
    State.rosterCompliance = {};
  }
  return State.rosterCompliance;
}

function evaluateRosterComplianceForTeam(tid, { persist = true } = {}){
  ensureRosterComplianceStore();
  if(tid == null) return null;
  ensureSquads();
  const roster = State.rosters?.[tid];
  const squads = State.squads?.[tid];
  if(!roster || !squads){
    if(persist) delete State.rosterCompliance[tid];
    return null;
  }
  const validation = validateForeignPlayerLimits({
    bats: roster.bats,
    pits: roster.pits,
    activeIds: squads.ichi,
  }, State.league?.rules ?? {});
  const enriched = {
    ...validation,
    teamId: tid,
    timestamp: Date.now(),
  };
  if(persist){
    State.rosterCompliance[tid] = enriched;
  }
  if(!enriched.errors.length){
    hideRosterViolationModal();
  }
  if(persist) updateAdvanceButtonsState();
  return enriched;
}

function refreshRosterComplianceAll({ persist = true } = {}){
  ensureRosterComplianceStore();
  const results = {};
  (State.teams||[]).forEach(team => {
    const tid = team.team_id;
    const result = evaluateRosterComplianceForTeam(tid, { persist });
    if(result) results[tid] = result;
  });
  if(persist) updateAdvanceButtonsState();
  return persist ? State.rosterCompliance : results;
}

function getRosterCompliance(tid, { refresh = false } = {}){
  ensureRosterComplianceStore();
  if(refresh || !State.rosterCompliance[tid]){
    return evaluateRosterComplianceForTeam(tid, { persist: true });
  }
  return State.rosterCompliance[tid] || null;
}

function hasBlockingRosterViolations(tid = State.userTeamId ?? 0){
  ensureRosterComplianceStore();
  const record = State.rosterCompliance?.[tid];
  return Boolean(record && Array.isArray(record.errors) && record.errors.length>0);
}

function updateAdvanceButtonsState(){
  const disabled = hasBlockingRosterViolations();
  const btnToday = document.querySelector('#btnToday');
  if(btnToday) btnToday.disabled = disabled;
  const btnEnd = document.querySelector('#btnEnd');
  if(btnEnd) btnEnd.disabled = disabled;
  const warn = document.querySelector('#advanceWarning');
  if(warn){
    if(!disabled){
      warn.textContent = '';
    } else {
      const comp = getRosterCompliance(State.userTeamId ?? 0, { refresh: false }) || {};
      const { label } = comp;
      warn.textContent = `é€²è¡Œã§ãã¾ã›ã‚“ï¼š${label || 'ç™»éŒ²åˆ¶é™'}ãŒè§£æ¶ˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚¹ã‚¿ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
    }
  }
}

function releasePlayerToFreeAgency(tid, playerId, reason='å¥‘ç´„æº€äº†'){
  ensureFreeAgents();
  const player = removePlayerFromRoster(tid, playerId);
  if(!player) return null;
  purgeFinanceContract(tid, playerId);
  if(player.contract){
    player.contract.team_id = null;
    player.contract.status = 'free-agent';
    player.contract.yearsRemaining = 0;
    player.contract.daysRemaining = null;
  }
  const faState = ensureFreeAgencyState(State);
  const eligibility = determineFreeAgencyEligibility(player);
  const rankInfo = rankFreeAgent(player);
  const salaryHistory = Array.isArray(player.freeAgency?.salaryHistory)
    ? player.freeAgency.salaryHistory.slice(-4)
    : [];
  const currentSalary = player.contract?.AAV ?? player.contract?.salary ?? null;
  if(Number.isFinite(currentSalary)){
    salaryHistory.push(Number(currentSalary));
  }
  const metadata = {
    ...(player.freeAgency || {}),
    ...eligibility,
    ...rankInfo,
    salaryHistory,
    lastTeamId: tid,
    originTid: tid,
    declaredSeason: State.season ?? null,
    declaredDay: State.curr_day ?? null,
    compensation: null,
    status: 'free-agent',
  };
  player.freeAgency = metadata;
  faState.players[player.id] = {
    playerId: player.id,
    playerName: player.name,
    ...metadata,
  };
  State.freeAgents.push(player);
  logHighlight('badge-alert', `ã€${reason}ã€‘${player.name}ãŒFAå¸‚å ´ã«å‡ºã¾ã—ãŸã€‚`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
  recomputeAllRatingsAll();
  return player;
}

function negotiateContract(tid, playerId, offer={}){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return { success:false, reason:'no finance' };
  const teamPosture = finance.negotiationPosture || 'standard';
  let player = findPlayerById(tid, playerId);
  let isFreeAgent=false;
  let faIndex=-1;
  if(!player){
    ensureFreeAgents();
    faIndex = State.freeAgents.findIndex(p=>p.id===playerId);
    if(faIndex>=0){ player = State.freeAgents[faIndex]; isFreeAgent=true; }
  }
  if(!player) return { success:false, reason:'player not found' };
  ensurePlayerPersona(player);
  const overall = getOverall(player);
  const market = valuePlayerContract(player, { overall });
  const proposedTerms = {
    years: offer.years ?? offer.expectedYears ?? market.years,
    AAV: offer.AAV ?? offer.salary ?? offer.expectedSalary ?? market.AAV,
    incentives: offer.incentives,
    noTradeClause: offer.noTradeClause ?? market.noTradeClause,
  };
  const tolerance = player.contract?.status==='holdout' ? 0.88 : 0.92;
  const negotiation = evaluateNegotiation(player, proposedTerms, {
    market,
    tolerance,
    yearTolerance: 0.8,
    overall,
    persona: player.persona,
    teamPosture,
    isExtension: !isFreeAgent,
    random: Math.random,
  });
  if(negotiation.breakOff){
    if(player.contract){
      player.contract.status = 'holdout';
      player.contract.daysRemaining = Math.max(7, (player.contract.daysRemaining||18) + 4);
    }
    logHighlight('user-x', `ã€äº¤æ¸‰æ±ºè£‚ã€‘${player.name}ã¨ã®äº¤æ¸‰ãŒæ±ºè£‚ã—ã¾ã—ãŸã€‚`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
    return { success:false, reason:'talks broke off', decision:'break-off', expectation: negotiation.counter, probabilities: negotiation.probabilities };
  }
  if(!negotiation.accepted){
    if(player.contract){
      player.contract.status = 'negotiating';
      player.contract.daysRemaining = Math.max(5, (player.contract.daysRemaining||20) - 2);
    }
    return { success:false, reason:'offer rejected', decision:'retry', expectation: negotiation.counter, probabilities: negotiation.probabilities };
  }
  let contract = ensurePlayerContract(player, tid, State.season);
  contract = normalizeContract({
    ...contract,
    AAV: negotiation.terms.AAV,
    salary: negotiation.terms.AAV,
    incentives: negotiation.terms.incentives,
    noTradeClause: negotiation.terms.noTradeClause,
    totalYears: negotiation.terms.years,
    years: negotiation.terms.years,
    yearsRemaining: negotiation.terms.years,
    startSeason: State.season,
    expirySeason: State.season + negotiation.terms.years - 1,
    status: 'active',
    type: isFreeAgent ? 'free-agent' : 'extension',
    daysRemaining: negotiation.terms.years === 1 ? 90 : null,
    expectedAnnual: negotiation.terms.expectedAnnual,
  }, player, tid, State.season);
  player.contract = { ...contract };
  if(isFreeAgent){
    State.freeAgents.splice(faIndex,1);
    addPlayerToRoster(tid, player);
  }
  upsertFinanceContract(tid, player, contract);
  const incentiveText = contract.incentives?.total ? ` (ã‚¤ãƒ³ã‚»ãƒ³ãƒ†ã‚£ãƒ–è¨ˆ${millionFormatter(contract.incentives.total)})` : '';
  logHighlight('wallet', `ã€å¥‘ç´„åˆæ„ã€‘${player.name}ã¨${contract.totalYears}å¹´ AAV ${millionFormatter(contract.AAV)}${incentiveText}ã§åˆæ„ã—ã¾ã—ãŸã€‚`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
  if(typeof recomputeAllRatingsAll === 'function') recomputeAllRatingsAll();
  if(isFreeAgent){
    const compensation = processFreeAgentSigning(State, tid, player.id, {
      player,
      protectedList: (State.freeAgency?.protectedLists?.[tid]) || [],
      getOverall,
      removePlayerFromRoster,
      addPlayerToRoster,
      ensurePlayerContract,
      purgeFinanceContract,
      upsertFinanceContract,
      updateFinancialSnapshots,
      logHighlight,
      recomputeAllRatings: recomputeAllRatingsAll,
    });
    if(player.freeAgency){
      player.freeAgency.signedTid = tid;
      player.freeAgency.signedSeason = State.season ?? null;
      player.freeAgency.signedDay = State.curr_day ?? null;
      player.freeAgency.compensation = compensation;
    }
  }
  return { success:true, contract, terms: negotiation.terms, probabilities: negotiation.probabilities };
}

function proposeTrade(fromTid, toTid, outgoingIds=[], incomingIds=[], options={}){
  ensureTeamFinances();
  const outgoingPlayers = outgoingIds.map(pid=>findPlayerById(fromTid, pid));
  const incomingPlayers = incomingIds.map(pid=>findPlayerById(toTid, pid));
  if(outgoingPlayers.some(p=>!p) || incomingPlayers.some(p=>!p)){
    return { success:false, reason:'player not found' };
  }
  const outgoingValue = outgoingPlayers.reduce((sum,p)=>sum+getOverall(p),0);
  const incomingValue = incomingPlayers.reduce((sum,p)=>sum+getOverall(p),0);
  const cash = options.cash||0;
  const valueBuffer = (cash/50000000) + 3 + (outgoingPlayers.length + incomingPlayers.length)*0.5;
  if(!options.force && incomingValue > outgoingValue + valueBuffer){
    return { success:false, reason:'valuation mismatch' };
  }
  outgoingPlayers.forEach(player=>{
    removePlayerFromRoster(fromTid, player.id);
    purgeFinanceContract(fromTid, player.id);
  });
  incomingPlayers.forEach(player=>{
    removePlayerFromRoster(toTid, player.id);
    purgeFinanceContract(toTid, player.id);
  });
  outgoingPlayers.forEach(player=>{
    ensurePlayerContract(player, toTid, State.season);
    addPlayerToRoster(toTid, player);
    upsertFinanceContract(toTid, player, player.contract);
  });
  incomingPlayers.forEach(player=>{
    ensurePlayerContract(player, fromTid, State.season);
    addPlayerToRoster(fromTid, player);
    upsertFinanceContract(fromTid, player, player.contract);
  });
  if(cash){
    State.teamFinances[fromTid].budget.reserves = (State.teamFinances[fromTid].budget.reserves||0) - cash;
    State.teamFinances[toTid].budget.reserves = (State.teamFinances[toTid].budget.reserves||0) + cash;
  }
  updateFinancialSnapshots(fromTid);
  updateFinancialSnapshots(toTid);
  const summaryText = `ã€ãƒˆãƒ¬ãƒ¼ãƒ‰æˆç«‹ã€‘${id2name(fromTid)} â‡„ ${id2name(toTid)} (${outgoingPlayers.length}â‡”${incomingPlayers.length})`;
  logHighlight('handshake', summaryText, { category:'finance', financeType:'trade', tid: fromTid, day: State.curr_day });
  if(typeof recomputeAllRatingsAll === 'function') recomputeAllRatingsAll();
  return { success:true, outgoing:outgoingPlayers, incoming:incomingPlayers };
}

function processContractCountdown(day){
  ensureTeamFinances();
  State.teams.forEach(team=>{
    const tid=team.team_id;
    const finance=State.teamFinances[tid];
    if(!finance) return;
    finance.contracts.slice().forEach(contract=>{
      if(contract.status==='active'){
        if(contract.yearsRemaining<=1){
          contract.daysRemaining = (contract.daysRemaining ?? 90) - 1;
          if(contract.daysRemaining===15){
            logHighlight('alarm-clock', `ã€å¥‘ç´„æœŸé™è¿«ã‚‹ã€‘${contract.name}ã¨ã®äº¤æ¸‰æœŸé™ãŒè¿«ã£ã¦ã„ã¾ã™ã€‚`, { category:'finance', financeType:'contract', tid, day });
          }
          if(contract.daysRemaining<=0){
            releasePlayerToFreeAgency(tid, contract.playerId, 'å¥‘ç´„æº€äº†');
            contract.status='expired';
          }
        }
      } else if(contract.status==='negotiating'){
        contract.daysRemaining = (contract.daysRemaining ?? 10) - 1;
        if(contract.daysRemaining<=0){
          releasePlayerToFreeAgency(tid, contract.playerId, 'äº¤æ¸‰æ±ºè£‚');
          contract.status='expired';
        }
      }
    });
    finance.contracts = finance.contracts.filter(c=>c.status!=='expired');
    updateFinancialSnapshots(tid);
  });
}

// ====== Ratings, Schedule & Simulation ======
function battingScore(player, oppHand="R"){ const platoon=(oppHand==="R"&&player.hand==="L")?1.08:(oppHand==="L"&&player.hand==="R")?1.05:1.0; return (0.5*player.con+0.2*player.disc+0.25*player.pwr+0.05*player.spd)*platoon }
function recomputeTeamRatings(team, roster, ichiSet){
  const batsAll=roster.bats.slice(); const pitsAll=roster.pits.slice();
  const bats=(ichiSet?batsAll.filter(batter=>ichiSet.has(batter.id)):batsAll).sort((a,b)=>battingScore(b,"R")-battingScore(a,"R")).slice(0,9);
  const sp5=(ichiSet?pitsAll.filter(p=>p.role==="SP"&&ichiSet.has(p.id)):pitsAll.filter(p=>p.role==="SP")).sort((a,b)=>(b.stam*.2+b.velo*.4+b.mov*.3+b.ctrl*.1)-(a.stam*.2+a.velo*.4+a.mov*.3+a.ctrl*.1)).slice(0,5);
  const rp5=(ichiSet?pitsAll.filter(p=>p.role!=="SP"&&ichiSet.has(p.id)):pitsAll.filter(p=>p.role!=="SP")).sort((a,b)=>(b.velo*.45+b.mov*.35+b.ctrl*.2)-(a.velo*.45+a.mov*.35+a.ctrl*.2)).slice(0,5);
  const avg=(arr,f)=>arr.length?Math.round(arr.reduce((s,x)=>s+f(x),0)/arr.length):50;
  team.onbase=avg(bats,x=>(x.con*.7+x.disc*.3));
  team.power =avg(bats,x=>x.pwr);
  team.sp=avg(sp5,x=>(x.velo*.4+x.mov*.4+x.ctrl*.2));
  team.rp=avg(rp5,x=>(x.velo*.45+x.mov*.35+x.ctrl*.2));
  team.defense=avg(bats,x=>x.fld);
}
function roundRobin(teamIds,repeats=6,seed=42){
  const rng=mulberry32(seed>>>0); const teams=teamIds.slice(); if(teams.length%2===1)teams.push(null);
  const n=teams.length,half=n>>1,rounds=n-1; const base=[]; let arr=teams.slice();
  for(let r=0;r<rounds;r++){
    const pairs=[];
    for(let i=0;i<half;i++){
      const t1=arr[i],t2=arr[n-1-i];
      if(t1!==null&&t2!==null){ if(r%2===0)pairs.push([t1,t2]); else pairs.push([t2,t1]); }
    }
    base.push(pairs);
    arr=[arr[0],arr[n-1],...arr.slice(1,n-1)];
  }
  const sched=[]; let day=1; let seriesSeq=0;
  const pickSeriesLength=()=> (rng()<0.55?3:2);
  for(let k=0;k<repeats;k++){
    const order=[...base.keys()];
    for(let i=order.length-1;i>0;i--){const j=Math.floor(rng()*(i+1)); [order[i],order[j]]=[order[j],order[i]];}
    for(const idx of order){
      const pairs=base[idx]; if(!pairs.length) continue;
      const seriesLength=pickSeriesLength();
      seriesSeq++;
      for(let g=1; g<=seriesLength; g++){
        for(const [h,a] of pairs){ sched.push({day,type:'game',home_id:h,away_id:a,seriesGame:g,seriesLength,seriesKey:seriesSeq}); }
        day++;
      }
      const isLastSeries=(k===repeats-1) && (idx===order[order.length-1]);
      if(!isLastSeries){ sched.push({day,type:'rest'}); day++; }
    }
  }
  return sched;
}

function samplePoisson(lambda,rng){const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rng()}while(p>L&&k<200); return k-1}
const offenseIndex=(onb,pow)=>clamp(0.6*(onb/50)+0.4*(pow/50),.4,2.0);
const pitMul=v=>clamp(50.0/v,.4,2.0); const defMul=v=>clamp(60.0/v,.7,2.0);
function expectedRunsSplit(att, opp, homeAdv=0.05, base=4.1){
  const attMods = (State.teamMods?.[att.team_id]) || {};
  const oppMods = (State.teamMods?.[opp.team_id]) || {};
  const wSP=0.65, wRP=0.35;
  const onb = clamp(att.onbase + (attMods.onb||0), 30, 99);
  const pow = clamp(att.power + (attMods.pow||0), 30, 99);
  const spO = clamp(opp.sp + (oppMods.sp||0), 30, 99);
  const rpO = clamp(opp.rp + (oppMods.rp||0), 30, 99);
  const defO= clamp(opp.defense + (oppMods.def||0), 30, 99);
  const off = offenseIndex(onb, pow);
  const muSP=base*off*pitMul(spO)*defMul(defO);
  const muRP=base*off*pitMul(rpO)*defMul(defO);
  let mu=wSP*muSP + wRP*muRP;
  mu*=(1+homeAdv);
  return clamp(mu, 0.5, 12.0);
}
function simulateGamePoissonLegacy(pair,rngSeed){
  const rng=mulberry32(rngSeed>>>0);
  const tH=State.teams.find(t=>t.team_id===pair.home_id), tA=State.teams.find(t=>t.team_id===pair.away_id);
  let rh=samplePoisson(expectedRunsSplit(tH,tA,State.home_adv,4.1),rng);
  let ra=samplePoisson(expectedRunsSplit(tA,tH,0.0,4.1),rng);
  let inn=9, extra=0;
  const mH = (State.teamMods?.[pair.home_id]) || {};
  const mA = (State.teamMods?.[pair.away_id]) || {};
  const exH = clamp(0.6 + (mH.extraAtk||0) - (mA.extraDef||0), 0.2, 1.2);
  const exA = clamp(0.6 + (mA.extraAtk||0) - (mH.extraDef||0), 0.2, 1.2);
  while(rh===ra && extra<12){ rh+=samplePoisson(exH, rng); ra+=samplePoisson(exA, rng); extra++; inn++; }
  if(rh===ra){ const bias = clamp(0.5 + ((mH.extraAtk||0) - (mA.extraAtk||0))*0.5, 0.2, 0.8); (rng()<bias) ? rh++ : ra++; inn++; }
  return {home_id:pair.home_id,away_id:pair.away_id,home_runs:rh,away_runs:ra,innings:inn,winner_id:(rh>ra)?pair.home_id:pair.away_id,day:State.curr_day};
}

function simulateGameSimple(pair,rngSeed){
  return simulateGamePoissonLegacy(pair,rngSeed);
}

function simulateGameDetailed(pair, rngSeed, rules, options={}){
  const day = options.day ?? State.curr_day ?? 1;
  const rng = mulberry32(rngSeed>>>0);
  const clampProb = (value, min, max)=>Math.max(min, Math.min(max, value));
  const cloneScore = (score)=>({ home:score.home, away:score.away });

  const prepareTeam = (tid, side)=>{
    const override = options?.lineups?.[side];
    const lineup = override || pickDayLineup(tid, day);
    const roster = State.rosters[tid] || { bats:[], pits:[] };
    const bats = [...(lineup?.bats||[])].filter(p=>p && !p.injury);
    for(const player of roster.bats){
      if(bats.length>=9) break;
      if(player && !player.injury && !bats.some(b=>b.id===player.id)) bats.push(player);
    }
    if(bats.length===0){
      bats.push(...roster.bats.slice(0,9));
    }
    const battingOrder = bats.slice(0,9).map((p,idx)=>({
      id:p?.id??`bat_${idx}`,
      name:p?.name||`Batter ${idx+1}`,
      pos:p?.pos || p?.position || '-',
      con:p?.con||60,
      disc:p?.disc||60,
      pwr:p?.pwr||60,
      spd:p?.spd||60,
      order:idx+1,
      raw:p
    }));
    const pitcherPool=[];
    if(lineup?.sp && !lineup.sp.injury) pitcherPool.push(lineup.sp);
    (lineup?.rps||[]).forEach(rp=>{ if(rp && !rp.injury && !pitcherPool.some(p=>p.id===rp.id)) pitcherPool.push(rp); });
    if(!pitcherPool.length){
      const pool = roster.pits.filter(p=>p && !p.injury);
      if(pool.length) pitcherPool.push(pool[0]);
    }
    const pitchers = pitcherPool.map((p,idx)=>({
      id:p?.id??`pit_${idx}`,
      name:p?.name||`Pitcher ${idx+1}`,
      role: idx===0 ? 'SP' : (p?.role||'RP'),
      velo:p?.velo||60,
      ctrl:p?.ctrl||60,
      mov:p?.mov||60,
      stam:p?.stam||60,
      outsLimit: idx===0 ? Math.round(15 + (p?.stam||60)/2) : Math.round(3 + Math.max(0,(p?.stam||55)-45)/6),
      raw:p,
      outsRecorded:0,
      runsAllowed:0,
      hitsAllowed:0,
      walksAllowed:0,
      strikeouts:0,
      homeRunsAllowed:0,
      entered:false
    }));
    if(!pitchers.length){
      pitchers.push({ id:`pit_auto_${tid}`, name:'ç·Šæ€¥æŠ•æ‰‹', role:'RP', velo:60, ctrl:60, mov:60, stam:60, outsLimit:9, raw:null, outsRecorded:0, runsAllowed:0, hitsAllowed:0, walksAllowed:0, strikeouts:0, homeRunsAllowed:0, entered:false });
    }
    return {
      side,
      team_id:tid,
      battingOrder,
      pitchers,
      battingStats:new Map(),
      pitchingStats:new Map(),
      orderIndex:0,
      currentPitcherIndex:0
    };
  };

  const home = prepareTeam(pair.home_id, 'home');
  const away = prepareTeam(pair.away_id, 'away');
  const scoreboard = { home:0, away:0 };
  const events=[];
  const innings=[];
  const keyMoments=[];
  const pitcherTimeline={ home:[], away:[] };
  const PROBABILITY_LIMITS={
    walkProb:[0.01,0.28],
    strikeProb:[0.04,0.45],
    hrProb:[0.005,0.24],
    hitProb:[0.10,0.65]
  };
  const adjustProbabilityWithSpecials=(base,key,adjustments)=>{
    const mod=adjustments?.[key];
    let value=base;
    if(mod){
      if(typeof mod.mult==='number') value*=mod.mult;
      if(typeof mod.add==='number') value+=mod.add;
    }
    const [min,max]=PROBABILITY_LIMITS[key]||[0,1];
    return clampProb(value,min,max);
  };
  const specialEngine=createPlateAppearanceSpecialEngine();

  const ensureBatterStats=(team,batter)=>{
    if(!batter) return null;
    if(!team.battingStats.has(batter.id)){
      team.battingStats.set(batter.id,{
        id:batter.id,
        name:batter.name,
        order:batter.order,
        pos:batter.pos,
        AB:0,H:0,HR:0,RBI:0,BB:0,SO:0,R:0,PA:0
      });
    }
    return team.battingStats.get(batter.id);
  };

  const ensurePitchingStats=(team,pitcher)=>{
    if(!pitcher) return null;
    if(!team.pitchingStats.has(pitcher.id)){
      team.pitchingStats.set(pitcher.id,{
        id:pitcher.id,
        name:pitcher.name,
        role:pitcher.role,
        outs:0,
        ER:0,
        R:0,
        H:0,
        BB:0,
        SO:0,
        HR:0
      });
    }
    return team.pitchingStats.get(pitcher.id);
  };

  const createRunner=(team,batter)=>({
    id:batter.id,
    name:batter.name,
    pos:batter.pos,
    order:batter.order,
    spd:batter.spd||60,
    side:team.side,
    stats:ensureBatterStats(team,batter)
  });

  const markPitcherEntry=(team,pitcher,inning,half)=>{
    if(!pitcher.entered){
      pitcher.entered=true;
      pitcherTimeline[team.side].push({
        id:pitcher.id,
        name:pitcher.name,
        role:pitcher.role,
        entered:{inning,half},
        exit:null,
        outs:0,
        runs:0
      });
    }
  };

  const markPitcherExit=(team,pitcher,inning,half)=>{
    const entry=pitcherTimeline[team.side].find(e=>e.id===pitcher.id && !e.exit);
    if(entry){
      entry.exit={inning,half};
      entry.outs=pitcher.outsRecorded;
      entry.runs=pitcher.runsAllowed;
    }
  };

  const updateTimeline=(team,pitcher)=>{
    const entry=pitcherTimeline[team.side].find(e=>e.id===pitcher.id && !e.exit);
    if(entry){
      entry.outs=pitcher.outsRecorded;
      entry.runs=pitcher.runsAllowed;
    }
  };

  const maybeSwitchPitcher=(defTeam, inning, half)=>{
    const pitcher=defTeam.pitchers[defTeam.currentPitcherIndex];
    if(!pitcher) return;
    const outsLimit=pitcher.outsLimit || 18;
    const runLimit=pitcher.role==='SP'?5:3;
    if((pitcher.outsRecorded>=outsLimit || pitcher.runsAllowed>=runLimit) && defTeam.currentPitcherIndex < defTeam.pitchers.length-1){
      markPitcherExit(defTeam,pitcher,inning,half);
      defTeam.currentPitcherIndex++;
      const next=defTeam.pitchers[defTeam.currentPitcherIndex];
      if(next) next.entered=false;
    }
  };

  const advanceWalk=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1) next[2]=b1;
    if(b0) next[1]=b0;
    next[0]=runner;
    return { bases:next, scored };
  };

  const advanceSingle=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1){
      if(rng()<0.65 + clampProb((b1.spd||60)-50, -40, 60)/220){ scored.push(b1); }
      else next[2]=b1;
    }
    if(b0){
      const goThird=rng()<0.5 + clampProb((b0.spd||60)-55, -40, 60)/230;
      if(goThird && !next[2]) next[2]=b0; else next[1]=b0;
    }
    next[0]=runner;
    return { bases:next, scored };
  };

  const advanceDouble=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1) scored.push(b1);
    if(b0){
      if(rng()<0.55 + clampProb((b0.spd||60)-55, -40, 60)/220){ scored.push(b0); }
      else next[2]=b0;
    }
    next[1]=runner;
    return { bases:next, scored };
  };

  const advanceTriple=(bases,runner)=>{
    const scored=[];
    bases.forEach(r=>{ if(r) scored.push(r); });
    return { bases:[null,null,runner], scored };
  };

  const advanceHomer=(bases,runner)=>{
    const scored=[...bases.filter(Boolean), runner];
    return { bases:[null,null,null], scored };
  };

  const applyScores=(scored,pitcher,pitchStats)=>{
    let runs=0;
    for(const runner of scored){
      if(runner.side==='home') scoreboard.home++; else scoreboard.away++;
      if(runner.stats) runner.stats.R = (runner.stats.R||0)+1;
      runs++;
    }
    if(runs>0){
      pitchStats.ER += runs;
      pitchStats.R += runs;
      pitcher.runsAllowed += runs;
    }
    return runs;
  };

  const registerKeyMoment=(desc, inning, half, side, scoreBefore, scoreAfter, playerId=null)=>{
    keyMoments.push({ description:desc, inning, half, side, before:scoreBefore, score:scoreAfter, playerId });
  };

  const plateAppearance=(battingTeam, defTeam, inning, half, halfState)=>{
    const batter=battingTeam.battingOrder[battingTeam.orderIndex % battingTeam.battingOrder.length];
    battingTeam.orderIndex++;
    const batterStats=ensureBatterStats(battingTeam,batter);
    const pitcher=defTeam.pitchers[defTeam.currentPitcherIndex];
    if(!pitcher) return;
    markPitcherEntry(defTeam,pitcher,inning,half);
    const pitchStats=ensurePitchingStats(defTeam,pitcher);
    const basesBefore=halfState.bases.map(r=>r?{id:r.id,name:r.name}:null);
    const outsBefore=halfState.outs;
    const scoreBefore=cloneScore(scoreboard);

    batterStats.PA++;

    let walkProb=clampProb(0.07 + (batter.disc - pitcher.ctrl)/280, 0.02, 0.22);
    let strikeProb=clampProb(0.18 + (pitcher.velo - batter.con)/320, 0.06, 0.35);
    let hrProb=clampProb(0.04 + (batter.pwr - pitcher.mov)/260, 0.01, 0.18);
    let hitProb=clampProb(0.27 + (batter.con - pitcher.mov)/260, 0.12, 0.55);

    const batterPlayer=batter?.raw||batter;
    const pitcherPlayer=pitcher?.raw||pitcher;
    let specialTriggers=[];
    let specialSummary=null;
    let specialCommentary=null;
    const specialResult=specialEngine.evaluate({
      batter:batterPlayer,
      pitcher:pitcherPlayer,
      context:{
        inning,
        half,
        outs:halfState.outs,
        bases:halfState.bases,
        scoreBefore,
        battingTeam,
        defTeam
      },
      batterStats,
      pitcherStats:pitchStats
    });
    if(specialResult){
      walkProb=adjustProbabilityWithSpecials(walkProb,'walkProb',specialResult.adjustments);
      strikeProb=adjustProbabilityWithSpecials(strikeProb,'strikeProb',specialResult.adjustments);
      hrProb=adjustProbabilityWithSpecials(hrProb,'hrProb',specialResult.adjustments);
      hitProb=adjustProbabilityWithSpecials(hitProb,'hitProb',specialResult.adjustments);
      specialTriggers=Array.isArray(specialResult.triggered)?specialResult.triggered.slice():[];
      const summaryParts=specialTriggers.map(entry=>entry.summary||entry.name).filter(Boolean);
      if(summaryParts.length) specialSummary=summaryParts.join(' / ');
      const commentaryParts=Array.isArray(specialResult.commentary)?specialResult.commentary.filter(Boolean):[];
      if(commentaryParts.length){
        specialCommentary=commentaryParts.join(' / ');
      } else if(specialTriggers.length){
        specialCommentary=`ç‰¹èƒ½ç™ºå‹•: ${specialTriggers.map(entry=>entry.name).join('ãƒ»')}`;
      }
    }

    let total=walkProb+strikeProb+hrProb+hitProb;
    if(total>0.96){
      const scale=0.96/total;
      walkProb*=scale; strikeProb*=scale; hrProb*=scale; hitProb*=scale;
    }

    const r=rng();
    let result='out';
    let description='';
    let newBases=halfState.bases.slice();
    let scored=[];
    let outsAdded=0;
    let rbi=0;
    let countAB=true;
    let eventRBI=0;

    if(r < walkProb){
      result='walk';
      description=`${batter.name} å››çƒã§å‡ºå¡`;
      const move=advanceWalk(halfState.bases, createRunner(battingTeam,batter));
      newBases=move.bases;
      scored=move.scored;
      rbi=scored.length;
      eventRBI=rbi;
      countAB=false;
      batterStats.BB++;
      pitchStats.BB++;
      pitcher.walksAllowed++;
    } else if(r < walkProb + strikeProb){
      result='strikeout';
      description=`${batter.name} ç©ºæŒ¯ã‚Šä¸‰æŒ¯`;
      outsAdded=1;
      batterStats.SO++;
      pitchStats.SO++;
      pitcher.strikeouts++;
    } else if(r < walkProb + strikeProb + hrProb){
      result='home_run';
      const move=advanceHomer(halfState.bases, createRunner(battingTeam,batter));
      newBases=move.bases;
      scored=move.scored;
      const runLabel=scored.length===4?'æº€å¡':scored.length===3?'3ãƒ©ãƒ³':scored.length===2?'2ãƒ©ãƒ³':'ã‚½ãƒ­';
      description=`${batter.name} ã®${runLabel}ãƒ›ãƒ¼ãƒ ãƒ©ãƒ³ï¼`;
      batterStats.H++;
      batterStats.HR++;
      pitchStats.H++;
      pitchStats.HR++;
      pitcher.hitsAllowed++;
      pitcher.homeRunsAllowed++;
    } else if(r < walkProb + strikeProb + hrProb + hitProb){
      const hitRoll=rng();
      const tripleCut=clampProb(0.08 + (batter.spd-60)/320, 0.01, 0.12);
      const doubleCut=tripleCut + clampProb(0.24 + (batter.pwr-60)/260, 0.12, 0.35);
      if(hitRoll < tripleCut){
        result='triple';
        const move=advanceTriple(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} ä¸‰å¡æ‰“ï¼`;
      } else if(hitRoll < doubleCut){
        result='double';
        const move=advanceDouble(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} ãƒ„ãƒ¼ãƒ™ãƒ¼ã‚¹ï¼`;
      } else {
        result='single';
        const move=advanceSingle(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} ã‚¿ã‚¤ãƒ ãƒªãƒ¼ï¼`;
      }
      batterStats.H++;
      pitchStats.H++;
      pitcher.hitsAllowed++;
    } else {
      const ground=rng()<0.55;
      if(ground){
        const hasRunnerFirst=halfState.bases[0]!=null;
        const canDoublePlay=hasRunnerFirst && halfState.outs<=1;
        const doublePlay=canDoublePlay && rng()<0.22 + (pitcher.mov-60)/250;
        if(doublePlay){
          result='double_play';
          description=`${batter.name} ä½µæ®ºæ‰“`;
          newBases=[null, halfState.bases[1], halfState.bases[2]];
          outsAdded=2;
        } else {
          result='groundout';
          description=`${batter.name} ã‚´ãƒ­ã‚¢ã‚¦ãƒˆ`;
          newBases=halfState.bases.slice();
          outsAdded=1;
          if(newBases[2] && halfState.outs<2 && rng()<0.55){
            scored=[newBases[2]];
            newBases[2]=null;
            result='groundout_rbi';
            description=`${batter.name} å†…é‡Žã‚´ãƒ­ã®é–“ã«1ç‚¹`;
            rbi=scored.length;
          }
        }
      } else {
        result='flyout';
        description=`${batter.name} ãƒ•ãƒ©ã‚¤ã‚¢ã‚¦ãƒˆ`;
        newBases=halfState.bases.slice();
        outsAdded=1;
        if(newBases[2] && halfState.outs<2 && rng()<0.58 + (batter.con-60)/320){
          scored=[newBases[2]];
          newBases[2]=null;
          result='sac_fly';
          description=`${batter.name} çŠ ç‰²ãƒ•ãƒ©ã‚¤ï¼`;
          rbi=scored.length;
          countAB=false;
        }
      }
    }

    if(countAB) batterStats.AB++;
    const runs=applyScores(scored, pitcher, pitchStats);
    if(['home_run','double','triple','single','walk'].includes(result)){
      batterStats.RBI += runs;
      eventRBI = runs;
    }
    if(result==='groundout_rbi' || result==='sac_fly'){
      const credited = rbi || runs;
      batterStats.RBI += credited;
      eventRBI = credited;
    }

    pitchStats.outs += outsAdded;
    pitcher.outsRecorded += outsAdded;
    halfState.bases=newBases;
    halfState.outs+=outsAdded;
    updateTimeline(defTeam,pitcher);

    const scoreAfter=cloneScore(scoreboard);
    events.push({
      inning,
      half,
      batter:{ id:batter.id, name:batter.name },
      pitcher:{ id:pitcher.id, name:pitcher.name },
      result,
      description,
      specials:specialTriggers,
      specialSummary,
      commentary:specialCommentary,
      basesBefore,
      basesAfter:newBases.map(r=>r?{id:r.id,name:r.name}:null),
      outsBefore,
      outsAfter:halfState.outs,
      runsScored:runs,
      rbi:eventRBI,
      scoreBefore,
      scoreAfter
    });

    if(runs>0){
      const battingSide=battingTeam.side;
      const otherSide=battingSide==='home'?'away':'home';
      const goAhead = scoreBefore[battingSide] <= scoreBefore[otherSide] && scoreAfter[battingSide] > scoreAfter[otherSide];
      const isWalkoff = half==='bottom' && inning>=9 && scoreAfter.home>scoreAfter.away;
      const bigMoment = runs>=3 || result==='home_run';
      if(goAhead || bigMoment || isWalkoff){
        registerKeyMoment(isWalkoff?`${description}ï¼ˆã‚µãƒ¨ãƒŠãƒ©ï¼‰`:description, inning, half, battingSide, scoreBefore, scoreAfter, batter.id);
      }
      if(isWalkoff) halfState.walkoff=true;
    }

    if(halfState.outs<3 && !halfState.walkoff){
      maybeSwitchPitcher(defTeam, inning, half);
    }
  };

  const playHalf=(battingTeam, defTeam, inning, half, halfOptions={})=>{
    const halfState={ outs:0, bases:[null,null,null], walkoff:false };
    if (halfOptions.ghostRunner) {
      halfState.bases[1] = createRunner(battingTeam, { id: 'ghost', name: 'Ghost Runner', spd: 80 });
    }
    const before=cloneScore(scoreboard);
    const indices=[];
    while(halfState.outs<3 && !halfState.walkoff){
      maybeSwitchPitcher(defTeam, inning, half);
      const idx=events.length;
      plateAppearance(battingTeam, defTeam, inning, half, halfState);
      if(events.length>idx) indices.push(idx); else break;
    }
    const after=cloneScore(scoreboard);
    const runs=battingTeam.side==='home'? (after.home-before.home):(after.away-before.away);
    return { runs, events:indices, scoreAfter:after, walkoff:halfState.walkoff };
  };

  let inning=1;
  const gameRules = {
    innings: rules.innings || 9,
    extraInnings: rules.extraInnings === Infinity ? 100 : (rules.extraInnings || 3),
    allowTie: rules.allowTie !== false,
    ghostRunner: rules.ghostRunner === true,
    ghostRunnerInning: rules.ghostRunnerInning || 10,
  };
  const maxInningsTotal = gameRules.innings + gameRules.extraInnings;
  let finished=false;

  while(!finished && inning <= maxInningsTotal){
    const isGhostRunnerInning = gameRules.ghostRunner && inning >= gameRules.ghostRunnerInning;
    const top=playHalf(away, home, inning, 'top', { ghostRunner: isGhostRunnerInning });
    const log={ inning, top:{ runs:top.runs, events:top.events, scoreAfter:top.scoreAfter } };
    if(top.walkoff){ innings.push(log); finished=true; break; }
    const bottom=playHalf(home, away, inning, 'bottom', { ghostRunner: isGhostRunnerInning });
    log.bottom={ runs:bottom.runs, events:bottom.events, scoreAfter:bottom.scoreAfter, walkoff:bottom.walkoff };
    innings.push(log);
    if(bottom.walkoff){ finished=true; break; }
    if(inning >= gameRules.innings && scoreboard.home!==scoreboard.away){ finished=true; break; }
    if (inning === maxInningsTotal && scoreboard.home === scoreboard.away) { finished = true; break; }
    inning++;
  }

  if(scoreboard.home===scoreboard.away && !gameRules.allowTie){
    const beforeTie=cloneScore(scoreboard);
    const bias = rng() < 0.5 ? 'home' : 'away';
    if(bias === 'home') scoreboard.home+=1; else scoreboard.away+=1;
    const afterTie=cloneScore(scoreboard);
    registerKeyMoment('å»¶é•·ã‚¿ã‚¤ãƒ–ãƒ¬ãƒ¼ã‚¯ã§ã‚µãƒ¨ãƒŠãƒ©å‹ã¡', inning, 'bottom', bias, beforeTie, afterTie, null);
    if(innings.length){
      const last=innings[innings.length-1];
      const targetHalf = bias === 'home' ? 'bottom' : 'top';
      if(last[targetHalf]){
        const prevScore=last[targetHalf].scoreAfter || beforeTie;
        const delta= (bias==='home' ? afterTie.home - (prevScore.home??beforeTie.home) : afterTie.away - (prevScore.away??beforeTie.away));
        last[targetHalf].runs = (last[targetHalf].runs||0) + delta;
        last[targetHalf].scoreAfter = afterTie;
        last[targetHalf].walkoff = true;
      } else {
        last[targetHalf]={ runs:1, events:[], scoreAfter:afterTie, walkoff:true };
      }
    } else {
      const homeRuns = bias === 'home' ? 1 : 0;
      const awayRuns = bias === 'away' ? 1 : 0;
      innings.push({ inning, top:{ runs:awayRuns, events:[], scoreAfter:afterTie }, bottom:{ runs:homeRuns, events:[], scoreAfter:afterTie, walkoff:true } });
    }
  }

  const finalInningNumber = innings.length ? innings[innings.length-1].inning : inning;

  const finalizePitchers=(team)=>{
    team.pitchers.forEach(p=>{
      if(p.entered){
        markPitcherExit(team,p,finalInningNumber,'end');
      }
      ensurePitchingStats(team,p);
    });
  };
  finalizePitchers(home);
  finalizePitchers(away);

  const mapTeamStats=(team)=>({
    batting:[...team.battingStats.values()].sort((a,b)=>a.order-b.order),
    pitching:team.pitchers.map(p=>{
      const stat=team.pitchingStats.get(p.id) || { outs:0, ER:0, R:0, H:0, BB:0, SO:0, HR:0 };
      return {
        id:p.id,
        name:p.name,
        role:p.role,
        outs:stat.outs || p.outsRecorded,
        IP:(stat.outs||p.outsRecorded)/3,
        ER:stat.ER,
        R:stat.R,
        H:stat.H,
        BB:stat.BB,
        SO:stat.SO,
        HR:stat.HR
      };
    })
  });

  const detail={
    events,
    innings,
    keyMoments,
    pitcherTimeline,
    stats:{
      home:mapTeamStats(home),
      away:mapTeamStats(away)
    },
    lineups:{
      home:{
        batting:home.battingOrder.map(b=>({ id:b.id, name:b.name, pos:b.pos, order:b.order })),
        pitchers:home.pitchers.map(p=>({ id:p.id, name:p.name, role:p.role }))
      },
      away:{
        batting:away.battingOrder.map(b=>({ id:b.id, name:b.name, pos:b.pos, order:b.order })),
        pitchers:away.pitchers.map(p=>({ id:p.id, name:p.name, role:p.role }))
      }
    }
  };

  const totalInnings = innings.length? innings[innings.length-1].inning : 9;
  return {
    home_id:pair.home_id,
    away_id:pair.away_id,
    home_runs:scoreboard.home,
    away_runs:scoreboard.away,
    innings:Math.max(totalInnings,9),
    winner_id:scoreboard.home>=scoreboard.away?pair.home_id:pair.away_id,
    day:day,
    detailed:detail
  };
}

function computeStandings(teams, results, rules = {}){
  const gameRules = rules.game || {};
  const rec = new Map();
  for(const t of teams) rec.set(t.team_id, { team:t.team, league:t.league, W:0, L:0, T:0 });
  for(const r of results){
    if(r.home_runs > r.away_runs){
      rec.get(r.home_id).W++;
      rec.get(r.away_id).L++;
    } else if (r.away_runs > r.home_runs) {
      rec.get(r.away_id).W++;
      rec.get(r.home_id).L++;
    } else {
      rec.get(r.home_id).T++;
      rec.get(r.away_id).T++;
    }
  }
  const rows = [...rec.entries()].map(([tid,v])=>{
    let g, pct;
    if (gameRules.winningPercentage === 'npb') {
      g = v.W + v.L;
      pct = g > 0 ? v.W / g : 0;
    } else {
      g = v.W + v.L + v.T;
      pct = g > 0 ? (v.W + v.T / 2) / g : 0;
    }
    return {team_id:tid, team:v.team, league:v.league, W:v.W, L:v.L, T:v.T, Pct:Math.round(pct*1000)/1000};
  }).sort((a,b) => b.Pct - a.Pct || b.W - a.W);
  if(rows.length > 0){
    const leadW = rows[0].W, leadL = rows[0].L;
    for(const r of rows) r.GB = ((leadW - r.W) + (r.L - leadL)) / 2;
  }
  return rows;
}

// ====== Playoffs Helpers ======
function defaultPlayoffState(){
  return { active:false, started:false, completed:false, stageIndex:0, stages:[], champion:null, runnerUp:null, seeds:{} };
}
function normalizePlayoffState(playoffs){
  if(!playoffs) return defaultPlayoffState();
  const base=defaultPlayoffState();
  base.active=!!playoffs.active;
  base.started=!!playoffs.started;
  base.completed=!!playoffs.completed;
  base.stageIndex=playoffs.stageIndex||0;
  base.champion=playoffs.champion??null;
  base.runnerUp=playoffs.runnerUp??null;
  base.seeds=playoffs.seeds||{};
  base.startedDay=playoffs.startedDay||null;
  base.stages=(playoffs.stages||[]).map(stage=>({
    name:stage.name,
    league:stage.league||null,
    series:(stage.series||[]).map(series=>({
      id:series.id,
      name:series.name,
      league:series.league||null,
      bestOf:series.bestOf||7,
      winsNeeded:series.winsNeeded||Math.floor(((series.bestOf||7))/2)+1,
      teams:(series.teams||[]).map(team=>({
        type:team.type|| (team.from? 'winner':'team'),
        from:team.from||null,
        seed:team.seed??null,
        team_id:team.team_id??null,
        name:team.name||null
      })),
      wins:{...(series.wins||{})},
      games:(series.games||[]).map(g=>({
        game:g.game,
        home_id:g.home_id,
        away_id:g.away_id,
        home_runs:g.home_runs,
        away_runs:g.away_runs,
        winner_id:g.winner_id,
        day:g.day
      })),
      completed:!!series.completed,
      winner:series.winner??null
    }))
  }));
  return base;
}
function ensurePlayoffState(){ if(!State.playoffs) State.playoffs=defaultPlayoffState(); return State.playoffs; }
function startPlayoffs(){
  ensurePlayoffState();
  const standings=computeStandings(State.teams, State.results||[], State.league.rules);
  if(!standings.length) return State.playoffs;
  const byLeague=new Map();
  standings.forEach(row=>{
    if(!byLeague.has(row.league)) byLeague.set(row.league, []);
    byLeague.get(row.league).push(row);
  });
  const playoffs=defaultPlayoffState();
  playoffs.active=true; playoffs.started=true; playoffs.stageIndex=0;
  updateSeasonStage('CS', State.curr_day||maxDay()+1);
  const stageFirst={ name:'ã‚¯ãƒ©ã‚¤ãƒžãƒƒã‚¯ã‚¹ã‚·ãƒªãƒ¼ã‚ºãƒ»ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ', series:[] };
  const stageFinal={ name:'ã‚¯ãƒ©ã‚¤ãƒžãƒƒã‚¯ã‚¹ã‚·ãƒªãƒ¼ã‚ºãƒ»ãƒ•ã‚¡ã‚¤ãƒŠãƒ«', series:[] };
  const stageJapan={ name:'æ—¥æœ¬ã‚·ãƒªãƒ¼ã‚º', series:[] };
  let centralFinalId=null, pacificFinalId=null;
  playoffs.seeds={};
  for(const [league, rows] of byLeague.entries()){
    const seeds=rows.slice(0,3);
    playoffs.seeds[league]=seeds.map((row,idx)=>({team_id:row.team_id, team:row.team, seed:idx+1}));
    if(seeds.length<2) continue;
    if(seeds.length>=3){
      const firstId=`${league.toLowerCase()}-first`;
      stageFirst.series.push({
        id:firstId,
        name:`${league==='Central'?'ã‚»ãƒ»ãƒªãƒ¼ã‚°':'ãƒ‘ãƒ»ãƒªãƒ¼ã‚°'} ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸`,
        league,
        bestOf:5,
        winsNeeded:3,
        teams:[
          {type:'team', team_id:seeds[1].team_id, seed:2, name:seeds[1].team},
          {type:'team', team_id:seeds[2].team_id, seed:3, name:seeds[2].team}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      const finalId=`${league.toLowerCase()}-final`;
      stageFinal.series.push({
        id:finalId,
        name:`${league==='Central'?'ã‚»ãƒ»ãƒªãƒ¼ã‚°':'ãƒ‘ãƒ»ãƒªãƒ¼ã‚°'} ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸`,
        league,
        bestOf:7,
        winsNeeded:4,
        teams:[
          {type:'team', team_id:seeds[0].team_id, seed:1, name:seeds[0].team},
          {type:'winner', from:firstId, seed:2, name:'ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆå‹è€…'}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      if(league==='Central') centralFinalId=finalId; else if(league==='Pacific') pacificFinalId=finalId;
    } else {
      const finalId=`${league.toLowerCase()}-final`;
      stageFinal.series.push({
        id:finalId,
        name:`${league==='Central'?'ã‚»ãƒ»ãƒªãƒ¼ã‚°':'ãƒ‘ãƒ»ãƒªãƒ¼ã‚°'} æ±ºå®šã‚·ãƒªãƒ¼ã‚º`,
        league,
        bestOf:7,
        winsNeeded:4,
        teams:[
          {type:'team', team_id:seeds[0].team_id, seed:1, name:seeds[0].team},
          {type:'team', team_id:seeds[1].team_id, seed:2, name:seeds[1].team}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      if(league==='Central') centralFinalId=finalId; else if(league==='Pacific') pacificFinalId=finalId;
    }
  }
  if(stageFirst.series.length>0) playoffs.stages.push(stageFirst);
  if(stageFinal.series.length>0) playoffs.stages.push(stageFinal);
  if(centralFinalId && pacificFinalId){
    stageJapan.series.push({
      id:'japan-series',
      name:'æ—¥æœ¬ã‚·ãƒªãƒ¼ã‚º',
      league:'Championship',
      bestOf:7,
      winsNeeded:4,
      teams:[
        {type:'winner', from:centralFinalId, seed:1, name:'ã‚»ä»£è¡¨'},
        {type:'winner', from:pacificFinalId, seed:1, name:'ãƒ‘ä»£è¡¨'}
      ],
      wins:{},
      games:[],
      completed:false,
      winner:null
    });
  }
  if(stageJapan.series.length>0) playoffs.stages.push(stageJapan);
  playoffs.startedDay=State.curr_day;
  if(!playoffs.stages.length){
    playoffs.active=false;
    playoffs.started=false;
    State.playoffs=playoffs;
    return playoffs;
  }
  State.playoffs=playoffs;
  logHighlight('trophy', `ã€ãƒã‚¹ãƒˆã‚·ãƒ¼ã‚ºãƒ³é–‹å¹•ã€‘${State.season}å¹´ç›®ã®ã‚¯ãƒ©ã‚¤ãƒžãƒƒã‚¯ã‚¹ã‚·ãƒªãƒ¼ã‚ºãŒé–‹å¹•ã—ã¾ã—ãŸï¼`);
  return playoffs;
}
function findPlayoffSeries(seriesId){
  if(!State.playoffs) return null;
  for(const stage of State.playoffs.stages){
    for(const series of stage.series){
      if(series.id===seriesId) return {stage, series};
    }
  }
  return null;
}
function resolvePlayoffTeam(entry){
  if(!entry) return null;
  if(entry.team_id!=null) return {team_id:entry.team_id, name:entry.name||id2name(entry.team_id), seed:entry.seed??null, from:entry.from||null};
  if(entry.type==='winner' && entry.from){
    const found=findPlayoffSeries(entry.from);
    if(found && found.series.completed && found.series.winner!=null){
      entry.team_id=found.series.winner;
      entry.name=id2name(entry.team_id);
      return {team_id:entry.team_id, name:entry.name, seed:entry.seed??null, from:entry.from};
    }
  }
  return null;
}
function playoffSeriesReady(series){
  if(!series) return false;
  const teams=series.teams.map(resolvePlayoffTeam);
  return teams.every(t=>t && t.team_id!=null);
}
function applyMoraleBonus(tid, bonus){
  const roster=State.rosters[tid];
  if(!roster) return;
  [...roster.bats, ...roster.pits].forEach(p=>{ p.morale=clamp((p.morale||60)+bonus,0,100); });
}
function finishPlayoffs(championId, runnerUpId){
  ensurePlayoffState();
  State.playoffs.active=false;
  State.playoffs.completed=true;
  State.playoffs.stageIndex = Math.max(0, (State.playoffs.stages.length||1) - 1);
  State.playoffs.champion=championId;
  State.playoffs.runnerUp=runnerUpId??null;
  State.playoffs.finishedDay=State.curr_day;
  logHighlight('crown', `ã€æ—¥æœ¬ä¸€ã€‘${id2name(championId)}ãŒé ‚ç‚¹ã«ç«‹ã¡ã¾ã—ãŸï¼`);
  dpGain(championId, 5);
  applyMoraleBonus(championId, 8);
  if(runnerUpId!=null){
    dpGain(runnerUpId, 2);
    applyMoraleBonus(runnerUpId, 4);
  }
  updateSeasonStage('POST', State.curr_day||maxDay());
}
function propagatePlayoffWinners(stage){
  if(!stage) return;
  for(const series of stage.series){
    if(!series.completed || series.winner==null) continue;
    for(const nextStage of State.playoffs.stages){
      for(const nextSeries of nextStage.series){
        nextSeries.teams.forEach(entry=>{
          if(entry.type==='winner' && entry.from===series.id && entry.team_id==null){
            entry.team_id=series.winner;
            entry.name=id2name(series.winner);
          }
        });
      }
    }
  }
}
function checkPlayoffStageCompletion(){
  if(!State.playoffs || !State.playoffs.active) return;
  let progressed=false;
  while(State.playoffs.stageIndex < State.playoffs.stages.length){
    const stage=State.playoffs.stages[State.playoffs.stageIndex];
    if(stage.series.some(s=>!s.completed)) break;
    propagatePlayoffWinners(stage);
    if(State.playoffs.stageIndex < State.playoffs.stages.length-1){
      State.playoffs.stageIndex++;
      progressed=true;
      logHighlight('flag', `ã€ã‚¹ãƒ†ãƒ¼ã‚¸çªç ´ã€‘${stage.name}ãŒå…¨æ—¥ç¨‹çµ‚äº†ã—ã¾ã—ãŸã€‚`);
      continue;
    }
    break;
  }
  const activeStage=State.playoffs.stages[State.playoffs.stageIndex];
  if(activeStage){
    const label = activeStage.name.includes('æ—¥æœ¬ã‚·ãƒªãƒ¼ã‚º') ? 'JS' : 'CS';
    updateSeasonStage(label, State.curr_day||maxDay());
  }
  return progressed;
}
function recordPlayoffGame(series, res){
  const gameNo=series.games.length+1;
  series.games.push({
    game:gameNo,
    home_id:res.home_id,
    away_id:res.away_id,
    home_runs:res.home_runs,
    away_runs:res.away_runs,
    winner_id:res.winner_id,
    day:res.day
  });
  series.wins[res.winner_id]=(series.wins[res.winner_id]||0)+1;
}
function playPlayoffGame(seriesId){
  const found=findPlayoffSeries(seriesId);
  if(!found) return false;
  const {stage, series}=found;
  if(series.completed) return false;
  const teams=series.teams.map(resolvePlayoffTeam);
  if(teams.some(t=>!t)) return false;
  const day=State.curr_day|| (maxDay()+1);
  tickDay();
  ensureSquads();
  recomputeAllRatingsAll();
  const homeFirst=teams[0];
  const awaySecond=teams[1];
  const gameIndex=series.games.length;
  const homeTeam = (gameIndex % 2 === 0) ? homeFirst : awaySecond;
  const awayTeam = (gameIndex % 2 === 0) ? awaySecond : homeFirst;
  const seedBase=State.seed||2025;
  const seed=seedBase + day*131 + gameIndex*17 + series.id.length*11;
  const playoffRules = getRulesetById('mlb-post');
  const res=simulateGameDetailed({home_id:homeTeam.team_id, away_id:awayTeam.team_id}, seed, playoffRules);
  res.day=day;
  recordPlayoffGame(series, res);
  allocateGameStats(res);
  dpGain(res.winner_id, 0.5);
  const loserId = (res.winner_id===homeTeam.team_id)?awayTeam.team_id:homeTeam.team_id;
  dpGain(loserId, 0.2);
  const scoreText=`${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
  logHighlight('medal', `ã€PO G${series.games.length}ã€‘${series.name}: ${scoreText}`);
  State.curr_day=day+1;
  if(series.wins[res.winner_id]>=series.winsNeeded){
    series.completed=true;
    series.winner=res.winner_id;
    const loserWins=series.wins[loserId]||0;
    logHighlight('flag', `ã€ã‚·ãƒªãƒ¼ã‚ºæ±ºç€ã€‘${id2name(res.winner_id)}ãŒ${series.name}ã‚’${series.wins[res.winner_id]}-${loserWins}ã§åˆ¶ã—ã¾ã—ãŸã€‚`);
    if(series.id==='japan-series'){
      finishPlayoffs(series.winner, loserId);
    } else {
      const stageIdx = State.playoffs.stages.indexOf(stage);
      const isLastStage = stageIdx === State.playoffs.stages.length - 1;
      if(isLastStage && stage.series.every(s=>s.completed) && !State.playoffs.completed){
        finishPlayoffs(series.winner, loserId);
      }
    }
  }
  checkPlayoffStageCompletion();
  return true;
}
function playNextPlayoffGame(){
  if(!State.playoffs || !State.playoffs.active) return false;
  checkPlayoffStageCompletion();
  const stage=State.playoffs.stages[State.playoffs.stageIndex];
  if(!stage) return false;
  const target=stage.series.find(s=>!s.completed && playoffSeriesReady(s));
  if(!target) return false;
  return playPlayoffGame(target.id);
}


// ====== NEW: Team Meta (Dev Points, Facilities, Coaches) ======
function defaultScoutingSetup(tid){
  const seed=((State.seed||2025) + tid*131)>>>0;
  const rng=mulberry32(seed);
  const staffLevel=()=>Math.floor(rng()*3);
  return {
    points: 8 + Math.round(rng()*4),
    maxPoints: 24,
    staff:{ lead: 1 + staffLevel(), bat: staffLevel(), pit: staffLevel() },
    assignments:{}
  };
}
function ensureTeamMeta(){
  ensureTeamFinances();
  if(!State.teamMeta) State.teamMeta={};
  for(const team of State.teams){
    const tid = team.team_id;
    let meta = State.teamMeta[tid];
    if(!meta){
      meta = {
        dp: 0,
        scouting: defaultScoutingSetup(tid),
        popularity: team.popularity ?? (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60)
      };
      State.teamMeta[tid] = meta;
    }
    if(meta.dp == null) meta.dp = 0;
    const facilities = ensureTeamFacilities(meta, tid);
    ensureTeamStaff(meta);
    if(!meta.scouting){
      meta.scouting = defaultScoutingSetup(tid);
    } else {
      meta.scouting.points = typeof meta.scouting.points==='number' ? meta.scouting.points : defaultScoutingSetup(tid).points;
      meta.scouting.maxPoints = meta.scouting.maxPoints || 24;
      meta.scouting.staff = meta.scouting.staff || defaultScoutingSetup(tid).staff;
      meta.scouting.assignments = meta.scouting.assignments || {};
    }
    if(facilities && facilities.recovery == null){
      facilities.recovery = facilities.medical ?? 0;
    }
    if(meta.popularity == null){
      meta.popularity = team.popularity ?? (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60);
    }
  }
  ensureTeamNeedsAll();
}
function updateTeamNeeds(tid){ if(!State?.teams) return null; const team=State.teams.find(t=>t.team_id===tid); if(!team) return null; return calculateDraftTeamNeeds(State, tid); }
function ensureTeamNeedsAll(){ if(!State?.teams) return; State.teams.forEach(team=>{ const needs=calculateDraftTeamNeeds(State, team.team_id); team.needs={ ...needs }; }); }
function dpGain(tid, amount){ ensureTeamMeta(); const m=State.teamMeta[tid]; m.dp=(m.dp||0)+amount; }
function dpSpend(tid, cost){ ensureTeamMeta(); const m=State.teamMeta[tid]; if((m.dp||0)>=cost){ m.dp-=cost; return true;} return false; }

function getTeamSupportAdjustments(tid){
  ensureTeamMeta();
  const meta = State.teamMeta[tid] || { facilities: {}, coaches: {} };
  return {
    staff: computeStaffAdjustments(meta.coaches || {}),
    facilities: computeFacilityAdjustments(meta.facilities || {})
  };
}

const SCOUT_ASSIGN_COST = 4;
function findDraftProspect(pid){
  const draft = State.draft && Array.isArray(State.draft.pool) ? State.draft : ensureDraftStateRecord(State);
  if(!Array.isArray(draft.pool)) return null;
  return draft.pool.find(p=>p.pid===pid);
}
function scoutingAssignmentLimit(meta){ return 2 + (meta?.scouting?.staff?.lead||0); }
function toggleScoutAssignment(tid, prospect){ ensureTeamMeta(); const meta=State.teamMeta[tid]; if(!meta?.scouting) return; const scouting=meta.scouting; scouting.assignments=scouting.assignments||{}; const assigned=scouting.assignments[prospect.pid]; if(assigned){ delete scouting.assignments[prospect.pid]; State.devLogs.push(`[ã‚¹ã‚«ã‚¦ãƒˆ] ${id2name(tid)}ã¯${prospect.name}ã®èª¿æŸ»ã‚’ä¸­æ­¢ã—ã¾ã—ãŸã€‚`); return; }
  const activeCount=Object.values(scouting.assignments).filter(a=>a&&a.active!==false).length; const limit=scoutingAssignmentLimit(meta);
  if(activeCount>=limit){ State.devLogs.push(`[ã‚¹ã‚«ã‚¦ãƒˆ] ${id2name(tid)}ã¯æ—¢ã«æœ€å¤§äººæ•°ã‚’èª¿æŸ»ä¸­ã§ã™ã€‚`); return; }
  if((scouting.points||0)<SCOUT_ASSIGN_COST){ State.devLogs.push(`[ã‚¹ã‚«ã‚¦ãƒˆ] ${id2name(tid)}ã¯èª¿æŸ»PtãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚`); return; }
  scouting.points=clamp((scouting.points||0)-SCOUT_ASSIGN_COST,0,scouting.maxPoints||24);
  scouting.assignments[prospect.pid]={ active:true, focus:prospect.type, started:State.curr_day||1 };
  const report=ensureProspectTeamReport(prospect, tid); if(report.progress<0.02){ report.progress+=0.02*(scouting.staff?.lead||0); }
  State.devLogs.push(`[ã‚¹ã‚«ã‚¦ãƒˆ] ${id2name(tid)}ãŒ${prospect.name}ã®è©³ç´°èª¿æŸ»ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚`);
}

function runScoutingTask(mode='daily'){
  const draft = ensureDraftStateRecord(State);
  if(!Array.isArray(draft.pool) || draft.pool.length===0) return;
  ensureTeamMeta();
  const isWeekly=mode==='weekly';
  for(const team of State.teams){
    const tid=team.team_id;
    const meta=State.teamMeta[tid];
    if(!meta?.scouting) continue;
    const scouting=meta.scouting;
    const staff=scouting.staff||{lead:1,bat:0,pit:0};
    const pointGainBase=isWeekly?3.5:0.6;
    const staffPointBonus=(staff.lead||0)*0.35;
    scouting.points=clamp((scouting.points||0)+pointGainBase+staffPointBonus,0,scouting.maxPoints||24);
    for(const [pid, assignment] of Object.entries(scouting.assignments||{})){
      if(!assignment || assignment.active===false) continue;
      const prospect=findDraftProspect(pid);
      if(!prospect){ delete scouting.assignments[pid]; continue; }
      ensureProspectStructure(prospect);
      const report=ensureProspectTeamReport(prospect, tid);
      const baseGain=isWeekly?0.18:0.05;
      const focusBonus=(prospect.type==='BAT'?(staff.bat||0):(staff.pit||0))*0.04;
      const leadBonus=(staff.lead||0)*0.08;
      const gain=baseGain*(1+focusBonus+leadBonus);
      const prev=report.progress||0;
      report.progress=clamp(prev+gain,0,1);
      report.lastUpdate=mode;
      if(report.progress>=1 && assignment.active){ assignment.active=false; assignment.completed=true; State.devLogs.push(`[ã‚¹ã‚«ã‚¦ãƒˆ] ${id2name(tid)}ã¯${prospect.name}ã®è©³ç´°æƒ…å ±ã‚’æŠŠæ¡ã—ã¾ã—ãŸã€‚`); }
    }
  }
}

// ====== Squads & Rotation ======
const SQUAD_MOVE_COOLDOWN_DAYS = 0;
function ensureSquads(){ if(State.squadsInit) return; initializePlayerSpecials(); State.squads={}; State.rotation={}; ensureTeamMeta();
  if(!State.squadMoveLog || typeof State.squadMoveLog !== 'object') State.squadMoveLog={};
  for(const t of State.teams){
    const R=State.rosters[t.team_id];
    // backfill data for older save files
    [...R.bats, ...R.pits].forEach(p => {
        if (p.morale === undefined) p.morale = 60;
        if (p.fatigue === undefined) p.fatigue = 20;
        if (!p.traits) p.traits = [];
        if (!p.status) p.status = { hot: 0, slump: 0 };
        if (p.injury === undefined) p.injury = null;
        if (p.role === 'RP' && !p.sub_role) p.sub_role = 'ä¸­ç¶™ãŽ';
        if (!p.history) p.history = { overall: [getOverall(p)], fatigue: [p.fatigue], morale: [p.morale] };
        if (!p.recentGains) p.recentGains = [];
        if (typeof p.isForeign !== 'boolean') p.isForeign = Boolean(p.isForeign);
        if (!p.origin) p.origin = p.isForeign ? 'international' : 'domestic';
        if(!Number.isFinite(p.lastSquadMoveDay)){
          const logDay=Number(State.squadMoveLog?.[p.id]);
          p.lastSquadMoveDay=Number.isFinite(logDay)?logDay:null;
        }
    });
    autoAssignSquads(t.team_id);
  }
  recomputeTeamModsAll(); State.squadsInit=true;
  refreshRosterComplianceAll();
}
function moveSquad(tid,pid,to,options={}){
  ensureSquads();
  const s=State.squads[tid];
  const opts=options||{};
  if(!s) return { ok:false, reason:'æ‰€å±žãƒãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' };
  const day=State.curr_day||1;
  const player=findPlayerById(tid,pid);
  const current=s.ichi.includes(pid)?'ä¸€è»':(s.ni.includes(pid)?'äºŒè»':null);
  if(current===to){
    return { ok:true, changed:false, from:current, to, playerName:player?.name||null };
  }
  const storedMove=Number(State.squadMoveLog?.[pid]);
  const lastMove=Number.isFinite(player?.lastSquadMoveDay)?player.lastSquadMoveDay: (Number.isFinite(storedMove)?storedMove:null);
  const cooldown=Math.max(0, opts.force?0:SQUAD_MOVE_COOLDOWN_DAYS);
  if(cooldown>0 && Number.isFinite(lastMove)){
    const availableDay=lastMove+cooldown;
    if(day<availableDay){
      const remaining=Math.max(1, availableDay-day);
      const teamName=id2name(tid);
      const playerName=player?.name||`ID:${pid}`;
      const direction=to==='ä¸€è»'?'æ˜‡æ ¼':'é™æ ¼';
      const reason=`${playerName}ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æœŸé–“ä¸­ã®ãŸã‚${direction}ã§ãã¾ã›ã‚“ã€‚`;
      const log=`[ç·¨æˆåˆ¶é™] ${teamName} ${playerName}ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã®ãŸã‚${direction}ä¸å¯ï¼ˆæ®‹ã‚Š${remaining}æ—¥ï¼‰`;
      if(!Array.isArray(State.devLogs)) State.devLogs=[];
      State.devLogs.push(log);
      const error={ type:'squad-move-cooldown', teamId:tid, playerId:pid, playerName, currentSquad:current, requestedSquad:to, remainingDays:remaining, cooldownDays:cooldown, availableDay, day };
      return { ok:false, reason, remainingDays:remaining, error };
    }
  }
  s.ichi=s.ichi.filter(x=>x!==pid);
  s.ni=s.ni.filter(x=>x!==pid);
  if(to==="ä¸€è»") s.ichi.push(pid); else s.ni.push(pid);
  if(!Array.isArray(State.devLogs)) State.devLogs=[];
  const teamName=id2name(tid);
  const playerName=player?.name||`ID:${pid}`;
  State.devLogs.push(`[ç·¨æˆ] ${teamName} ${playerName}ã‚’${to}ã¸ç§»å‹• (${day}æ—¥ç›®)`);
  if(player) player.lastSquadMoveDay=day;
  if(!State.squadMoveLog || typeof State.squadMoveLog !== 'object') State.squadMoveLog={};
  State.squadMoveLog[pid]=day;
  evaluateRosterComplianceForTeam(tid);
  return { ok:true, changed:true, from:current, to, day, playerName };
}

// ====== Roster AI & Strategy (v12) ======
function ensureTeamStrategy(tid){
  if(!State.teamStrategy) State.teamStrategy = {};
  if(!State.teamStrategy[tid]){
    State.teamStrategy[tid] = { roster: 'default', lineup: 'condition' };
  }
}

function getPlayerRosterValue(player, strategy = { roster: 'default' }) {
    if(player.injury) return 0.1; // Injured players have minimal value for roster assignment
    const isPitcher = !!player.velo;
    let rating, potential_w = 0.25, age_mod = 1.0;

    if (isPitcher) {
        rating = (player.velo * 0.35 + player.mov * 0.35 + player.ctrl * 0.2 + player.stam * 0.1);
    } else {
        rating = (0.35 * player.con + 0.1 * player.disc + 0.2 * player.pwr + 0.05 * player.spd + 0.3 * player.fld);
    }
    if (player.age < 24) age_mod = 1.03; 
    else if (player.age >= 25 && player.age <= 31) age_mod = 1.05;
    else if (player.age > 34) age_mod = 0.92;

    if (strategy.roster === 'youth') {
        potential_w = 0.5;
        if (player.age < 25) age_mod = 1.15;
        else if (player.age > 30) age_mod = 0.8;
    } else if (strategy.roster === 'veteran') {
        potential_w = 0.1;
        if (player.age > 32) age_mod = 1.1;
        else if (player.age < 26) age_mod = 0.9;
    } else { // default
        if (player.age < 27) potential_w = 0.4;
    }

    return (rating * (1 - potential_w) + player.pot * potential_w) * age_mod;
}

function autoAssignSquads(tid) {
    ensureTeamStrategy(tid);
    const strategy = State.teamStrategy[tid];
    const R = State.rosters[tid];

    const allPlayers = [...R.bats, ...R.pits].map(p => ({ player: p, value: getPlayerRosterValue(p, strategy) }));

    const bats = allPlayers.filter(item => !item.player.velo).sort((a, b) => b.value - a.value);
    const pitsSP = allPlayers.filter(item => item.player.velo && item.player.role === "SP").sort((a, b) => b.value - a.value);
    const pitsRP = allPlayers.filter(item => item.player.velo && item.player.role !== "SP").sort((a, b) => b.value - a.value);

    const ichi = new Set();
    bats.slice(0, 13).forEach(item => ichi.add(item.player.id));
    pitsSP.slice(0, 5).forEach(item => ichi.add(item.player.id));
    pitsRP.slice(0, 8).forEach(item => ichi.add(item.player.id));

    const ni = [...R.bats, ...R.pits].filter(p => !ichi.has(p.id)).map(p => p.id);

  State.squads[tid] = { ichi: [...ichi], ni: [...ni] };
  State.rotation[tid] = { order: pitsSP.slice(0, 5).map(p => p.player.id), idx: 0 };

  logHighlight('shuffle', `[${id2name(tid)}] ãƒ­ãƒ¼ã‚¹ã‚¿ãƒ¼è‡ªå‹•ç·¨æˆã‚’å®Ÿè¡Œã—ã¾ã—ãŸã€‚(æ–¹é‡: ${strategy.roster})`);
}

function autoFixRosterViolations(tid){
  const compliance = getRosterCompliance(tid, { refresh: true });
  if(!compliance) return;
  const squads = State.squads?.[tid];
  if(!squads) return;

  const foreignIds = Array.isArray(compliance.foreignPlayers) ? compliance.foreignPlayers : [];
  if(!foreignIds.length){
    evaluateRosterComplianceForTeam(tid, { persist: true });
    refreshIcons?.();
    updateAdvanceButtonsState?.();
    return;
  }

  const ichi = Array.isArray(squads.ichi) ? squads.ichi.filter(pid => !foreignIds.includes(pid)) : [];
  const niBase = Array.isArray(squads.ni) ? squads.ni.filter((pid, idx, arr) => arr.indexOf(pid) === idx) : [];
  const ni = [...niBase];
  foreignIds.forEach(pid => {
    if(!ni.includes(pid)) ni.push(pid);
  });

  State.squads[tid] = { ichi, ni };

  evaluateRosterComplianceForTeam(tid, { persist: true });
  refreshIcons?.();
  updateAdvanceButtonsState?.();
}

// ====== Lineup Selection (v12 Natural) ======
function gameDayBattingScore(player, oppHand = "R", strategy = { lineup: 'condition' }) {
    let score = battingScore(player, oppHand);
    const fatigue = player.fatigue || 0;
    const morale = player.morale || 60;
    
    let fatigue_penalty = fatigue / 180;
    if (strategy.lineup === 'best_member') {
        fatigue_penalty = fatigue / 300; // Reduce fatigue penalty
    }

    score *= (1 - fatigue_penalty); 
    score *= (1 + (morale - 60) / 200);
    if (player.status?.hot > 0) score *= 1.15;
    if (player.status?.slump > 0) score *= 0.85;
    return Math.max(score, 0);
}

function relieverReadinessScore(p) {
    const rating = p.velo * 0.45 + p.mov * 0.35 + p.ctrl * 0.2;
    const fatigue = p.fatigue || 0;
    return rating * (1 - (fatigue / 110));
}

function pickDayLineup(tid, dayOverride=null){
  ensureSquads();
  ensureTeamStrategy(tid);
  const strategy = State.teamStrategy[tid];
  const R=State.rosters[tid];
  const ichi=new Set(State.squads[tid].ichi);

  const gameDay = dayOverride ?? (State.curr_day||1);
  const hasGameToday = State.schedule.some(evt=>evt.day===gameDay && (evt?.type||'game')==='game' && (evt.home_id===tid || evt.away_id===tid));
  if(!hasGameToday){
    return {bats:[],sp:null,rps:[]};
  }

  const bats=R.bats.filter(batter=>ichi.has(batter.id) && !batter.injury).sort((a,b)=>gameDayBattingScore(b,"R", strategy)-gameDayBattingScore(a,"R", strategy)).slice(0,9);

  const SPorder=State.rotation[tid]?.order||[];
  let idx=State.rotation[tid]?.idx||0;
  let sp = null;
  let spFound = false;
  for(let i=0; i<SPorder.length; i++){
    const currentIdx = (idx + i) % SPorder.length;
    const potentialSpId = SPorder[currentIdx];
    const potentialSp = R.pits.find(p => p.id === potentialSpId);
    if(potentialSp && !potentialSp.injury && (potentialSp.fatigue || 0) < 80) {
        sp = potentialSp;
        idx = (currentIdx + 1) % SPorder.length;
        spFound = true;
        break;
    }
  }
  
  if (!spFound) {
    sp = R.pits.filter(p => p.role === "SP" && ichi.has(p.id) && !p.injury)
               .sort((a,b) => (a.fatigue || 0) - (b.fatigue || 0))[0];
  }
  State.rotation[tid]={order:SPorder,idx};
  
  const rps=R.pits.filter(p=>p.role!=="SP" && ichi.has(p.id) && !p.injury)
    .sort((a,b)=> relieverReadinessScore(b) - relieverReadinessScore(a))
    .slice(0,5);
  
  return {bats,sp,rps};
}


// ====== Training System (v12) ======
const FOCUS_BAT=["Con","Disc","Pwr","Spd","Fld"], FOCUS_PIT=["Velo","Ctrl","Mov","Stam"]; const INTENS={"è»½":0.7,"æ¨™æº–":1.0,"å¼·":1.3};
function ageCurve(age){ if(age<=22) return 1.20; if(age<=27) return 1.00; if(age<=31) return 0.85; return 0.60; }
function ensureTrainingDefaults(tid){ const tp=State.trainingPlans[tid]||{}; const R=State.rosters[tid]; for(const batter of R.bats){ if(!tp[batter.id]) tp[batter.id]={focus:(batter.pwr<batter.con?"Pwr":"Con"),intens:"æ¨™æº–"}; if(!batter.status) batter.status={hot:0,slump:0}; }
  for(const p of R.pits){ if(!tp[p.id]) tp[p.id]={focus:(p.ctrl<p.velo?"Ctrl":"Mov"),intens:"æ¨™æº–"}; if(!p.status) p.status={hot:0,slump:0}; } State.trainingPlans[tid]=tp; }
function autoPlan(tid){ const tp=State.trainingPlans[tid]||{}; const R=State.rosters[tid]; for(const batter of R.bats){ const gapCon=batter.pot-batter.con, gapPwr=batter.pot-batter.pwr; tp[batter.id]={focus:(gapCon>gapPwr)?"Con":"Pwr",intens:"æ¨™æº–"}; } for(const p of R.pits){ const gaps=[["Ctrl",p.pot-p.ctrl],["Mov",p.pot-p.mov],["Velo",p.pot-p.velo]]; gaps.sort((a,b)=>b[1]-a[1]); tp[p.id]={focus:gaps[0][0],intens:"æ¨™æº–"}; } State.trainingPlans[tid]=tp; }
// ====== Traits & Special Effects ======
const TRAIT_RULES = [
  {id:'power_hitter',   name:getSpecialById('power_hitter')?.name || 'ãƒ‘ãƒ¯ãƒ¼ãƒ’ãƒƒã‚¿ãƒ¼', cond:(p)=>p.pwr>=85},
  {id:'plate_discipline', name:getSpecialById('plate_discipline')?.name || 'é¸çƒçœ¼ã€‡', cond:(p)=>p.con>=75 && p.disc>=75},
  {id:'speedster',       name:getSpecialById('speedster')?.name || 'å¿«è¶³', cond:(p)=>p.spd>=85},
  {id:'precision_pitcher', name:getSpecialById('precision_pitcher')?.name || 'ç²¾å¯†æ©Ÿæ¢°', cond:(p)=>p.ctrl>=84},
  {id:'power_pitcher',   name:getSpecialById('power_pitcher')?.name || 'å‰›è…•', cond:(p)=>p.velo>=90},
  {id:'iron_arm',        name:getSpecialById('iron_arm')?.name || 'é‰„è…•', cond:(p)=>p.stam>=88},
  {id:'lefty_killer',    name:getSpecialById('lefty_killer')?.name || 'å¯¾å·¦æŠ•æ‰‹â—‹', cond:(p)=>['R','å³','S','ä¸¡'].includes(p.hand||'') && p.con>=78 && p.pwr>=75},
  // New unlockables by thresholds
  {id:'slugger_elite',   name:getSpecialById('slugger_elite')?.name || 'é•·è·é›¢ç ²', cond:(p)=>p.pwr>=90},
  {id:'contact_master',  name:getSpecialById('contact_master')?.name || 'å·§æ‰“è·äºº', cond:(p)=>p.con>=85 && p.disc>=78},
  {id:'defense_specialist', name:getSpecialById('defense_specialist')?.name || 'å®ˆå‚™è·äºº', cond:(p)=>p.fld!==undefined && p.fld>=88},
  {id:'strikeout_machine', name:getSpecialById('strikeout_machine')?.name || 'å¥ªä¸‰æŒ¯ãƒžã‚·ãƒ³', cond:(p)=>p.velo!==undefined && p.velo>=88 && p.mov>=84},
  {id:'pitch_to_contact', name:getSpecialById('pitch_to_contact')?.name || 'æ‰“ãŸã›ã¦å–ã‚‹', cond:(p)=>p.ctrl!==undefined && p.ctrl>=86 && p.mov>=82},
  {id:'clutch_hitter',   name:getSpecialById('clutch_hitter')?.name || 'ã‚¯ãƒ©ãƒƒãƒãƒ’ãƒƒã‚¿ãƒ¼', cond:(p)=>p.con!==undefined && p.pwr!==undefined && p.con>=80 && p.pwr>=80},
  {id:'elite_closer',    name:getSpecialById('elite_closer')?.name || 'ã‚¯ãƒ­ãƒ¼ã‚¶ãƒ¼â—Ž', cond:(p)=>p.role==='RP' && p.ctrl>=82 && p.mov>=82},
  {id:'iron_man',        name:getSpecialById('iron_man')?.name || 'é‰„äºº', cond:(p)=> (p.stam||p.spd||0) >= 90}
];

const SPECIAL_TRAIT_POOL_BAT = ['captain','mood_maker','clutch_hitter','defense_specialist','slugger_elite','contact_master','lefty_killer','iron_man'];
const SPECIAL_TRAIT_POOL_PIT = ['captain','mood_maker','elite_closer','strikeout_machine','pitch_to_contact','iron_man'];

function hasTrait(player, identifier){
  return playerHasSpecial(player, identifier);
}

function initializePlayerSpecials(){
  const shouldAssign = !State.specialsInit;
  const rng = shouldAssign ? mulberry32((State.seed||2025)+5555) : null;
  for(const tid of Object.keys(State.rosters||{})){
    const R = State.rosters[tid];
    if(!R) continue;
    for(const batter of (R.bats||[])){
      if(!batter) continue;
      const traits = normalizePlayerSpecials(batter);
      if(shouldAssign && rng()<0.10){
        const t = SPECIAL_TRAIT_POOL_BAT[Math.floor(rng()*SPECIAL_TRAIT_POOL_BAT.length)];
        if(t && !traits.includes(t)) traits.push(t);
      }
    }
    for(const pitcher of (R.pits||[])){
      if(!pitcher) continue;
      const traits = normalizePlayerSpecials(pitcher);
      if(shouldAssign && rng()<0.10){
        const t = SPECIAL_TRAIT_POOL_PIT[Math.floor(rng()*SPECIAL_TRAIT_POOL_PIT.length)];
        if(t && !traits.includes(t)) traits.push(t);
      }
    }
  }
  if(shouldAssign) State.specialsInit=true;
}

function computeTeamMods(tid){
  const R=State.rosters[tid]; const ichi=new Set(State.squads[tid]?.ichi||[]);
  const bats=R.bats.filter(batter=>ichi.has(batter.id)).slice().sort((a,b)=> battingScore(b,"R") - battingScore(a,"R")).slice(0,9);
  const sp5=R.pits.filter(p=>p.role==="SP" && ichi.has(p.id)).slice().sort((a,b)=>(b.stam*.2+b.velo*.4+b.mov*.3+b.ctrl*.1)-(a.stam*.2+a.velo*.4+a.mov*.3+a.ctrl*.1)).slice(0,5);
  const rp5=R.pits.filter(p=>p.role!=="SP" && ichi.has(p.id)).slice().sort((a,b)=>(b.velo*.45+b.mov*.35+b.ctrl*.2)-(a.velo*.45+a.mov*.35+a.ctrl*.2)).slice(0,5);
  const mods={onb:0,pow:0,def:0,sp:0,rp:0,extraAtk:0,extraDef:0,teamTrain:0,hotDelta:0,slumpDelta:0,fatigueTeam:1.0,moraleAura:0};
  collectPlayerEffects(bats, 'teamMods:lineup', mods);
  collectPlayerEffects(sp5, 'teamMods:rotation', mods);
  collectPlayerEffects(rp5, 'teamMods:bullpen', mods);

  const closer = R.pits.find(p => ichi.has(p.id) && p.sub_role === 'ã‚¯ãƒ­ãƒ¼ã‚¶ãƒ¼');
  if (closer) {
      mods.extraDef = (mods.extraDef || 0) + 0.04;
  }
  const setup_men = R.pits.filter(p => ichi.has(p.id) && p.sub_role === 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ‘ãƒ¼');
  if (setup_men.length > 0) {
      mods.rp = (mods.rp || 0) + setup_men.length * 1.5; 
  }

  return mods;
}

function recomputeTeamModsAll(){ State.teamMods={}; for(const t of State.teams){ State.teamMods[t.team_id]=computeTeamMods(t.team_id); } }
function appearanceBoost(pid){ const pts=(State.weekXP[pid]||0); return 1+Math.min(.2, pts*.01); }
const WEEK_XP_LOG_WINDOW = 12;
function ensureWeekXPLog(){
  if(!State.weekXPLog) State.weekXPLog={};
}
function addWeekXP(pid, amount){
  if(!amount) return;
  State.weekXP[pid]=(State.weekXP[pid]||0)+amount;
  ensureWeekXPLog();
  const arr=State.weekXPLog[pid]||(State.weekXPLog[pid]=[]);
  arr.push({day:State.curr_day||0,xp:amount});
  if(arr.length>WEEK_XP_LOG_WINDOW) arr.splice(0, arr.length-WEEK_XP_LOG_WINDOW);
}
function getWeekXPSeries(pid){
  return (State.weekXPLog?.[pid]||[]).map(entry=>entry.xp);
}
function trainingSupportMultiplier(player, focus, tid, support){
  const adjustments = support || getTeamSupportAdjustments(tid);
  const staff = adjustments.staff || {};
  const facilities = adjustments.facilities || {};
  const isPitch = player.velo !== undefined;
  let multiplier = (staff.growth?.global ?? 1) * (facilities.growth?.global ?? 1);

  if (!isPitch) {
    multiplier *= staff.growth?.hitting ?? 1;
    if (["Con", "Disc", "Fld"].includes(focus)) {
      multiplier *= facilities.growth?.battingPrecision ?? 1;
    }
    if (["Pwr"].includes(focus)) {
      multiplier *= facilities.growth?.battingPower ?? 1;
    }
    if (["Spd"].includes(focus)) {
      multiplier *= facilities.growth?.speed ?? 1;
    }
    if (["Stam"].includes(focus)) {
      multiplier *= facilities.growth?.stamina ?? 1;
    }
  } else {
    multiplier *= staff.growth?.pitching ?? 1;
    if (["Ctrl", "Mov"].includes(focus)) {
      multiplier *= facilities.growth?.pitchingCommand ?? 1;
    }
    if (["Velo"].includes(focus)) {
      multiplier *= facilities.growth?.pitchingPower ?? 1;
    }
    if (["Stam"].includes(focus)) {
      multiplier *= facilities.growth?.stamina ?? 1;
    }
  }

  return multiplier;
}
function moraleFatigueMult(player){ const morale=player.morale??60, fatigue=player.fatigue??20; const moraleF=1+(morale-50)/250; const fatigueF=1-(fatigue)/200; const hot=(player.status?.hot||0)>0?1.15:1.0; const slump=(player.status?.slump||0)>0?0.8:1.0; return clamp(moraleF*fatigueF*hot*slump,0.5,1.4); }
function weeklyRecovery(player, tid, intens, support){
  const adjustments = support || getTeamSupportAdjustments(tid);
  const staff = adjustments.staff || {};
  const facilities = adjustments.facilities || {};
  const baseRec = (intens==="è»½"?12:(intens==="æ¨™æº–"?8:4));
  const recoveryMult = (staff.recovery?.mult ?? 1) * (facilities.recovery?.mult ?? 1);
  const recoveryFlat = (staff.recovery?.flat ?? 0) + (facilities.recovery?.flat ?? 0);
  const injuryDurationMult = Math.max(0.3, (staff.injuryDuration ?? 1) * (facilities.injuryDuration ?? 1));
  let totalRecovery = Math.max(0, baseRec * recoveryMult + recoveryFlat);
  if (player?.injury) {
    const injuryPenalty = clamp(0.6 / injuryDurationMult, 0.35, 1.05);
    totalRecovery *= injuryPenalty;
  }
  player.fatigue = clamp((player.fatigue||0) - totalRecovery, 0, 100);
}
function dangerCheck(player, plan){ // risk of slump when overworked
  if(player.fatigue>85 && plan.intens==="å¼·"){ if(Math.random()<0.15){ player.status.slump=Math.max(player.status.slump||0,2); return "ãƒ•ã‚©ãƒ¼ãƒ å´©ã‚Œ(2é€±)"; } }
  return null;
}
function rollHotStreak(player){ if(player.morale>85 && Math.random()<0.08){ player.status.hot=Math.max(player.status.hot||0,2); return "é–‹çœ¼(2é€±)"; } return null; }

function applyTrainingWeekToPlayer(player, plan, tid, support){
  const isPitch=(player.velo!==undefined); const focus=plan.focus; const intens=INTENS[plan.intens||"æ¨™æº–"]||1.0;
  const supportAdjustments = support || getTeamSupportAdjustments(tid);
  const staffAdjust = supportAdjustments.staff || {};
  const facilityAdjust = supportAdjustments.facilities || {};

  if (player.injury) {
    weeklyRecovery(player, tid, 'è»½', supportAdjustments);
    return [`ãƒªãƒãƒ“ãƒªä¸­ (${player.injury.type})`];
  }

  const ov=isPitch?(player.velo*.4+player.mov*.4+player.ctrl*.2):(player.con*.5+player.disc*.2+player.pwr*.3);
  const baseGrowth=Math.max(0,(player.pot||60)-ov)/100; // 0..~0.4
  let mult = ageCurve(player.age||25) * intens * appearanceBoost(player.id) * trainingSupportMultiplier(player, focus, tid, supportAdjustments) * moraleFatigueMult(player) * (1 + ((State.teamMods?.[tid]?.teamTrain)||0));
  mult = clamp(mult, 0.35, 1.8);
  // Crit / Weak outcomes influenced by morale & fatigue
  const morale=player.morale||60, fatigue=player.fatigue||20; const critP=clamp(0.05 + (morale-50)/300 - (fatigue-30)/400, 0.02, 0.25); const weakP=clamp(0.08 + (fatigue-40)/300, 0.05, 0.35);
  const r=Math.random(); if(r<critP) mult*=1.5; else if(r>1-weakP) mult*=0.75;
  const noise=(Math.random()*0.4+0.8);
  const delta=baseGrowth*mult*noise; // 0..something
  let gains=[];
  function inc(key, amt){ const before=player[key]; player[key]=clamp(Math.round(before+amt),30,99); if(player[key]!==before) gains.push(`${key[0].toUpperCase()}${key.slice(1)}+${player[key]-before}`); }
  if(!isPitch){ if(focus==="Con") inc("con", +2.2*delta); if(focus==="Disc") inc("disc", +1.7*delta); if(focus==="Pwr") inc("pwr", +2.3*delta); if(focus==="Spd") inc("spd", +1.6*delta); if(focus==="Fld") inc("fld", +1.8*delta); }
  else{ if(focus==="Velo") inc("velo", +2.0*delta); if(focus==="Ctrl") inc("ctrl", +2.0*delta); if(focus==="Mov") inc("mov", +2.0*delta); if(focus==="Stam") inc("stam", +1.6*delta); }
  // Small chance to raise potential when doing well
  if(delta>0.4 && player.pot<99 && Math.random()<0.10){ player.pot=clamp(player.pot+1,30,99); gains.push("ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«+1"); }
  // Traits
  const playerTraits = normalizePlayerSpecials(player);
  const intensityKey = plan.intens || 'æ¨™æº–';
  const baseTraitChance = intensityKey === 'å¼·' ? 0.22 : (intensityKey === 'è»½' ? 0.12 : 0.16);
  const performanceFactor = clamp(delta, 0, 1.2);
  const baseChance = clamp(baseTraitChance * (1 + performanceFactor * 0.6), 0.02, 0.85);
  const traitMultiplier = (staffAdjust.specialAwaken ?? 1) * (facilityAdjust.specialAwaken ?? 1);
  for(const tr of TRAIT_RULES){
    if(!playerTraits.includes(tr.id) && tr.cond(player)){
      const ruleBase = tr.chance != null ? tr.chance : baseChance;
      const awakenChance = clamp(ruleBase * traitMultiplier, 0, 0.95);
      if(Math.random() < awakenChance){
        playerTraits.push(tr.id);
        const special = getSpecialById(tr.id);
        const traitName = special?.name || tr.name || tr.id;
        gains.push(`ç‰¹èƒ½:${traitName}`);
        logHighlight('award', `ã€è¦šé†’ã€‘${player.name}ãŒç‰¹èƒ½ã€Ž${traitName}ã€ã‚’ç¿’å¾—ã—ã¾ã—ãŸï¼`);
      }
    }
  }

  // Morale & status updates
  if(gains.length>0) player.morale=clamp((player.morale||60)+3,0,100); else player.morale=clamp((player.morale||60)-1,0,100);
  const slump=dangerCheck(player, plan); const hot=rollHotStreak(player); if(slump) gains.push(slump); if(hot) gains.push(hot);
  weeklyRecovery(player, tid, plan.intens, supportAdjustments);
  return gains;
}
function tickStatuses(player){ if(player.status){ if(player.status.hot>0) player.status.hot--; if(player.status.slump>0) player.status.slump--; } }

function applyTrainingWeek(tid,weeks=1,label="é€±æ¬¡è‚²æˆ"){
  ensureSquads(); ensureTrainingDefaults(tid); ensureTeamMeta(); const team=State.teams.find(t=>t.team_id===tid); const logs=[];
  const maxHistory = 10;
  for(let w=0; w<weeks; w++){
    const tmods = (State.teamMods?.[tid]) || {};
    if(tmods.moraleAura){ [...State.rosters[tid].bats, ...State.rosters[tid].pits].forEach(p=>{ p.morale = clamp((p.morale||60) + tmods.moraleAura, 0, 100); }); }

    const supportAdjustments = getTeamSupportAdjustments(tid);

    const weekLabel = weeks > 1 ? `${label} ${w+1}é€±ç›®` : label;
    const niList = Array.isArray(State.squads?.[tid]?.ni) ? State.squads[tid].ni.slice() : [];
    niList.forEach(pid=>{ addWeekXP(pid, 12); const P=findPlayerById(tid,pid); if(P) P.morale=clamp((P.morale||60)-1,0,100); });
    
    // Apply training and update history in one loop
    [...State.rosters[tid].bats, ...State.rosters[tid].pits].forEach(player => {
        const gains = applyTrainingWeekToPlayer(player, State.trainingPlans[tid][player.id], tid, supportAdjustments);
        player.recentGains = gains.filter(g => !g.includes('ãƒªãƒãƒ“ãƒªä¸­'));
        if (gains.length && !gains[0].includes('ãƒªãƒãƒ“ãƒªä¸­')) {
            logs.push(`[${team.team}] ${player.name}: ${gains.join(', ')}`);
        }
        tickStatuses(player);

        // Update history
        player.history.overall.push(getOverall(player));
        player.history.fatigue.push(player.fatigue);
        player.history.morale.push(player.morale);
        if (player.history.overall.length > maxHistory) player.history.overall.shift();
        if (player.history.fatigue.length > maxHistory) player.history.fatigue.shift();
        if (player.history.morale.length > maxHistory) player.history.morale.shift();
    });

    const recoveryMult = (supportAdjustments.staff.recovery?.mult ?? 1) * (supportAdjustments.facilities.recovery?.mult ?? 1);
    const recoveryFlat = (supportAdjustments.staff.recovery?.flat ?? 0) + (supportAdjustments.facilities.recovery?.flat ?? 0);
    const traitRate = (supportAdjustments.staff.specialAwaken ?? 1) * (supportAdjustments.facilities.specialAwaken ?? 1);
    const farmOutcome = applyFarmEffects(State, {
        teamId: tid,
        days: 7,
        label: weekLabel,
        traitRules: TRAIT_RULES,
        modifiers: {
            recoveryMult,
            recoveryFlat,
            traitUnlockRate: traitRate
        }
    });
    farmOutcome.players.forEach(result => {
        const player = findPlayerById(tid, result.playerId);
        if (!player) return;

        if (!player.history) player.history = { overall: [getOverall(player)], fatigue: [player.fatigue||20], morale: [player.morale||60], farmReveal: [Math.round(result.revealAfter)] };
        if (!Array.isArray(player.history.farmReveal)) player.history.farmReveal = [];
        player.history.farmReveal.push(Math.round(result.revealAfter));
        if (player.history.farmReveal.length > maxHistory) player.history.farmReveal.shift();

        const entry = {
            day: State.curr_day ?? 0,
            label: weekLabel,
            revealGain: result.revealGain,
            revealAfter: result.revealAfter,
            fatigueRecovered: result.fatigueRecovered,
            traitUnlocks: result.traitUnlocks.slice(),
            milestones: result.milestones.slice(),
            summary: result.messages.slice(),
        };
        const farmLog = player.farmLog || (player.farmLog = []);
        farmLog.push(entry);
        if (farmLog.length > 8) farmLog.splice(0, farmLog.length - 8);
        player.farmLast = entry;
        player.farmReveal = result.revealAfter;

        const updates = [];
        if (result.revealGain > 0) updates.push(`æ½œåœ¨+${result.revealGain}% (ç´¯è¨ˆ${result.revealAfter}%)`);
        if (result.fatigueRecovered > 0) updates.push(`ç–²åŠ´-${result.fatigueRecovered}`);
        result.milestones.forEach(mark => {
            updates.push(`ç¯€ç›®${mark}%`);
            if (mark === 100) {
                logHighlight('sparkle', `ã€é–‹ç¤ºå®Œäº†ã€‘${player.name}ã®æ½œåœ¨ãŒå…¨ã¦è¦‹ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸï¼`, { tid });
            }
        });
        const playerTraits = normalizePlayerSpecials(player);
        result.traitUnlocks.forEach(trait => {
            const traitId = findSpecialId(trait) || trait;
            if (!playerTraits.includes(traitId)) {
                playerTraits.push(traitId);
                const special = getSpecialById(traitId);
                const traitName = special?.name || trait;
                updates.push(`è¦šé†’:${traitName}`);
                logHighlight('award', `ã€è¦šé†’ã€‘${player.name}ãŒç‰¹èƒ½ã€Ž${traitName}ã€ã‚’äºŒè»ç·´ç¿’ã§ç¿’å¾—ã—ã¾ã—ãŸï¼`, { tid });
            }
        });
        if (updates.length) {
            logs.push(`[${team.team}] ${player.name}: äºŒè» ${updates.join(', ')}`);
        }
    });

    State.weekXP={};
  }
  recomputeTeamRatings(team, State.rosters[tid], new Set(State.squads[tid].ichi));
  State.devLogs.push(`${label}ï¼ˆ${team.team}ï¼‰ï¼š${weeks}é€± / æ›´æ–°:${logs.length}ä»¶`); State.devLogs.push(...logs.slice(-100));
}

// ====== Special Training (Manual) ======
function findPlayerById(tid,pid){ const R=State.rosters[tid]; return R.bats.find(b=>b.id===pid) || R.pits.find(p=>p.id===pid); }
function doSpecialTraining(tid,pid){ ensureTeamMeta(); const cost=5; 
  const P=findPlayerById(tid,pid); if(!P) return; 
  if (P.injury) { console.error('æ€ªæˆ‘ä¸­ã®é¸æ‰‹ã¯ç‰¹è¨“ã§ãã¾ã›ã‚“'); return; }
  if(!dpSpend(tid,cost)){ console.error(`Devãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦:${cost}ï¼‰`); return; }
  
  const isPitch=(P.velo!==undefined); const plan=State.trainingPlans[tid][pid]||{focus:isPitch?"Velo":"Con",intens:"æ¨™æº–"}; const focus=plan.focus;
  const morale=P.morale||60, fatigue=P.fatigue||20; const base=1 + (morale-50)/80 - (fatigue)/120; const r=Math.random(); let result,amt;
  if(r<0.20+Math.max(0,(morale-60))/200){ result="å¤§æˆåŠŸ"; amt= (isPitch?3.5:3.5) * base; }
  else if(r<0.75){ result="æˆåŠŸ"; amt=(isPitch?2.2:2.2)*base; }
  else if(r<0.95){ result="å¾®å¢—"; amt=(isPitch?1.2:1.2)*base; }
  else { result="ä¸èª¿ï¼ˆã‚¹ãƒ©ãƒ³ãƒ—1é€±ï¼‰"; amt=0; P.status= P.status||{}; P.status.slump=Math.max(P.status.slump||0,1); }
  function inc(key,a){ const before=P[key]; P[key]=clamp(Math.round(before+a),30,99); return P[key]-before; }
  let changed=0; if(!isPitch){ if(focus==="Con") changed=inc("con",amt); if(focus==="Disc") changed=inc("disc",amt*0.8); if(focus==="Pwr") changed=inc("pwr",amt*1.1); if(focus==="Spd") changed=inc("spd",amt*0.7); if(focus==="Fld") changed=inc("fld",amt*0.9); }
  else{ if(focus==="Velo") changed=inc("velo",amt); if(focus==="Ctrl") changed=inc("ctrl",amt); if(focus==="Mov") changed=inc("mov",amt); if(focus==="Stam") changed=inc("stam",amt*0.8); }
  P.morale=clamp((P.morale||60)+(result==="ä¸èª¿ï¼ˆã‚¹ãƒ©ãƒ³ãƒ—1é€±ï¼‰"?-4:3),0,100); P.fatigue=clamp((P.fatigue||20)+6,0,100);
  State.devLogs.push(`ç‰¹è¨“ ${result}ï¼š${State.teams.find(t=>t.team_id===tid).team} ${P.name} â†’ ${focus}${changed>=0?`+${changed}`:changed}`);
  saveAndRerender();
}

// ====== State ======
const State=(function(){ const saved=localStorage.getItem(SAVE_KEY); if(saved){ try{ const obj=JSON.parse(saved); obj.version=15; obj.ruleId = obj.ruleId || 'npb-2025'; obj.highlights = obj.highlights || []; obj.playoffs = normalizePlayoffState(obj.playoffs); obj.schedule = obj.schedule||[]; obj.gameRecaps = obj.gameRecaps || {}; obj.ui = obj.ui || {}; obj.ui.dashboardTab = obj.ui.dashboardTab || 'season'; obj.cachedMetrics = obj.cachedMetrics || {}; obj.historicalStats = obj.historicalStats || {}; obj.rosterCompliance = obj.rosterCompliance || {}; obj.squadMoveLog = (obj.squadMoveLog && typeof obj.squadMoveLog === 'object') ? obj.squadMoveLog : {}; obj.userTeamId = Number.isFinite(obj.userTeamId) ? obj.userTeamId : parseInt(obj.userTeamId, 10) || 0; normalizeTeamFinances(obj); normalizeRosterPlayers(obj); normalizeSquadAssignments(obj); normalizeNarrativeState(obj); normalizeLeagueState(obj); normalizeSeasonInfo(obj); if(Array.isArray(obj.teams)){ obj.teams.forEach(team=>{ calculateDraftTeamNeeds(obj, team.team_id); }); } return obj; }catch(e){} }
  const teams=baseTeams.map(t=>({...t})); const rosters={}; teams.forEach(t=>{ rosters[t.team_id]=mkInitialRoster(t.team_id); });
  const baseState = { version:15, ruleId: 'npb-2025', teams, rosters, schedule:[], results:[], curr_day:1, seed:2025, home_adv:0.05, trainingPlans:{}, devLogs:[], weekXP:{}, weekXPLog:{}, squads:{}, squadsInit:false, rotation:{}, teamMeta:{}, teamStrategy:{}, userTeamId:0, commissioner:false, playerStats:{}, playerGameLogs:{}, historicalStats:{}, season:1, highlights: [], playoffs: defaultPlayoffState(), gameRecaps:{}, teamFinances:{}, freeAgents:[], narrativeSettings:{ frequency:'standard', theme:'balanced' }, teamNarratives:{}, narrativeLog:[], ui:{ dashboardTab:'season' }, cachedMetrics:{}, league: defaultLeagueState(), seasonInfo: defaultSeasonInfo(), rosterCompliance:{}, squadMoveLog:{} };
  normalizeTeamFinances(baseState);
  normalizeRosterPlayers(baseState);
  normalizeSquadAssignments(baseState);
  normalizeNarrativeState(baseState);
  normalizeLeagueState(baseState);
  normalizeSeasonInfo(baseState);
  if(Array.isArray(baseState.teams)){ baseState.teams.forEach(team=>{ calculateDraftTeamNeeds(baseState, team.team_id); }); }
  return baseState;
})();

window.State = State;
window.normalizeLeagueState = normalizeLeagueState;

ensureTeamNeedsAll();

// ====== Narrative Events ======
const RIVALRY_MAP=new Map([
  [0,new Set([1,5])],
  [1,new Set([0])],
  [2,new Set([4])],
  [3,new Set([5])],
  [4,new Set([2])],
  [5,new Set([0,3])],
  [6,new Set([7])],
  [7,new Set([6])],
  [8,new Set([11])],
  [9,new Set([10])],
  [10,new Set([9])],
  [11,new Set([8])]
]);
const NARRATIVE_FREQ_MULTIPLIER={ low:0.6, standard:1, high:1.4 };

function ensureNarrativeState(){
  normalizeNarrativeState(State);
  const day=State.curr_day||1;
  (State.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const avg=Math.round(computeTeamAverageMorale(tid));
    recordTeamMoralePoint(tid, day, avg);
  });
}

function computeTeamAverageMorale(tid){
  const roster=State.rosters?.[tid];
  if(!roster) return 60;
  const players=[...(roster.bats||[]), ...(roster.pits||[])];
  if(players.length===0) return 60;
  const total=players.reduce((sum,p)=>sum+(p?.morale??60),0);
  return total/players.length;
}

function computeTeamAverageFatigue(tid){
  const roster=State.rosters?.[tid];
  if(!roster) return 20;
  const players=[...(roster.bats||[]), ...(roster.pits||[])];
  if(players.length===0) return 20;
  const total=players.reduce((sum,p)=>sum+(p?.fatigue??20),0);
  return total/players.length;
}

function recordTeamMoralePoint(tid, day, value){
  const narrative=State.teamNarratives?.[tid];
  if(!narrative) return;
  if(!Array.isArray(narrative.morale)) narrative.morale=[];
  const last=narrative.morale[narrative.morale.length-1];
  if(last && last.season===State.season && last.day===day){
    last.value=value;
  } else {
    narrative.morale.push({ season:State.season, day, value });
    if(narrative.morale.length>200) narrative.morale.splice(0, narrative.morale.length-200);
  }
}

function captureDailyMoraleSnapshot(day){
  ensureNarrativeState();
  (State.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const avg=Math.round(computeTeamAverageMorale(tid));
    recordTeamMoralePoint(tid, day, avg);
  });
}

function pushRecentGain(player, gain){
  if(!player) return;
  if(!Array.isArray(player.recentGains)) player.recentGains=[];
  player.recentGains.push(gain);
  if(player.recentGains.length>8) player.recentGains.splice(0, player.recentGains.length-8);
}

function determineAbilityAttrFromPlayer(player){
  if(!player) return null;
  if(player.velo!=null) return 'velo';
  return 'con';
}

function getTopPlayersByOverall(tid, limit=5){
  const roster=State.rosters?.[tid];
  if(!roster) return [];
  return [...(roster.bats||[]), ...(roster.pits||[])]
    .filter(p=>p && !p.injury)
    .sort((a,b)=>getOverall(b)-getOverall(a))
    .slice(0, limit);
}

function getLowestMoralePlayers(tid, limit=4){
  const roster=State.rosters?.[tid];
  if(!roster) return [];
  return [...(roster.bats||[]), ...(roster.pits||[])]
    .filter(p=>p)
    .sort((a,b)=>(a.morale??60)-(b.morale??60))
    .slice(0, limit);
}

function isRivalPair(a,b){
  return (RIVALRY_MAP.get(a)?.has(b)) || (RIVALRY_MAP.get(b)?.has(a)) || false;
}

function getTeamStreakCached(tid, cache){
  if(cache.has(tid)) return cache.get(tid);
  const results=State.results||[];
  let wins=0, losses=0;
  for(let i=results.length-1;i>=0;i--){
    const game=results[i];
    if(game.home_id!==tid && game.away_id!==tid) continue;
    const won=game.winner_id===tid;
    if(wins===0 && losses===0){
      if(won) wins=1; else losses=1;
    } else if(wins>0){
      if(won) wins++; else break;
    } else if(losses>0){
      if(!won) losses++; else break;
    }
  }
  const data={ wins, losses };
  cache.set(tid,data);
  return data;
}

const narrativeEventTemplates=[
  {
    id:'momentumSurge',
    category:'team',
    mood:'positive',
    baseChance:0.95,
    tag:'å£«æ°—ä¸Šæ˜‡',
    icon:'party-popper',
    priority:3,
    generate({ resultsToday, streakCache }){
      const events=[];
      const winners=new Set((resultsToday||[]).map(r=>r.winner_id).filter(v=>v!=null));
      winners.forEach(tid=>{
        const streak=getTeamStreakCached(tid, streakCache).wins;
        if(streak>=3){
          const teamName=id2name(tid);
          const core=getTopPlayersByOverall(tid,6);
          const playerIds=core.map(p=>p.id);
          events.push({
            teamId:tid,
            title:'é€£å‹ãƒ–ãƒ¼ã‚¹ãƒˆ',
            summary:`${teamName}ãŒ${streak}é€£å‹ã§å£«æ°—ãŒæœ€é«˜æ½®ã«ã€‚`,
            detail:'é€£å‹ãƒ ãƒ¼ãƒ‰ã§ã‚¯ãƒ©ãƒ–ãƒã‚¦ã‚¹ãŒä¸€ä½“æ„Ÿã«åŒ…ã¾ã‚Œã€ä¸»åŠ›ãŒè‡ªä¸»çš„ã«ãƒªã‚«ãƒãƒªãƒ¼ãƒ¯ãƒ¼ã‚¯ã‚’è¡Œã£ãŸã€‚',
            playerIds,
            effects:{ morale:4, fatigue:-3 },
            highlightText:`${teamName}ãŒ${streak}é€£å‹ã§ãƒãƒ¼ãƒ ã®å£«æ°—ãŒè·³ã­ä¸ŠãŒã‚‹ï¼`
          });
        }
      });
      return events;
    }
  },
  {
    id:'slumpMeeting',
    category:'team',
    mood:'positive',
    baseChance:0.7,
    tag:'å£«æ°—ä¼šè­°',
    icon:'users',
    priority:1,
    generate({ streakCache }){
      const events=[];
      (State.teams||[]).forEach(team=>{
        const tid=team.team_id;
        const streak=getTeamStreakCached(tid, streakCache);
        const morale=computeTeamAverageMorale(tid);
        if(streak.losses>=3 || morale<48){
          const lowPlayers=getLowestMoralePlayers(tid,4);
          const playerIds=lowPlayers.map(p=>p.id);
          events.push({
            teamId:tid,
            title:'ç·Šæ€¥ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°',
            summary:`${team.team}ã¯ã‚­ãƒ£ãƒ—ãƒ†ãƒ³ä¸»å°Žã®ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã§æ°—æŒã¡ã‚’ç«‹ã¦ç›´ã—ãŸã€‚`,
            detail:'å¤œé…ãã¾ã§èª²é¡Œã‚’å…±æœ‰ã—ã€å£«æ°—ã¯ä¸ŠãŒã£ãŸãŒã‚„ã‚„ç–²åŠ´ã‚‚è“„ç©ã€‚',
            playerIds,
            effects:{ morale:3, fatigue:2 },
            highlightText:`${team.team}ãŒãƒãƒ¼ãƒ ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã§ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç‚¹ç«ã€‚`
          });
        }
      });
      return events;
    }
  },
  {
    id:'rivalryClash',
    category:'rivalry',
    mood:'positive',
    baseChance:1,
    tag:'ãƒ©ã‚¤ãƒãƒ«æˆ¦',
    icon:'swords',
    priority:4,
    generate({ resultsToday }){
      const events=[];
      (resultsToday||[]).forEach(res=>{
        if(!isRivalPair(res.home_id, res.away_id)) return;
        const diff=Math.abs((res.home_runs??0)-(res.away_runs??0));
        if(diff>2) return;
        const key=gameRecapKey(res.day, res.home_id, res.away_id);
        const recap=State.gameRecaps?.[key];
        const winner=res.winner_id;
        const loser=winner===res.home_id?res.away_id:res.home_id;
        if(winner!=null){
          const playerId=recap?.decidingPlayerId||null;
          const player=playerId!=null?findPlayerById(winner, playerId):null;
          const abilityAttr=player?determineAbilityAttrFromPlayer(player):null;
          const abilityEffects=abilityAttr?[{ attr:abilityAttr, delta:1 }]:[];
          events.push({
            teamId:winner,
            title:'å®¿æ•µæ’ƒç ´',
            summary:`${id2name(winner)}ãŒãƒ©ã‚¤ãƒãƒ«${id2name(loser)}ã¨ã®æŽ¥æˆ¦ã‚’åˆ¶ã—ãŸã€‚`,
            detail:'ãƒ™ãƒ³ãƒã¯å¤§æ­“å£°ã€‚å‹è² æ‰€ã§é›†ä¸­åŠ›ãŒé«˜ã¾ã‚Šã€ä¸»åŠ›ã«ãƒªãƒ©ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ãŒä¸Žãˆã‚‰ã‚ŒãŸã€‚',
            playerIds:playerId?[playerId]:[],
            effects:{ morale:3, fatigue:-2, ability:abilityEffects },
            highlightText:`${id2name(winner)}ãŒãƒ©ã‚¤ãƒãƒ«${id2name(loser)}ã‚’æ’ƒç ´ï¼`,
            metadata:{ opponentId:loser, rivalry:true }
          });
        }
        if(loser!=null){
          events.push({
            teamId:loser,
            title:'æƒœæ•—ã®æ‚”ã—ã•',
            summary:`${id2name(loser)}ã¯ãƒ©ã‚¤ãƒãƒ«æˆ¦ã®æƒœæ•—ã§å£«æ°—ãŒæ²ˆã‚“ã ã€‚`,
            detail:'è©¦åˆå¾Œã®åçœä¼šã§èª²é¡Œã‚’å…±æœ‰ã—ãŸãŒã€æ°—ç–²ã‚ŒãŒæ®‹ã£ã¦ã„ã‚‹ã€‚',
            effects:{ morale:-2, fatigue:2 },
            icon:'skull',
            mood:'negative',
            highlightText:`${id2name(loser)}ã¯ãƒ©ã‚¤ãƒãƒ«ã«æƒœæ•—ã—æ‚”ã—ã•ã‚’å‹Ÿã‚‰ã›ã¦ã„ã‚‹ã€‚`,
            metadata:{ opponentId:winner, rivalry:true }
          });
        }
      });
      return events;
    }
  },
  {
    id:'heroSpotlight',
    category:'player',
    mood:'positive',
    baseChance:0.75,
    tag:'ãƒ¢ãƒãƒ™å‘ä¸Š',
    icon:'megaphone',
    priority:2,
    generate({ resultsToday }){
      const events=[];
      (resultsToday||[]).forEach(res=>{
        const key=gameRecapKey(res.day, res.home_id, res.away_id);
        const recap=State.gameRecaps?.[key];
        if(!recap?.decidingPlayerId) return;
        const winner=res.winner_id;
        const player=findPlayerById(winner, recap.decidingPlayerId);
        if(!player) return;
        if((player.morale??60) >= 85) return;
        const attr=determineAbilityAttrFromPlayer(player);
        events.push({
          teamId:winner,
          title:'ãƒ’ãƒ¼ãƒ­ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼',
          summary:`${player.name}ã¯ãƒ’ãƒ¼ãƒ­ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã§é—˜å¿—ã‚’ç‡ƒã‚„ã—ãŸã€‚`,
          detail:'ãƒ•ã‚¡ãƒ³ã‹ã‚‰ã®å£°æ´ã«èƒŒä¸­ã‚’æŠ¼ã•ã‚Œã€æŠ€è¡“é¢ã®å¾®èª¿æ•´ã«ã‚‚æ‰‹å¿œãˆã‚’æŽ´ã‚“ã ã€‚',
          playerIds:[player.id],
          effects:{ morale:6, fatigue:1, ability: attr ? [{ attr, delta:1 }] : [] },
          highlightText:`${player.name}ãŒãƒ’ãƒ¼ãƒ­ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ“ãƒ¥ãƒ¼ã§ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³æ€¥ä¸Šæ˜‡ï¼`
        });
      });
      return events;
    }
  },
  {
    id:'restDayReset',
    category:'team',
    mood:'positive',
    baseChance:0.6,
    tag:'èª¿æ•´æ—¥',
    icon:'leaf',
    priority:1,
    generate({ restDay }){
      if(!restDay) return [];
      const events=[];
      (State.teams||[]).forEach(team=>{
        const tid=team.team_id;
        if(computeTeamAverageFatigue(tid)>=45){
          events.push({
            teamId:tid,
            title:'ãƒªã‚«ãƒãƒªãƒ¼èª¿æ•´æ—¥',
            summary:`${team.team}ã¯ä¼‘é¤Šæ—¥ã‚’æ´»ã‹ã—ã¦ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ‹ãƒ³ã‚°ã‚’å®Ÿæ–½ã€‚`,
            detail:'ã‚¹ãƒˆãƒ¬ãƒƒãƒã¨ãƒ¡ãƒ³ã‚¿ãƒ«ã‚±ã‚¢ã§ç–²åŠ´ã‚’æŠœãã€ç©ã‚„ã‹ãªé›°å›²æ°—ãŒæˆ»ã£ãŸã€‚',
            effects:{ morale:2, fatigue:-6 },
            highlightText:`${team.team}ãŒä¼‘é¤Šæ—¥ã§ãƒªã‚«ãƒãƒªãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å®Ÿæ–½ã€‚`
          });
        }
      });
      return events;
    }
  }
];

function themeChanceModifier(template, evt, theme){
  switch(theme){
    case 'heroic':
      return (evt.mood==='negative'?0.25:1.3);
    case 'drama':
      return (evt.mood==='negative'?1.3:0.9);
    case 'rivalry':
      return (evt.metadata?.rivalry || template.category==='rivalry')?1.4:0.6;
    default:
      return 1;
  }
}

function evaluateDailyNarrativeEvents(context){
  ensureNarrativeState();
  const day=context.day||State.curr_day||1;
  const season=State.season||1;
  const freqSetting=State.narrativeSettings?.frequency||'standard';
  const themeSetting=State.narrativeSettings?.theme||'balanced';
  const freqMult=NARRATIVE_FREQ_MULTIPLIER[freqSetting]??1;
  const resultsToday=context.resultsToday || (State.results||[]).filter(r=>r.day===day);
  const streakCache=context.streakCache||new Map();
  const acceptanceRng=mulberry32(((State.seed||2025)+day*197+season*67)>>>0);
  const baseSeed=((State.seed||2025)+day*149+season*31)>>>0;
  const produced=[];
  narrativeEventTemplates.forEach((template, idx)=>{
    const rng=mulberry32((baseSeed + hashString(template.id) + idx*97)>>>0);
    const generated=template.generate({ ...context, day, resultsToday, streakCache, rng });
    if(!Array.isArray(generated)) return;
    generated.forEach(evt=>{
      if(!evt || evt.teamId==null) return;
      evt.day=evt.day??day;
      evt.icon=evt.icon||template.icon;
      evt.tag=evt.tag||template.tag;
      evt.category=evt.category||template.category;
      evt.mood=evt.mood||template.mood||'positive';
      evt.priority=evt.priority??template.priority??1;
      const baseChance=evt.chance??template.baseChance??1;
      const themeWeight=themeChanceModifier(template, evt, themeSetting);
      if(themeWeight<=0) return;
      const adjustedChance=clamp(baseChance * freqMult * themeWeight, 0, 1);
      if(acceptanceRng()<=adjustedChance){
        produced.push(evt);
      }
    });
  });
  const maxEvents=Math.max(1, Math.round((context.restDay?1.2:2)*freqMult));
  if(produced.length>maxEvents){
    produced.sort((a,b)=> (b.priority||0) - (a.priority||0));
    return produced.slice(0, maxEvents);
  }
  return produced;
}

function applyNarrativeEvent(evt){
  ensureNarrativeState();
  const day=evt.day ?? (State.curr_day||1);
  const tid=evt.teamId;
  const roster=State.rosters?.[tid];
  if(!roster) return false;
  const rosterPlayers=[...(roster.bats||[]), ...(roster.pits||[])];
  const explicitPlayers=(Array.isArray(evt.playerIds)?evt.playerIds:[])
    .map(pid=>findPlayerById(tid,pid))
    .filter(Boolean);
  const targetPlayers=explicitPlayers.length?explicitPlayers:rosterPlayers;
  const abilityEffects=Array.isArray(evt.effects?.ability)?evt.effects.ability:[];
  const abilityTargets=abilityEffects.length && explicitPlayers.length?explicitPlayers: abilityEffects.length?targetPlayers:[];
  const moraleDelta=evt.effects?.morale||0;
  const fatigueDelta=evt.effects?.fatigue||0;
  const affectedNames=new Set();
  const abilityChanges=[];
  let abilityChanged=false;

  targetPlayers.forEach(player=>{
    if(!player) return;
    if(moraleDelta){
      player.morale=clamp((player.morale??60)+moraleDelta,0,100);
      affectedNames.add(player.name);
    }
    if(fatigueDelta){
      player.fatigue=clamp((player.fatigue??20)+fatigueDelta,0,100);
      affectedNames.add(player.name);
    }
  });

  abilityTargets.forEach(player=>{
    if(!player) return;
    abilityEffects.forEach(effect=>{
      const attr=effect?.attr;
      const delta=effect?.delta||0;
      if(!attr || typeof player[attr] !== 'number' || delta===0) return;
      const before=player[attr];
      player[attr]=clamp(before+delta,20,99);
      if(player[attr]!==before){
        abilityChanged=true;
        abilityChanges.push({ playerId:player.id, name:player.name, attr, before, after:player[attr] });
        pushRecentGain(player, `${attr.toUpperCase()}${delta>=0?'+':'-'}${Math.abs(delta)}`);
        affectedNames.add(player.name);
      }
    });
  });

  const narrative=State.teamNarratives[tid];
  const listedPlayers = targetPlayers.length>10 && explicitPlayers.length===0 ? ['ãƒãƒ¼ãƒ å…¨ä½“'] : Array.from(affectedNames);
  const logEntry={
    season:State.season,
    day,
    team_id:tid,
    title:evt.title||'ã‚¤ãƒ™ãƒ³ãƒˆ',
    summary:evt.summary||'',
    detail:evt.detail||'',
    icon:evt.icon||'sparkles',
    tag:evt.tag||'NARRATIVE',
    players:listedPlayers,
    metadata:evt.metadata||null,
    effects:{ morale:moraleDelta, fatigue:fatigueDelta, ability:abilityChanges }
  };
  if(narrative){
    if(!Array.isArray(narrative.events)) narrative.events=[];
    narrative.events.push(logEntry);
    if(narrative.events.length>150) narrative.events.splice(0, narrative.events.length-150);
  }
  if(Array.isArray(State.narrativeLog)){
    State.narrativeLog.push({ ...logEntry });
    if(State.narrativeLog.length>400) State.narrativeLog.splice(0, State.narrativeLog.length-400);
  }

  const highlightText=evt.highlightText || `${id2name(tid)}ï¼š${evt.summary || evt.title || 'å£«æ°—ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ'}`;
  logHighlight(evt.icon || 'sparkles', highlightText, { category:'narrative', tag: evt.tag || 'NARRATIVE', day, tid });

  return abilityChanged;
}

// ====== Player Stats Logic (NEW) ======
function weightedRandom(items, weightFn, rng) {
    let totalWeight = items.reduce((sum, item) => sum + weightFn(item), 0);
    if (totalWeight <= 0) return items[Math.floor(rng() * items.length)];
    let random = rng() * totalWeight;
    for (const item of items) {
        const weight = weightFn(item);
        if (random < weight) return item;
        random -= weight;
    }
    return items[items.length - 1];
}

function initializePlayerStats(pid) {
    if (!State.playerStats[pid]) {
        State.playerStats[pid] = {};
    }
    if(!State.playerGameLogs[pid]) State.playerGameLogs[pid] = [];
}

function allocateGameStatsDetailed(res, detail, rng, key, highlightMeta) {
    const recap = {
        gameKey: key,
        season: State.season,
        day: res.day,
        home_id: res.home_id,
        away_id: res.away_id,
        innings: res.innings || 9,
        score: { home: res.home_runs, away: res.away_runs },
        winner_id: res.winner_id,
        highlights: [],
        teams: {}
    };
    recap.scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
    const injuryCandidates = [];
    const margin = Math.abs(res.home_runs - res.away_runs);
    const winnerSide = res.winner_id === res.home_id ? 'home' : 'away';

    const processTeam = (side) => {
        const tid = side === 'home' ? res.home_id : res.away_id;
        const isWinner = res.winner_id === tid;
        const teamRecap = {
            team_id: tid,
            team_name: id2name(tid),
            runs: side === 'home' ? res.home_runs : res.away_runs,
            batting: [],
            pitching: { starter: null, relievers: [] },
            highlights: []
        };
        const lineupInfo = detail.lineups?.[side] || { batting: [], pitchers: [] };
        const battingStats = new Map((detail.stats?.[side]?.batting || []).map(s => [s.id, s]));
        const pitchingStats = new Map((detail.stats?.[side]?.pitching || []).map(s => [s.id, s]));

        lineupInfo.batting.forEach(info => {
            const stat = battingStats.get(info.id) || {};
            const row = {
                order: info.order,
                id: info.id,
                name: info.name,
                pos: info.pos,
                AB: stat.AB || 0,
                H: stat.H || 0,
                HR: stat.HR || 0,
                RBI: stat.RBI || 0,
                BB: stat.BB || 0,
                SO: stat.SO || 0,
                R: stat.R || 0
            };
            teamRecap.batting.push(row);
            const player = findPlayerById(tid, info.id);
            if(player){
                injuryCandidates.push({ player, tid });
                addWeekXP(player.id, 4);
                player.fatigue = clamp((player.fatigue || 0) + 10, 0, 100);
                player.morale = clamp((player.morale || 60) + (isWinner ? 2 : -1), 0, 100);
                initializePlayerStats(player.id);
                const log = { day: res.day, AB: row.AB, H: row.H, HR: row.HR, RBI: row.RBI, BB: row.BB, SO: row.SO, R: row.R };
                State.playerGameLogs[player.id].push(log);
                if(row.H >= 3 && rng() < 0.1) player.status.hot = Math.max(player.status.hot || 0, 2);
                if(row.AB > 3 && row.H === 0 && rng() < 0.08) player.status.slump = Math.max(player.status.slump || 0, 1);
                if(row.HR >= 3){
                    logHighlight('bomb', `ã€å¤§çˆ†ç™ºã€‘${player.name}ãŒ1è©¦åˆ${row.HR}æœ¬å¡æ‰“ï¼`, highlightMeta);
                } else if(row.H >= 4){
                    logHighlight('swords', `ã€çŒ›æ‰“è³žã€‘${player.name}ãŒ4å®‰æ‰“ã®å¤§æš´ã‚Œï¼`, highlightMeta);
                }
            }
        });

        const timeline = detail.pitcherTimeline?.[side] || [];
        timeline.forEach((entry, idx) => {
            const stat = pitchingStats.get(entry.id) || {};
            const outs = stat.outs || 0;
            const ip = outs / 3;
            const ipDisplay = Math.floor(ip) + ((outs % 3) / 10);
            const row = {
                id: entry.id,
                name: entry.name,
                role: entry.role || (idx === 0 ? 'SP' : 'RP'),
                IP: ipDisplay,
                ER: stat.ER || 0,
                SO: stat.SO || 0,
                BB: stat.BB || 0,
                R: stat.R || 0,
                H: stat.H || 0,
                HR: stat.HR || 0,
                W: 0,
                L: 0,
                SV: 0
            };
            if(idx === 0 && isWinner && outs >= 15) row.W = 1;
            if(idx === 0 && !isWinner) row.L = 1;
            if(idx > 0 && isWinner && idx === timeline.length - 1 && margin <= 3) row.SV = 1;
            if(idx === 0) teamRecap.pitching.starter = row; else teamRecap.pitching.relievers.push(row);

            const player = findPlayerById(tid, entry.id);
            if(player){
                injuryCandidates.push({ player, tid });
                initializePlayerStats(player.id);
                const log = { day: res.day, IP: ipDisplay, ER: row.ER, SO: row.SO, BB: row.BB, H: row.H, HR: row.HR };
                if(idx === 0) log.GS = 1;
                if(row.W) log.W = row.W;
                if(row.L) log.L = row.L;
                if(row.SV) log.SV = row.SV;
                State.playerGameLogs[player.id].push(log);
                if(idx === 0){
                    addWeekXP(player.id, 4);
                    player.fatigue = clamp((player.fatigue || 0) + Math.max(8, Math.round((outs / 3) * 12)), 0, 100);
                    player.morale = clamp((player.morale || 60) + (isWinner ? 3 : -2), 0, 100);
                    const totalWins = (State.playerGameLogs[player.id] || []).reduce((sum, lg) => sum + (lg.W || 0), 0);
                    if(row.W === 1 && totalWins === 1 && player.age <= 22){
                        logHighlight('trophy', `ã€åˆå‹åˆ©ðŸŽ‰ã€‘ãƒ«ãƒ¼ã‚­ãƒ¼ã®${player.name}æŠ•æ‰‹ãŒãƒ—ãƒ­åˆå‹åˆ©ï¼`, highlightMeta);
                    }
                    if(ipDisplay >= 9 && row.ER === 0){
                        logHighlight('shield-check', `ã€å¿«æŒ™ã€‘${player.name}ãŒå®Œå°å‹åˆ©ã‚’é”æˆï¼`, highlightMeta);
                    }
                } else {
                    addWeekXP(player.id, 2);
                    player.fatigue = clamp((player.fatigue || 0) + Math.min(30, Math.round(outs * 4)), 0, 100);
                    player.morale = clamp((player.morale || 60) + (isWinner ? 1 : -1), 0, 100);
                }
            }
        });

        if(!teamRecap.pitching.starter){
            teamRecap.pitching.starter = { id: null, name: '-', role: 'SP', IP: 0, ER: 0, SO: 0, BB: 0, W: 0, L: 0 };
        }

        const topBat = [...teamRecap.batting]
            .filter(b => b.H > 0 || b.RBI > 0 || b.HR > 0)
            .sort((a,b)=>(b.RBI*3 + b.HR*4 + b.H*2) - (a.RBI*3 + a.HR*4 + a.H*2))[0];
        if(topBat){
            const parts=[];
            if(topBat.H>0) parts.push(`${topBat.H}å®‰æ‰“`);
            if(topBat.HR>0) parts.push(`${topBat.HR}æœ¬å¡æ‰“`);
            if(topBat.RBI>0) parts.push(`${topBat.RBI}æ‰“ç‚¹`);
            teamRecap.highlights.push(`${topBat.name}ãŒ${parts.join('ãƒ»')}`);
        }
        const starterHighlight = teamRecap.pitching.starter;
        if(starterHighlight && (starterHighlight.W || starterHighlight.IP >= 6)){
            const ipText = typeof starterHighlight.IP === 'number' ? starterHighlight.IP.toFixed(1) : starterHighlight.IP;
            teamRecap.highlights.push(`${starterHighlight.name}ãŒ${ipText}å›ž${starterHighlight.ER}å¤±ç‚¹ã®åŠ›æŠ•`);
        }
        return teamRecap;
    };

    const homeTeamRecap = processTeam('home');
    const awayTeamRecap = processTeam('away');

    const seenInjury = new Set();
    const injuryPool = injuryCandidates.filter(entry=>entry && entry.player && !seenInjury.has(entry.player.id) && seenInjury.add(entry.player.id));
    injuryPool.forEach(entry => {
        const player = entry.player;
        const tid = entry.tid;
        if(player.injury) return;
        let injuryChance = 0.003 + (player.fatigue || 0) / 6000;
        const injuryEffects = getPlayerEffects(player, 'player:injury');
        if(injuryEffects.injuryResist != null) injuryChance *= injuryEffects.injuryResist;
        const support = getTeamSupportAdjustments(tid);
        injuryChance *= (support.staff.injuryRate ?? 1) * (support.facilities.injuryRate ?? 1);
        if(rng() < injuryChance){
            const roll = rng();
            let injury_type = INJURY_TYPES[0];
            let acc = 0;
            for(const type of INJURY_TYPES){
                acc += type.chance;
                if(roll < acc){ injury_type = type; break; }
            }
            const durationBase = injury_type.min + Math.floor(rng() * (injury_type.max - injury_type.min + 1));
            const durationMult = Math.max(0.3, (support.staff.injuryDuration ?? 1) * (support.facilities.injuryDuration ?? 1));
            const duration = Math.max(1, Math.round(durationBase * durationMult));
            player.injury = { type: injury_type.name, duration };
            logHighlight('siren', `ã€è² å‚·é›¢è„±ã€‘${player.name}ãŒ${injury_type.name}ã§æˆ¦ç·šé›¢è„±... (å…¨æ²»${duration}æ—¥)`, highlightMeta);
            moveSquad(tid, player.id, 'äºŒè»', { force:true });
        }
    });

    const keyMoments = detail.keyMoments || [];
    const momentHighlights = keyMoments.map(m => {
        const halfText = m.half === 'top' ? 'è¡¨' : 'è£';
        return `${m.inning}å›ž${halfText} ${m.description}`;
    });

    recap.teams = { home: homeTeamRecap, away: awayTeamRecap };
    recap.keyMoments = keyMoments;
    recap.playLog = detail.events || [];
    recap.inningsLog = detail.innings || [];
    recap.pitcherTimeline = detail.pitcherTimeline || {};

    recap.highlights = [
        ...momentHighlights,
        ...homeTeamRecap.highlights.map(h => `${homeTeamRecap.team_name}: ${h}`),
        ...awayTeamRecap.highlights.map(h => `${awayTeamRecap.team_name}: ${h}`)
    ].filter(Boolean).slice(0, 12);

    const decidingMoment = [...keyMoments].reverse().find(m => m.side === winnerSide);
    const winnerRecap = winnerSide === 'home' ? homeTeamRecap : awayTeamRecap;
    if(decidingMoment){
        recap.decidingPlay = decidingMoment.description;
        if(decidingMoment.playerId) recap.decidingPlayerId = decidingMoment.playerId;
    } else {
        const fallback = winnerRecap.highlights[0] || (winnerRecap.batting[0]?.name ? `${winnerRecap.batting[0].name}ãŒæ´»èº` : null);
        if(fallback) recap.decidingPlay = fallback;
    }
    if(!recap.decidingPlayerId){
        const candidate = [...winnerRecap.batting]
            .filter(b => b.RBI > 0 || b.HR > 0 || b.H >= 2)
            .sort((a,b)=>(b.RBI*3 + b.HR*4 + b.H*1.5) - (a.RBI*3 + a.HR*4 + a.H*1.5))[0];
        if(candidate) recap.decidingPlayerId = candidate.id;
    }

    State.gameRecaps[key] = recap;

    if(keyMoments.length){
        const finalMoment = keyMoments[keyMoments.length-1];
        const scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
        logHighlight('clapperboard', `${scoreText} ${finalMoment.description}`, highlightMeta);
    }

    const storedKeys = Object.keys(State.gameRecaps);
    if (storedKeys.length > 600) {
        const sorted = storedKeys.sort((a,b)=>{
            const pa = parseGameRecapKey(a);
            const pb = parseGameRecapKey(b);
            return (pa?.day||0) - (pb?.day||0);
        });
        while (sorted.length > 600) {
            const oldest = sorted.shift();
            if (oldest && oldest !== key) delete State.gameRecaps[oldest];
        }
    }
    return true;
}

function allocateGameStats(res) {
    const isGameDay = State.schedule.some(evt=>evt.day===res.day && (evt?.type||'game')==='game');
    if(!isGameDay) return;
    const rng = mulberry32(res.day * 101 + res.home_id * 17 + res.away_id);
    const key = gameRecapKey(res.day, res.home_id, res.away_id);
    const highlightMeta = { gameKey: key, day: res.day, home_id: res.home_id, away_id: res.away_id };
    if(res.detailed){
        const handled = allocateGameStatsDetailed(res, res.detailed, rng, key, highlightMeta);
        if(handled) return;
    }
    const recap = {
        gameKey: key,
        season: State.season,
        day: res.day,
        home_id: res.home_id,
        away_id: res.away_id,
        innings: res.innings || 9,
        score: { home: res.home_runs, away: res.away_runs },
        winner_id: res.winner_id,
        highlights: [],
        teams: {}
    };

    const processTeam = (team_id, runs, opp_runs, isWinner) => {
        const lineup = pickDayLineup(team_id, res.day);
        const teamRecap = {
            team_id,
            team_name: id2name(team_id),
            runs,
            batting: [],
            pitching: { starter: null, relievers: [] },
            highlights: []
        };
        if (!lineup.bats.length || !lineup.sp) return teamRecap;

        const allPlaying = [...lineup.bats, lineup.sp, ...lineup.rps];
        allPlaying.forEach(player => {
            if(player.injury) return;
            let injury_chance = 0.003 + (player.fatigue / 6000);
            const injuryEffects = getPlayerEffects(player, 'player:injury');
            if(injuryEffects.injuryResist != null) injury_chance *= injuryEffects.injuryResist;
            const support = getTeamSupportAdjustments(tid);
            injury_chance *= (support.staff.injuryRate ?? 1) * (support.facilities.injuryRate ?? 1);
            if(rng() < injury_chance){
                const r = rng();
                let injury_type = INJURY_TYPES[0];
                let accumulated_chance = 0;
                for(const type of INJURY_TYPES){
                    accumulated_chance += type.chance;
                    if(r < accumulated_chance){
                        injury_type = type;
                        break;
                    }
                }
                const duration = injury_type.min + Math.floor(rng() * (injury_type.max - injury_type.min + 1));
                player.injury = { type: injury_type.name, duration: duration };
                logHighlight('siren', `ã€è² å‚·é›¢è„±ã€‘${player.name}ãŒ${injury_type.name}ã§æˆ¦ç·šé›¢è„±... (å…¨æ²»${duration}æ—¥)`, highlightMeta);
                moveSquad(team_id, player.id, 'äºŒè»', { force:true });
            }
        });

        lineup.bats.forEach(batter => {
            addWeekXP(batter.id, 4);
            batter.fatigue = clamp((batter.fatigue || 0) + 10, 0, 100);
            batter.morale = clamp(batter.morale + (isWinner ? 2 : -1), 0, 100);
        });

        const sp = lineup.sp;
        const rps = lineup.rps;
        const spIPRaw = clamp(5 + (rng() * 4 - 2), 1, 7);
        const spIP = Math.round(spIPRaw * 10) / 10;
        const totalInnings = res.innings || 9;
        const rpIP = Math.max(0, totalInnings - spIPRaw);

        addWeekXP(sp.id, 4);
        sp.fatigue = clamp((sp.fatigue || 0) + 12 * spIPRaw, 0, 100);
        sp.morale = clamp(sp.morale + (isWinner ? 3 : -2), 0, 100);

        const numRelieversUsed = rpIP > 3 ? 3 : (rpIP > 0 ? 2 : 0);
        if (rpIP > 0 && rps.length > 0) {
             for (let i = 0; i < numRelieversUsed && i < rps.length; i++) {
                const p = rps[i];
                addWeekXP(p.id, 2);
                p.fatigue = clamp((p.fatigue || 0) + 25, 0, 100);
                p.morale = clamp(p.morale + (isWinner ? 1 : -1), 0, 100);
            }
        }

        const hits = Math.round(runs * (1.6 + rng() * 0.8) + (runs > 0 ? 1 : 0));
        const walks = Math.max(0, Math.round((hits / 3.5) + (rng() * 4 - 2)));
        const strikeouts = Math.max(0, Math.round(7 + (rng() * 6 - 3)));
        const batterLogs = new Map();
        let hits_by_player = {}, walks_by_player = {}, so_by_player = {};

        for (let i = 0; i < hits; i++) {
            const p = weightedRandom(lineup.bats, b => b.con, rng);
            hits_by_player[p.id] = (hits_by_player[p.id] || 0) + 1;
        }
        for (let i = 0; i < walks; i++) {
            const p = weightedRandom(lineup.bats, b => b.disc, rng);
            walks_by_player[p.id] = (walks_by_player[p.id] || 0) + 1;
        }
        for (let i = 0; i < strikeouts; i++) {
            const p = weightedRandom(lineup.bats, b => 105 - b.con, rng);
            so_by_player[p.id] = (so_by_player[p.id] || 0) + 1;
        }

        lineup.bats.forEach(b => {
            initializePlayerStats(b.id);
            const log = { day: res.day, H: hits_by_player[b.id] || 0, BB: walks_by_player[b.id] || 0, SO: so_by_player[b.id] || 0, AB: 4 + (rng() > 0.5 ? 1 : 0) };
            log.HR = Math.floor(log.H * (b.pwr / 700.0) * (0.8 + rng() * 0.4));
            log.RBI = Math.round((log.H * 0.5) + (log.HR * 1.5));
            batterLogs.set(b.id, log);
            State.playerGameLogs[b.id].push(log);

            if(log.H >= 3 && rng() < 0.1) { b.status.hot = Math.max(b.status.hot || 0, 2); }
            if(log.AB > 3 && log.H === 0 && rng() < 0.08) { b.status.slump = Math.max(b.status.slump || 0, 1); }
            if (log.HR >= 3) { logHighlight('bomb', `ã€å¤§çˆ†ç™ºã€‘${b.name}ãŒ1è©¦åˆ3æœ¬å¡æ‰“ã®å¤§æ´»èºï¼`, highlightMeta); }
            else if (log.H >= 4) { logHighlight('swords', `ã€çŒ›æ‰“è³žã€‘${b.name}ãŒ4å®‰æ‰“ã®å¤§æš´ã‚Œï¼`, highlightMeta); }
        });

        teamRecap.batting = lineup.bats.map((b, idx) => {
            const stats = batterLogs.get(b.id) || { AB:0, H:0, HR:0, RBI:0, BB:0, SO:0 };
            return {
                order: idx + 1,
                id: b.id,
                name: b.name,
                pos: b.pos || b.position || '-',
                AB: stats.AB,
                H: stats.H,
                HR: stats.HR,
                RBI: stats.RBI,
                BB: stats.BB,
                SO: stats.SO
            };
        });

        const sps = State.playerStats[sp.id] = State.playerStats[sp.id] || {};
        const spShare = spIPRaw / totalInnings;
        const spRunsAllowed = Math.round(opp_runs * spShare);
        const spLog = {
            day: res.day,
            GS: 1,
            IP: spIP,
            ER: Math.round(spRunsAllowed * 0.92),
            SO: Math.round(Math.max(0, 7 + (rng() * 6 - 3)) * spShare),
            BB: Math.round(Math.max(0, (Math.round(opp_runs * (1.6+rng()*0.8)*spShare) / 3.5) + (rng() * 4 - 2)) * spShare)
        };
        if (isWinner && spIPRaw >= 5) spLog.W=1; else if (!isWinner) spLog.L=1;
        initializePlayerStats(sp.id); State.playerGameLogs[sp.id].push(spLog);

        const totalWins = (State.playerGameLogs[sp.id] || []).reduce((sum, log) => sum + (log.W || 0), 0);
        if (spLog.W === 1 && totalWins === 1 && sp.age <= 22) { logHighlight('trophy', `ã€åˆå‹åˆ©ðŸŽ‰ã€‘ãƒ«ãƒ¼ã‚­ãƒ¼ã®${sp.name}æŠ•æ‰‹ãŒãƒ—ãƒ­åˆå‹åˆ©ã‚’æŒ™ã’ã¾ã—ãŸï¼è¨˜å¿µã™ã¹ãæ—¥ã§ã™ã€‚`, highlightMeta); }
        if (spLog.IP >= 9 && spLog.ER === 0) { logHighlight('shield-check', `ã€å¿«æŒ™ã€‘${sp.name}ãŒå®Œå°å‹åˆ©ã‚’é”æˆã—ã¾ã—ãŸï¼`, highlightMeta); }

        if (spIPRaw >= 6 && spLog.ER <= 1 && rng() < 0.12) { lineup.sp.status.hot = Math.max(lineup.sp.status.hot || 0, 1); }
        if (spIPRaw < 5 && spLog.ER >= 3 && rng() < 0.09) { lineup.sp.status.slump = Math.max(lineup.sp.status.slump || 0, 1); }

        teamRecap.pitching.starter = {
            id: sp.id,
            name: sp.name,
            IP: spLog.IP,
            ER: spLog.ER,
            SO: spLog.SO,
            BB: spLog.BB,
            W: spLog.W || 0,
            L: spLog.L || 0
        };

        if (rpIP > 0 && rps.length > 0) {
            rps.slice(0, numRelieversUsed).forEach((rp, i) => {
                const rpShare = (rpIP / Math.max(1, numRelieversUsed)) / totalInnings;
                const rpIPEach = Math.round((rpIP / Math.max(1, numRelieversUsed)) * 10) / 10;
                const rpLog = {
                    day: res.day,
                    IP: rpIPEach,
                    ER: Math.round(opp_runs * rpShare * 0.92),
                    SO: Math.max(0, Math.round((4 + rng() * 4 - 2) * rpShare * totalInnings)),
                    BB: Math.max(0, Math.round((2 + rng() * 3 - 1) * rpShare * totalInnings))
                };
                if (isWinner && (runs - opp_runs <= 3) && i === numRelieversUsed - 1) rpLog.SV=1;
                initializePlayerStats(rp.id); State.playerGameLogs[rp.id].push(rpLog);
                teamRecap.pitching.relievers.push({
                    id: rp.id,
                    name: rp.name,
                    IP: rpLog.IP,
                    ER: rpLog.ER,
                    SO: rpLog.SO,
                    BB: rpLog.BB,
                    SV: rpLog.SV || 0
                });
            });
        }

        const battingHighlight = [...teamRecap.batting]
            .filter(b => b.H > 0 || b.RBI > 0 || b.HR > 0)
            .sort((a,b)=> (b.RBI*3 + b.HR*4 + b.H*2) - (a.RBI*3 + a.HR*4 + a.H*2))[0];
        if (battingHighlight) {
            const detail = [`${battingHighlight.H}å®‰æ‰“`];
            if (battingHighlight.HR > 0) detail.push(`${battingHighlight.HR}æœ¬å¡æ‰“`);
            if (battingHighlight.RBI > 0) detail.push(`${battingHighlight.RBI}æ‰“ç‚¹`);
            teamRecap.highlights.push(`${battingHighlight.name}ãŒ${detail.join('ãƒ»')}`);
        }

        const starterHighlight = teamRecap.pitching.starter;
        if (starterHighlight && (starterHighlight.W || starterHighlight.IP >= 6)) {
            const parts = [`${starterHighlight.name} ${starterHighlight.IP.toFixed ? starterHighlight.IP.toFixed(1) : starterHighlight.IP}å›ž`];
            parts.push(`${starterHighlight.ER}å¤±ç‚¹`);
            if (starterHighlight.W) parts.push('å‹åˆ©æŠ•æ‰‹');
            teamRecap.highlights.push(parts.join(' '));
        }

        return teamRecap;
    };

    const homeRecap = processTeam(res.home_id, res.home_runs, res.away_runs, res.winner_id === res.home_id);
    const awayRecap = processTeam(res.away_id, res.away_runs, res.home_runs, res.winner_id === res.away_id);
    recap.teams = { home: homeRecap, away: awayRecap };

    const scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
    recap.scoreText = scoreText;
    recap.highlights = [`${id2name(res.winner_id)}ãŒ${scoreText}ã§å‹åˆ©`, ...(homeRecap?.highlights||[]), ...(awayRecap?.highlights||[])].filter(Boolean);

    const winnerRecap = res.winner_id === res.home_id ? homeRecap : awayRecap;
    if (winnerRecap) {
        const candidate = [...(winnerRecap.batting||[])]
            .filter(b => b.RBI > 0 || b.HR > 0 || b.H >= 2)
            .sort((a,b)=> (b.RBI*3 + b.HR*4 + b.H*1.5) - (a.RBI*3 + a.HR*4 + a.H*1.5))[0];
        if (candidate) {
            const details = [];
            if (candidate.H > 0) details.push(`${candidate.H}å®‰æ‰“`);
            if (candidate.HR > 0) details.push(`${candidate.HR}æœ¬å¡æ‰“`);
            if (candidate.RBI > 0) details.push(`${candidate.RBI}æ‰“ç‚¹`);
            recap.decidingPlay = `${candidate.name}ã®${details.join('ãƒ»')}`;
            recap.decidingPlayerId = candidate.id;
        } else if (winnerRecap.pitching?.starter) {
            const p = winnerRecap.pitching.starter;
            recap.decidingPlay = `${p.name}ãŒ${(p.IP.toFixed ? p.IP.toFixed(1) : p.IP)}å›ž${p.ER}å¤±ç‚¹ã®åŠ›æŠ•`;
            recap.decidingPlayerId = p.id;
        } else {
            recap.decidingPlay = `${winnerRecap.team_name}ãŒ${res.home_runs}-${res.away_runs}ã§å‹åˆ©`;
        }
    }

    State.gameRecaps[key] = recap;
    const storedKeys = Object.keys(State.gameRecaps);
    if (storedKeys.length > 600) {
        const sorted = storedKeys.sort((a,b)=>{
            const pa = parseGameRecapKey(a);
            const pb = parseGameRecapKey(b);
            return (pa?.day||0) - (pb?.day||0);
        });
        while (sorted.length > 600) {
            const oldest = sorted.shift();
            if (oldest && oldest !== key) delete State.gameRecaps[oldest];
        }
    }
}

// ====== UI Renderers ======
function id2name(id){return State.teams.find(t=>t.team_id===id)?.team??`Team ${id}`}
const scheduleView = createScheduleView({
  describeStage,
  getCalendarEntry: day => getCalendarEntry(day),
  maxDay: () => maxDay(),
  id2name,
  querySelector: $,
  createElement: el,
  selectors: {
    seasonLabel: '#seasonLabel',
    dayLabel: '#dayLabel',
    gamesLabel: '#gamesLabel',
    container: '#todayMatchups'
  }
});
const draftView = createDraftView({
  createElement: el,
  getState: () => State,
  ensureDraft,
  ensureTeamMeta,
  ensureTeamNeedsAll,
  ensureProspectStructure,
  id2name,
  generateDraftClass: () => {
    const order = draftOrderFromStandings();
    const prospects = generateProspects();
    initializeDraftState(State, { order, prospects, rounds: 5, year: State.season || 1 });
    State.devLogs.push(`ãƒ‰ãƒ©ãƒ•ãƒˆã‚¯ãƒ©ã‚¹ç”Ÿæˆ: å€™è£œè€…${State.draft.pool?.length || 0}å`);
    saveAndRerender();
  },
  scouting: {
    SCOUT_ASSIGN_COST,
    assignmentLimit: scoutingAssignmentLimit,
    progressDisplay: (prospect, tid) => scoutingProgressDisplay(prospect, tid),
    statCell: (prospect, attr, tid) => scoutedStatTd(prospect, attr, tid),
    growthCurveSVG: (type) => createGrowthCurveSVG(type),
    showReport: (prospect, tid) => showScoutReportModal(prospect, tid),
    toggleAssignment: (tid, prospect) => toggleScoutAssignment(tid, prospect),
    evaluateScouted: (prospect, tid) => evaluateScoutedProspect(prospect, tid),
  },
  actions: {
    submitBid: (teamId, prospectId) => submitDraftBid(State, teamId, prospectId),
    selectProspect: (teamId, prospectId) => {
      const result = selectDraftProspect(State, teamId, prospectId, { onLog: handleDraftEvent });
      if (result) {
        completeDraftSelection(teamId, result);
      }
      return result;
    },
    shouldResolveFirstRound: () => shouldResolveDraftFirstRound(State),
    processFirstRoundResolution: () => processFirstRoundResolution(),
    checkDraftCompletion: () => checkDraftCompletion(),
    getPendingTeams: () => getDraftPendingTeams(State),
    getOnClockTeam: () => getDraftOnClockTeamId(State),
    isDraftComplete: () => isDraftComplete(State),
    autoUntilUser: (tid) => autoUntilUserTurn(tid),
    autoDraftStep: (stopTid) => autoDraftStep(stopTid),
    saveAndRerender: () => saveAndRerender(),
    saveState: () => save(),
  },
  qa: {
    evaluateProspectForTeam: (prospect, tid) => evaluateProspectForTeam(prospect, tid),
    getNextDraftActor: () => getNextDraftActor(),
  },
  refreshIcons,
});
const contractsView = createContractsView({
  createElement: el,
  evaluateOffer: evaluateNegotiation,
  valuePlayerContract,
  normalizeContractTerms,
  ensurePlayerPersona,
  ensurePlayerContract,
  normalizeContract,
  upsertFinanceContract,
  updateFinancialSnapshots,
  logHighlight,
  getOverall,
  onStateChange: saveAndRerender,
  recomputeAllRatingsAll,
  processFreeAgentSigning,
  millionFormatter,
  refreshIcons,
});
const faView = createFAView({
  createElement: el,
  ensureFreeAgencyState,
  determineFreeAgencyEligibility,
  rankFreeAgent,
  getOverall,
  millionFormatter,
  onStateChange: saveAndRerender,
  refreshIcons,
});
const staffView = createStaffView({
  createElement: el,
  getState: () => State,
  ensureTeamFinances,
  ensureTeamMeta,
  updateFinancialSnapshots,
  id2name,
  millionFormatter,
  staffCosts: STAFF_COSTS,
  logHighlight,
  actions: {
    saveAndRerender: () => saveAndRerender(),
    canControlTeam,
    showToast,
  },
  refreshIcons,
});
const financeView = createFinanceView({
  createElement: el,
  getState: () => State,
  ensureTeamFinances,
  ensureTeamFans: (state, tid) => ensureTeamFansState(state, tid),
  ensureSponsorDeals: (state, tid) => ensureSponsorDealsState(state, tid),
  millionFormatter,
  yenFormatter,
  createSparklineWithTooltip,
  createSparklineSVG,
  computeAttendanceForGame: (_state, result) => estimateGameAttendance(result.home_id, result.away_id),
  refreshIcons,
});
const facilitiesView = createFacilitiesView({
  createElement: el,
  getState: () => State,
  ensureTeamMeta,
  ensureTeamFacilities,
  updateTeamFacilities,
  computeFacilityAdjustments,
  id2name,
  actions: {
    saveAndRerender: () => saveAndRerender(),
    canControlTeam,
    showToast,
  },
  refreshIcons,
});
function canControlTeam(tid){ const userTid = Number(State.userTeamId ?? 0); return !!State.commissioner || Number(tid) === userTid; }

function logHighlight(icon, text, meta={}) {
    if (!State.highlights) State.highlights = [];
    const entryDay = meta.day ?? State.curr_day;
    const entry = { season: State.season, day: entryDay, icon, text };
    if (meta.gameKey) {
        entry.gameKey = meta.gameKey;
    } else if (meta.day != null && meta.home_id != null && meta.away_id != null) {
        entry.gameKey = gameRecapKey(meta.day, meta.home_id, meta.away_id);
    }
    if (meta.category) entry.category = meta.category;
    if (meta.tag) entry.tag = meta.tag;
    if (meta.financeType) entry.financeType = meta.financeType;
    if (meta.tid != null) entry.team_id = meta.tid;
    State.highlights.push(entry);
}

function renderUserControls(){
  // This logic is now handled in the init() function to sync with teamSelectionStore.
  // We only handle the mode select here now.
  const mode = document.querySelector('#modeSelect');
  if(mode){ mode.value = State.commissioner? 'comm':'user';
    mode.onchange = ()=>{ State.commissioner = (mode.value==='comm'); saveAndRerender(); };
  }
}

function renderSeasonSettings(){
  ensureNarrativeState();
  const freqSelect = document.querySelector('#eventFrequency');
  if(freqSelect){
    const freq = State.narrativeSettings?.frequency || 'standard';
    if(freqSelect.value !== freq) freqSelect.value = freq;
    freqSelect.onchange = () => {
      ensureNarrativeState();
      State.narrativeSettings.frequency = freqSelect.value;
      save();
    };
  }
  const themeSelect = document.querySelector('#eventTheme');
  if(themeSelect){
    const theme = State.narrativeSettings?.theme || 'balanced';
    if(themeSelect.value !== theme) themeSelect.value = theme;
    themeSelect.onchange = () => {
      ensureNarrativeState();
      State.narrativeSettings.theme = themeSelect.value;
      save();
    };
  }

  const ruleSelect = document.querySelector('#ruleSet');
  if (ruleSelect) {
    if (ruleSelect.options.length === 0) {
      const allRulesets = getAllRulesets();
      allRulesets.forEach(rs => {
        ruleSelect.append(el('option', { value: rs.id }, rs.name));
      });
    }
    const currentRuleId = State.ruleId || 'npb-2025';
    if (ruleSelect.value !== currentRuleId) {
      ruleSelect.value = currentRuleId;
    }
    ruleSelect.onchange = () => {
      const newRuleId = ruleSelect.value;
      if (newRuleId === State.ruleId) return;

      // Get old rules before changing state
      const oldRules = rulesStore.get();

      // Update state and get new rules
      State.ruleId = newRuleId;
      normalizeLeagueState(State);
      const newRules = rulesStore.get();
      saveAndRerender();

      const scheduleRelevantChanges = (
        JSON.stringify(oldRules.game) !== JSON.stringify(newRules.game) ||
        JSON.stringify(oldRules.interleague) !== JSON.stringify(newRules.interleague) ||
        oldRules.gamesPerTeam !== newRules.gamesPerTeam
      );

      if (scheduleRelevantChanges) {
        if (confirm('ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã®å¤‰æ›´ã«ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†ç”ŸæˆãŒå¿…è¦ã§ã™ã€‚å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ\næ³¨æ„: ç¾åœ¨ã®ã‚·ãƒ¼ã‚ºãƒ³é€²è¡ŒçŠ¶æ³ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚')) {
          const seed=parseInt($("#seed").value)||2025;
          const reps=parseInt($("#repeats").value)||6;

          const { schedule, calendarInfo } = generateSchedule({
            teams: State.teams,
            rules: newRules,
            seed: seed + State.season,
            repeats: reps
          });

          State.seasonInfo = calendarInfo;
          normalizeSeasonInfo(State);

          State.league.rules.gamesPerTeam = calendarInfo.gamesPerTeam || newRules.gamesPerTeam;

          State.schedule = schedule;
          State.results=[];
          State.curr_day=1;
          State.weekXP={}; State.weekXPLog={};
          State.squadsInit=false;
          State.playerGameLogs = {};
          ensureSquads();
          recomputeAllRatingsAll();
          saveAndRerender();
        }
      }
    };
  }
}

function renderTeamNarrativePanel(tid){
  ensureNarrativeState();
  const narrative=State.teamNarratives?.[tid];
  if(!narrative) return null;
  const moralePoints=(narrative.morale||[]).slice(-20);
  const recentEvents=(narrative.events||[]).slice(-4).reverse();
  if(!moralePoints.length && !recentEvents.length) return null;

  const panel=el('div',{class:'management-narrative-panel'});
  const header=el('div',{class:'management-narrative-header'},
    el('div',{style:'display:flex;align-items:center;gap:8px;'},
      el('i',{ 'data-lucide':'drama', class:'mini-icon' }),
      el('strong',{}, `${id2name(tid)} å£«æ°—ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰`)
    ),
    (()=>{
      const btn=el('button',{class:'ghost', type:'button'}, el('i',{ 'data-lucide':'notebook-text', class:'mini-icon' }), 'å±¥æ­´');
      btn.onclick=()=>showNarrativeLogModal(tid);
      return btn;
    })()
  );
  panel.append(header);

  const grid=el('div',{class:'management-narrative-grid'});

  const timelineCard=el('div',{class:'narrative-subcard'});
  timelineCard.append(el('h4',{}, el('i',{ 'data-lucide':'activity', class:'mini-icon' }), 'ãƒãƒ¼ãƒ å£«æ°—ãƒˆãƒ¬ãƒ³ãƒ‰'));
  if(moralePoints.length>=2){
    const values=moralePoints.map(p=>p.value);
    const latest=values[values.length-1];
    const avg=Math.round(values.reduce((a,b)=>a+b,0)/values.length);
    const timelineRow=el('div',{class:'morale-timeline'});
    timelineRow.append(el('span',{},`æœ€æ–° ${latest}`));
    timelineRow.append(createSparklineSVG(values, 'var(--accent)', 140, 28));
    timelineRow.append(el('span',{},`å¹³å‡ ${avg}`));
    timelineCard.append(timelineRow);
    const meta=moralePoints[moralePoints.length-1];
    timelineCard.append(el('p',{class:'mini', style:'margin:0;color:var(--text-secondary);'}, `${meta.season}å¹´ç›® Day ${meta.day}`));
  } else if(moralePoints.length===1){
    const point=moralePoints[0];
    timelineCard.append(el('div',{class:'morale-timeline'},
      el('span',{},`ç¾åœ¨å€¤ ${point.value}`)
    ));
    timelineCard.append(el('p',{class:'mini', style:'margin:0;color:var(--text-secondary);'}, `${point.season}å¹´ç›® Day ${point.day}`));
  } else {
    timelineCard.append(el('div',{class:'narrative-log-empty'},'å£«æ°—ãƒ‡ãƒ¼ã‚¿ãŒã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚'));
  }
  grid.append(timelineCard);

  const logCard=el('div',{class:'narrative-subcard'});
  logCard.append(el('h4',{}, el('i',{ 'data-lucide':'sparkles', class:'mini-icon' }), 'ç›´è¿‘ã‚¤ãƒ™ãƒ³ãƒˆ'));
  if(recentEvents.length){
    const list=el('ul',{class:'narrative-log-list'});
    recentEvents.forEach(evt=>{
      const item=el('li',{class:'narrative-log-item'});
      item.append(el('span',{class:'narrative-tag'}, evt.tag || 'NARRATIVE'));
      const summary=evt.summary || evt.title || '';
      if(summary) item.append(document.createTextNode(` ${summary}`));
      item.append(el('div',{class:'mini'}, `${evt.season}å¹´ç›® Day ${evt.day}`));
      list.append(item);
    });
    logCard.append(list);
  } else {
    logCard.append(el('div',{class:'narrative-log-empty'},'æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚'));
  }
  grid.append(logCard);

  panel.append(grid);
  return panel;
}
function teamOptions(sel){ sel.innerHTML=""; State.teams.forEach(t=> sel.append(el("option",{value:t.team_id},t.team))); }
function statTd(val){ const tier=val>=90?"s":val>=80?"a":val>=70?"b":val>=60?"c":val>=50?"d":"f"; return el("td",{}, el("span",{class:`stat stat-${tier}`},val)); }

function ensureProspectStructure(prospect){
  if(!prospect) return prospect;
  if(!prospect.trueRatings){
    if(prospect.type==='BAT'){
      prospect.trueRatings={
        con: prospect.con??60,
        disc: prospect.disc??60,
        pwr: prospect.pwr??60,
        spd: prospect.spd??60,
        fld: prospect.fld??60,
        pot: prospect.pot??70
      };
    } else {
      prospect.trueRatings={
        velo: prospect.velo??60,
        ctrl: prospect.ctrl??60,
        mov: prospect.mov??60,
        stam: prospect.stam??60,
        pot: prospect.pot??70
      };
    }
  }
  if(typeof prospect.isForeign !== 'boolean') prospect.isForeign = Boolean(prospect.isForeign);
  if(!prospect.origin) prospect.origin = prospect.isForeign ? 'international' : 'domestic';
  const age=Number.isFinite(prospect.age)?prospect.age:20;
  if(!Number.isFinite(prospect.age)) prospect.age=age;
  const level=resolveProspectLevel(prospect);
  prospect.level=level;
  if(!prospect.ageBand){ prospect.ageBand = age<=19?'18-19æ­³':age<=21?'20-21æ­³':age<=24?'22-24æ­³':age<=27?'25-27æ­³':'28æ­³ä»¥ä¸Š'; }
  if(!prospect.scouting){
    const seedBase = hashString(prospect.pid||prospect.name||`${Math.random()}`);
    const rng = mulberry32(seedBase>>>0);
    prospect.scouting=createScoutingProfile(prospect.trueRatings, prospect.type, level, rng);
  }
  prospect.scouting.baseGrades = prospect.scouting.baseGrades||{};
  prospect.scouting.errors = prospect.scouting.errors||{};
  prospect.scouting.hiddenAttrs = prospect.scouting.hiddenAttrs||{};
  prospect.scouting.revealThreshold = prospect.scouting.revealThreshold||{};
  prospect.scouting.teams = prospect.scouting.teams||{};
  prospect.scouting.events = prospect.scouting.events || generateProspectEvents(prospect.type, prospect.trueRatings, mulberry32((hashString((prospect.pid||'')+':events'))>>>0));
  if(!prospect.pos){ if(prospect.type==='PIT'){ const role=(prospect.role||'RP').toUpperCase(); prospect.pos=role==='SP'?'SP':'RP'; } else { prospect.pos='IF'; } }
  if(!prospect.potRange || !Number.isFinite(prospect.potRange.min) || !Number.isFinite(prospect.potRange.max)){ const pot=prospect.trueRatings?.pot??70; const spread=6; prospect.potRange={ min: clamp(pot-spread-1,20,99), max: clamp(pot+spread+2,20,99) }; } else { prospect.potRange={ min: clamp(prospect.potRange.min,20,99), max: clamp(prospect.potRange.max,20,99) }; }
  if(typeof prospect.riskInjury!=='number'){ const seed=hashString((prospect.pid||prospect.name||'risk')+':risk'); const rng=mulberry32(seed>>>0); const base=prospect.type==='PIT'?52:45; const val=Math.round(base + (age-19)*(prospect.type==='PIT'?1.6:1.2) + (rng()*18-9)); prospect.riskInjury=clamp(val,10,95); } else { prospect.riskInjury=clamp(Math.round(prospect.riskInjury),0,100); }
  if(typeof prospect.signWillingness!=='number'){ const seed=hashString((prospect.pid||prospect.name||'sign')+':sign'); const rng=mulberry32(seed>>>0); const baseMap={é«˜æ ¡:62,å¤§å­¦:68,ç¤¾ä¼šäºº:64,ç‹¬ç«‹ãƒªãƒ¼ã‚°:58,æµ·å¤–:66}; const base=baseMap[prospect.level]??63; prospect.signWillingness=clamp(Math.round(base + (rng()*22-11)),25,95); } else { prospect.signWillingness=clamp(Math.round(prospect.signWillingness),0,100); }
  return prospect;
}

function ensureProspectTeamReport(prospect, tid){
  ensureProspectStructure(prospect);
  const teams=prospect.scouting.teams;
  if(!teams[tid]){ teams[tid]={ progress:0, lastUpdate:null }; }
  if(typeof teams[tid].progress!=='number'){ teams[tid].progress=0; }
  return teams[tid];
}

function getProspectAttributeList(prospect){
  if(prospect.type==='BAT') return ['con','disc','pwr','spd','fld','pot'];
  return ['velo','ctrl','mov','stam','pot'];
}

function prospectAttributeLabel(prospect, attr){
  if(prospect.type==='BAT'){
    const map={con:'ãƒŸãƒ¼ãƒˆ',disc:'é¸çƒçœ¼',pwr:'ãƒ‘ãƒ¯ãƒ¼',spd:'èµ°åŠ›',fld:'å®ˆå‚™',pot:'æ½œåœ¨'};
    return map[attr]||attr;
  }
  const map={velo:'çƒé€Ÿ',ctrl:'åˆ¶çƒ',mov:'å¤‰åŒ–',stam:'ä½“åŠ›',pot:'æ½œåœ¨'};
  return map[attr]||attr;
}

function scoutedDisplayData(prospect, attr, tid){
  ensureProspectStructure(prospect);
  const trueRatings=prospect.trueRatings||{};
  const trueVal=trueRatings[attr];
  if(trueVal==null) return { known:false, value:null, margin:null, progress:0 };
  const baseGrades=prospect.scouting.baseGrades||{};
  const errors=prospect.scouting.errors||{};
  const baseVal=baseGrades[attr]??trueVal;
  const error=errors[attr]??(baseVal-trueVal);
  const report=tid!=null?ensureProspectTeamReport(prospect, tid):{progress:0};
  const progress=clamp(report.progress||0,0,1);
  const revealThreshold=prospect.scouting.revealThreshold?.[attr]??0;
  const hidden=prospect.scouting.hiddenAttrs?.[attr]??false;
  const known=!hidden || progress>=revealThreshold;
  const value=Math.round(clamp(trueVal + error*(1-progress),20,99));
  const margin=known?Math.max(0, Math.round(Math.abs(error)*(1-progress))):null;
  return { known, value, margin, progress };
}

function scoutedStatTd(prospect, attr, tid){
  const data=scoutedDisplayData(prospect, attr, tid);
  if(!data.known){ return el('td',{class:'scout-unknown'}, el('span',{},'??')); }
  const tier=data.value>=90?'s':data.value>=80?'a':data.value>=70?'b':data.value>=60?'c':data.value>=50?'d':'f';
  const span=el('span',{class:`stat stat-${tier}`});
  span.textContent=data.value;
  if(data.margin && data.margin>0){ span.append(el('span',{class:'margin'},`Â±${data.margin}`)); }
  return el('td',{}, span);
}

function scoutingProgressDisplay(prospect, tid){
  const report=ensureProspectTeamReport(prospect, tid);
  const percent=Math.round(clamp(report.progress||0,0,1)*100);
  const bar=el('div',{class:'scout-progress'}, el('span',{style:`width:${percent}%`}));
  const label=el('div',{class:'scout-progress-label'}, `${percent}%`);
  return el('div',{style:'display:flex;flex-direction:column;align-items:flex-end;gap:4px;'}, bar, label);
}

function evaluateScoutedProspect(prospect, tid){
  ensureProspectStructure(prospect);
  const attrs=prospect.type==='BAT'
    ? [['pot',1.1],['pwr',0.4],['con',0.4],['spd',0.2]]
    : [['pot',1.1],['velo',0.35],['mov',0.35],['ctrl',0.25]];
  let score=0;
  attrs.forEach(([attr,weight])=>{
    const data=scoutedDisplayData(prospect, attr, tid);
    const value=data.known?data.value: (prospect.scouting.baseGrades?.[attr]??60);
    score+=value*weight;
  });
  if(prospect.type!=='BAT' && prospect.role==='SP'){ score+=5; }
  if(tid!=null){
    ensureTeamNeedsAll();
    const team=State.teams?.find(t=>t.team_id===tid);
    if(team){
      const bucket=prospectNeedBucket(prospect);
      const need=clamp((team.needs?.[bucket])??0,0,1.5);
      score*=1+need*0.4;
    }
  }
  if(prospect.potRange){ const range=prospect.potRange; score+=clamp((range.max-range.min),0,25)*0.08; }
  if(typeof prospect.signWillingness==='number'){ score*=1+clamp((prospect.signWillingness-60)/230,-0.2,0.3); }
  if(typeof prospect.riskInjury==='number'){ score*=1-clamp((prospect.riskInjury-50)/230,-0.25,0.25); }
  return score;
}

function createSparklineSVG(data, color, width=40, height=16, ghostData = null) {
    if (!data || data.length < 2) return el('div');
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.style.overflow = 'visible';
    
    const allData = ghostData ? [...data, ...ghostData] : data;
    const maxVal = Math.max(...allData);
    const minVal = Math.min(...allData);
    const range = maxVal - minVal === 0 ? 1 : maxVal - minVal;

    function createPolyline(d, c, dash = false) {
        const points = d.map((val, i) => {
            const x = (i / (d.length - 1)) * width;
            const y = height - ((val - minVal) / range) * (height - 2) - 1;
            return `${x.toFixed(2)},${y.toFixed(2)}`;
        }).join(' ');
        
        const polyline = document.createElementNS(svgNS, 'polyline');
        polyline.setAttribute('points', points);
        polyline.setAttribute('fill', 'none');
        polyline.setAttribute('stroke', c);
        polyline.setAttribute('stroke-width', '1.5');
        polyline.setAttribute('stroke-linecap', 'round');
        polyline.setAttribute('stroke-linejoin', 'round');
        if (dash) polyline.setAttribute('stroke-dasharray', '2,2');
        return polyline;
    }

    if(ghostData) svg.append(createPolyline(ghostData, 'rgba(150,150,180,0.5)', true));
    svg.append(createPolyline(data, color));
    
    return svg;
}

function createGrowthCurveSVG(type, width=40, height=16) {
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const curves = {
        prodigy:  [3, 2, 2, 1, 1],
        late:     [14, 13, 11, 7, 2],
        standard: [14, 11, 8, 5, 2],
        early:    [12, 6, 4, 3, 3],
        bust:     [15, 15, 14, 14, 14]
    };
    const data = curves[type] || curves['standard'];
    
    const points = data.map((d, i) => {
        const x = (i / (data.length - 1)) * width;
        const y = d;
        return `${x.toFixed(2)},${y.toFixed(2)}`;
    }).join(' ');
    
    const polyline = document.createElementNS(svgNS, 'polyline');
    polyline.setAttribute('points', points);
    polyline.setAttribute('fill', 'none');
    polyline.setAttribute('stroke', 'var(--primary)');
    polyline.setAttribute('stroke-width', '2');
    polyline.setAttribute('stroke-linecap', 'round');
    polyline.setAttribute('stroke-linejoin', 'round');

    svg.append(polyline);
    return svg;
}


function createRadarChartSVG(stats) {
    const svgNS = "http://www.w3.org/2000/svg";
    const size = 200;
    const center = size / 2;
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", size);
    svg.setAttribute("height", size);
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);

    const labels = Object.keys(stats);
    const values = Object.values(stats);
    const numAxes = labels.length;
    const angleSlice = (Math.PI * 2) / numAxes;

    function createSvgElement(tag, attrs) {
        const element = document.createElementNS(svgNS, tag);
        for (const [key, value] of Object.entries(attrs)) {
            element.setAttribute(key, value);
        }
        return element;
    }

    // Draw grid lines
    for (let i = 1; i <= 4; i++) {
        const radius = (center * 0.9) * (i / 4);
        let points = "";
        for (let j = 0; j < numAxes; j++) {
            const angle = angleSlice * j - Math.PI / 2;
            const x = center + radius * Math.cos(angle);
            const y = center + radius * Math.sin(angle);
            points += `${x},${y} `;
        }
        points += points.split(' ').slice(0, 2).join(' '); // close the polygon
        svg.append(createSvgElement("polygon", { points, fill: "none", stroke: "var(--border)", "stroke-width": "1" }));
    }

    // Draw axes and labels
    for (let i = 0; i < numAxes; i++) {
        const angle = angleSlice * i - Math.PI / 2;
        const radius = center * 0.95;
        const x1 = center;
        const y1 = center;
        const x2 = center + radius * Math.cos(angle);
        const y2 = center + radius * Math.sin(angle);
        svg.append(createSvgElement("line", { x1, y1, x2, y2, stroke: "var(--border)", "stroke-width": "1" }));

        // Labels
        const labelX = center + (center * 1.08) * Math.cos(angle);
        const labelY = center + (center * 1.08) * Math.sin(angle);
        const labelEl = createSvgElement("text", { x: labelX, y: labelY, "font-size": "10px", fill: "var(--text-secondary)", "text-anchor": "middle", "dominant-baseline": "middle" });
        labelEl.textContent = labels[i];
        svg.append(labelEl);
    }

    // Draw data polygon
    let dataPoints = "";
    for (let i = 0; i < numAxes; i++) {
        const value = Math.max(0, values[i] / 100); // Normalize to 0-1, ensure non-negative
        const radius = (center * 0.9) * value;
        const angle = angleSlice * i - Math.PI / 2;
        const x = center + radius * Math.cos(angle);
        const y = center + radius * Math.sin(angle);
        dataPoints += `${x},${y} `;
    }
    dataPoints += dataPoints.split(' ').slice(0, 2).join(' ');
    svg.append(createSvgElement("polygon", { points: dataPoints, fill: "rgba(255, 71, 126, 0.5)", stroke: "var(--accent)", "stroke-width": "2" }));

    return svg;
}


function showPlayerDetailModal(pid, tid) {
    const player = findPlayerById(tid, pid);
    if (!player) return;

    playSound('A#4', '16n');

    const modal = $('#playerDetailModal');
    $('#modalPlayerName').textContent = `${player.name} (${player.age}æ­³)`;
    const body = $('#modalBody');
    body.innerHTML = ''; // Clear previous content

    const statsContainer = el('div');
    const isPitcher = !!player.velo;

    // Basic Info
    statsContainer.append(el('p', { class: 'mini' }, `å®ˆ:${player.pos || player.role} / æŠ•:${player.hand}`));

    // Status
    let statusText = '';
    if (player.injury) statusText = `ðŸ©¹ æ€ªæˆ‘: ${player.injury.type} (ã‚ã¨${player.injury.duration}æ—¥)`;
    else if (player.status?.hot > 0) statusText = `ðŸ”¥ å¥½èª¿ (ã‚ã¨${player.status.hot}é€±)`;
    else if (player.status?.slump > 0) statusText = `â„ï¸ ä¸èª¿ (ã‚ã¨${player.status.slump}é€±)`;

    if(statusText){
        statsContainer.append(el('div', { class: 'pill', style: `margin-bottom:12px; background-color: ${player.injury ? 'var(--bad)' : 'var(--warn)'}; color: #fff; border-color: transparent;` }, statusText));
    }


    // Stats Table
    const statsTable = el('table', { style: 'margin-bottom: 16px;' });
    const tbody = el('tbody');

    if (isPitcher) {
        tbody.append(
            el('tr', {}, el('td', {}, 'é€Ÿçƒ'), statTd(player.velo)),
            el('tr', {}, el('td', {}, 'åˆ¶çƒ'), statTd(player.ctrl)),
            el('tr', {}, el('td', {}, 'å¤‰åŒ–'), statTd(player.mov)),
            el('tr', {}, el('td', {}, 'ä½“åŠ›'), statTd(player.stam))
        );
    } else {
        tbody.append(
            el('tr', {}, el('td', {}, 'ãƒŸãƒ¼ãƒˆ'), statTd(player.con)),
            el('tr', {}, el('td', {}, 'é¸çƒçœ¼'), statTd(player.disc)),
            el('tr', {}, el('td', {}, 'ãƒ‘ãƒ¯ãƒ¼'), statTd(player.pwr)),
            el('tr', {}, el('td', {}, 'èµ°åŠ›'), statTd(player.spd)),
            el('tr', {}, el('td', {}, 'å®ˆå‚™åŠ›'), statTd(player.fld))
        );
    }
    tbody.append(el('tr', {}, el('td', {}, 'ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«'), statTd(player.pot)));
    statsTable.append(tbody);
    statsContainer.append(statsTable);

    if (Number.isFinite(player.farmReveal)) {
        const revealPct = clamp(Math.round(player.farmReveal), 0, 100);
        const farmBlock = el('div', { class: 'training-progress-block', style: 'margin-bottom: 16px;' });
        farmBlock.append(
            el('div', { class: 'training-progress-header' },
                el('span', {}, 'äºŒè»è‚²æˆçŠ¶æ³'),
                el('span', {}, `${revealPct}%`)
            )
        );
        const bar = el('div', { class: 'training-progress-bar' });
        bar.append(el('span', { style: `width:${revealPct}%` }));
        farmBlock.append(bar);

        const last = player.farmLast || null;
        const meta = el('div', { class: 'training-progress-meta' });
        if (last?.label) meta.append(el('span', {}, last.label));
        if (last?.revealGain) meta.append(el('span', {}, `æ½œåœ¨+${last.revealGain}%`));
        if (last?.fatigueRecovered) meta.append(el('span', {}, `ç–²åŠ´-${last.fatigueRecovered}`));
        if (Array.isArray(last?.traitUnlocks) && last.traitUnlocks.length) meta.append(el('span', {}, `è¦šé†’:${last.traitUnlocks.join('ãƒ»')}`));
        if (meta.childNodes.length) farmBlock.append(meta);

        if (Array.isArray(player.farmLog) && player.farmLog.length) {
            const logList = el('ul', { class: 'farm-log' });
            player.farmLog.slice().reverse().forEach(entry => {
                const label = entry.label || 'äºŒè»';
                const detailParts = [];
                if (entry.revealGain) detailParts.push(`æ½œåœ¨+${entry.revealGain}% â†’ ${Math.round(entry.revealAfter || 0)}%`);
                else detailParts.push(`æ½œåœ¨${Math.round(entry.revealAfter || 0)}%`);
                if (entry.fatigueRecovered) detailParts.push(`ç–²åŠ´-${entry.fatigueRecovered}`);
                if (Array.isArray(entry.traitUnlocks) && entry.traitUnlocks.length) detailParts.push(`è¦šé†’:${entry.traitUnlocks.join('ãƒ»')}`);
                if (Array.isArray(entry.milestones) && entry.milestones.length) detailParts.push(`ç¯€ç›®:${entry.milestones.join('% / ')}%`);
                const item = el('li');
                item.append(el('span', { class: 'farm-log-time' }, label));
                item.append(el('span', {}, detailParts.join(' / ')));
                logList.append(item);
            });
            farmBlock.append(logList);
        }

        statsContainer.append(farmBlock);
    }

    // Traits
    const displayTraits = normalizePlayerSpecials(player);
    if (displayTraits.length > 0) {
        statsContainer.append(el('h4', { class: 'mini', style: 'font-weight:bold;' }, 'ç‰¹èƒ½'));
        const traitsDiv = el('div', { style: 'display:flex; flex-wrap:wrap; gap:6px; margin-bottom: 16px;' });
        displayTraits.forEach(token => {
            const traitId = findSpecialId(token) || token;
            const special = getSpecialById(traitId);
            const label = special?.name || token;
            const attrs = { class: 'tag' };
            if (special?.desc) attrs.title = special.desc;
            traitsDiv.append(el('span', attrs, label));
        });
        statsContainer.append(traitsDiv);
    }

    // Morale & Fatigue
    statsContainer.append(moraleBar(player.morale || 60));
    statsContainer.append(fatigueBar(player.fatigue || 20));

    // Radar Chart
    const chartContainer = el('div');
    let chartStats = {};
    if (isPitcher) {
        chartStats = { "é€Ÿçƒ": player.velo, "åˆ¶çƒ": player.ctrl, "å¤‰åŒ–": player.mov, "ä½“åŠ›": player.stam, "ãƒ": player.pot };
    } else {
        chartStats = { "ãƒŸãƒ¼ãƒˆ": player.con, "ãƒ‘ãƒ¯ãƒ¼": player.pwr, "èµ°åŠ›": player.spd, "å®ˆå‚™": player.fld, "é¸çƒ": player.disc };
    }
    chartContainer.append(el('h4', { class: 'mini', style: 'text-align:center; font-weight:bold;' }, 'èƒ½åŠ›ãƒãƒ£ãƒ¼ãƒˆ'));
    chartContainer.append(createRadarChartSVG(chartStats));


    body.append(statsContainer, chartContainer);

    modal.style.display = 'flex';
    if (activeFocusTrap) activeFocusTrap();
    activeFocusTrap = focusTrap(modal);
    refreshIcons();
}

function hidePlayerDetailModal() {
    if (activeFocusTrap) {
        activeFocusTrap();
        activeFocusTrap = null;
    }
    $('#playerDetailModal').style.display = 'none';
    playSound('C3', '16n');
}

function createGameRecapSection(title, content, extraClass='') {
    const className = ['game-recap-section'];
    if (extraClass) className.push(extraClass);
    const section = el('div', { class: className.join(' ') });
    section.append(el('h4', {}, title));
    const body = el('div', { class: 'section-body' });
    if (Array.isArray(content)) content.forEach(node => body.append(node));
    else if (content) body.append(content);
    else body.append(el('div', { class: 'mini' }, 'è¨˜éŒ²ãªã—'));
    section.append(body);
    return section;
}

function buildBattingTable(teamRecap) {
    const rows = teamRecap?.batting || [];
    if (!rows.length) return el('div', { class: 'mini' }, 'è¨˜éŒ²ãªã—');
    const table = el('table', { class: 'game-recap-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, 'é †'),
            el('th', {}, 'é¸æ‰‹'),
            el('th', {}, 'Pos'),
            el('th', {}, 'AB'),
            el('th', {}, 'H'),
            el('th', {}, 'HR'),
            el('th', {}, 'RBI'),
            el('th', {}, 'BB'),
            el('th', {}, 'SO')
        )),
        el('tbody')
    );
    rows.forEach(b => {
        table.lastChild.append(el('tr', {},
            el('td', {}, b.order ?? '-'),
            el('td', { style: 'text-align:left;' }, b.name || '-'),
            el('td', {}, b.pos || '-'),
            el('td', {}, b.AB ?? 0),
            el('td', {}, b.H ?? 0),
            el('td', {}, b.HR ?? 0),
            el('td', {}, b.RBI ?? 0),
            el('td', {}, b.BB ?? 0),
            el('td', {}, b.SO ?? 0)
        ));
    });
    return table;
}

function buildPitchingTable(teamRecap) {
    const rows = [];
    if (teamRecap?.pitching?.starter) {
        const s = teamRecap.pitching.starter;
        rows.push({
            name: s.name,
            role: 'å…ˆç™º',
            IP: s.IP,
            ER: s.ER,
            SO: s.SO,
            BB: s.BB,
            W: s.W,
            L: s.L,
            SV: 0
        });
    }
    (teamRecap?.pitching?.relievers || []).forEach(rp => {
        rows.push({
            name: rp.name,
            role: rp.SV ? 'æŠ‘ãˆ' : 'æ•‘æ´',
            IP: rp.IP,
            ER: rp.ER,
            SO: rp.SO,
            BB: rp.BB,
            W: rp.W || 0,
            L: rp.L || 0,
            SV: rp.SV || 0
        });
    });
    if (!rows.length) return el('div', { class: 'mini' }, 'è¨˜éŒ²ãªã—');
    const table = el('table', { class: 'game-recap-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, 'æŠ•æ‰‹'),
            el('th', {}, 'å½¹å‰²'),
            el('th', {}, 'IP'),
            el('th', {}, 'ER'),
            el('th', {}, 'SO'),
            el('th', {}, 'BB'),
            el('th', {}, 'W'),
            el('th', {}, 'L'),
            el('th', {}, 'SV')
        )),
        el('tbody')
    );
    rows.forEach(p => {
        table.lastChild.append(el('tr', {},
            el('td', { style: 'text-align:left;' }, p.name || '-'),
            el('td', {}, p.role || '-'),
            el('td', {}, formatInnings(p.IP)),
            el('td', {}, p.ER ?? 0),
            el('td', {}, p.SO ?? 0),
            el('td', {}, p.BB ?? 0),
            el('td', {}, p.W ?? 0),
            el('td', {}, p.L ?? 0),
            el('td', {}, p.SV ?? 0)
        ));
    });
    return table;
}

function resolveGameRecap(ref){
    if(!ref) return { key:null, recap:null };
    let key=null;
    if(typeof ref === 'string') key = ref;
    else if(ref.gameKey) key = ref.gameKey;
    else if(ref.day!=null && ref.home_id!=null && ref.away_id!=null) key = gameRecapKey(ref.day, ref.home_id, ref.away_id);
    if(!key) return { key:null, recap:null };
    return { key, recap: State.gameRecaps?.[key] };
}

function showGameRecapModal(ref) {
    const modal = $('#gameRecapModal');
    const body = $('#gameRecapBody');
    const title = $('#gameRecapTitle');
    if (!modal || !body || !title) return;
    const { key, recap } = resolveGameRecap(ref);
    if (!recap) {
        alert('è©¦åˆè©³ç´°ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
        return;
    }

    const halfLabel = half => half === 'top' ? 'è¡¨' : half === 'bottom' ? 'è£' : '';
    const buildTimelineBlock = (timeline, label) => {
        const block = el('div', { class: 'timeline-entry' });
        block.append(el('strong', {}, label));
        if (!Array.isArray(timeline) || !timeline.length) {
            block.append(el('span', { class: 'mini' }, 'ç™»æ¿ãªã—'));
            return block;
        }
        timeline.forEach(item => {
            const enterHalf = halfLabel(item?.entered?.half || 'top');
            const exitHalf = halfLabel(item?.exit?.half || 'end');
            const exitInning = item?.exit?.inning != null ? item.exit.inning : item?.entered?.inning;
            const outText = item?.outs != null ? `${(item.outs / 3).toFixed(1)}å›ž` : '';
            const line = `${item.name} (${item.role || 'RP'}) - ${item?.entered?.inning || 1}å›ž${enterHalf}ã€œ${exitInning}${exitHalf} ${outText} ${item?.runs || 0}å¤±ç‚¹`;
            block.append(el('span', {}, line));
        });
        return block;
    };

    title.textContent = `${id2name(recap.away_id)} @ ${id2name(recap.home_id)}`;
    body.innerHTML = '';

    const header = el('div', { class: 'game-recap-header' },
        el('div', { class: 'scoreline' }, `${id2name(recap.away_id)} ${recap.score?.away ?? 0} - ${id2name(recap.home_id)} ${recap.score?.home ?? 0}`),
        el('div', { class: 'game-recap-meta' },
            el('span', {}, `${recap.season}å¹´ç›®`),
            el('span', {}, `Day ${recap.day}`),
            el('span', {}, `${recap.innings || 9} Innings`)
        )
    );
    body.append(header);

    if (recap.decidingPlay) {
        body.append(el('div', { class: 'game-recap-keyplay' }, `æ±ºå‹ç‚¹: ${recap.decidingPlay}`));
    }

    if (recap.highlights && recap.highlights.length) {
        const list = el('ul');
        recap.highlights.forEach(h => list.append(el('li', {}, h)));
        const section = createGameRecapSection('è©¦åˆãƒã‚¤ãƒ©ã‚¤ãƒˆ', list, 'game-recap-highlights');
        body.append(section);
    }

    if (Array.isArray(recap.keyMoments) && recap.keyMoments.length) {
        const kmList = el('div', { class: 'key-moment-list' });
        recap.keyMoments.forEach(m => {
            const scoreText = m.score ? ` (${m.score.away}-${m.score.home})` : '';
            kmList.append(el('div', { class: 'key-moment-item' }, `${m.inning}å›ž${halfLabel(m.half)} ${m.description}${scoreText}`));
        });
        body.append(createGameRecapSection('ã‚­ãƒ¼ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ', kmList));
    }

    if (recap.pitcherTimeline) {
        const timelineWrap = el('div', { class: 'game-recap-timeline' });
        timelineWrap.append(buildTimelineBlock(recap.pitcherTimeline.away, `${id2name(recap.away_id)} ç¶™æŠ•`));
        timelineWrap.append(buildTimelineBlock(recap.pitcherTimeline.home, `${id2name(recap.home_id)} ç¶™æŠ•`));
        body.append(createGameRecapSection('ç¶™æŠ•ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³', timelineWrap));
    }

    if (Array.isArray(recap.playLog) && recap.playLog.length) {
        const highlightEvents = recap.playLog.filter(evt => (evt.runsScored || 0) > 0 || (evt.commentary && evt.commentary.length)).slice(-12);
        if (highlightEvents.length) {
            const playList = el('div', { class: 'play-log-list' });
            highlightEvents.forEach(evt => {
                const desc = evt.description || `${evt.batter?.name || ''} ${evt.result || ''}`;
                const scoreText = evt.scoreAfter ? ` (${evt.scoreAfter.away}-${evt.scoreAfter.home})` : '';
                const commentary = evt.commentary ? ` ï½œ ${evt.commentary}` : '';
                playList.append(el('div', { class: 'play-log-item' }, `${evt.inning}å›ž${halfLabel(evt.half)} ${desc}${scoreText}${commentary}`));
            });
            body.append(createGameRecapSection('å¾—ç‚¹ãƒ—ãƒ¬ãƒ¼', playList));
        }
    }

    const grid = el('div', { class: 'game-recap-grid' });
    grid.append(
        createGameRecapSection(`${id2name(recap.away_id)} æ‰“æ’ƒ`, buildBattingTable(recap.teams?.away)),
        createGameRecapSection(`${id2name(recap.home_id)} æ‰“æ’ƒ`, buildBattingTable(recap.teams?.home)),
        createGameRecapSection(`${id2name(recap.away_id)} æŠ•æ‰‹`, buildPitchingTable(recap.teams?.away)),
        createGameRecapSection(`${id2name(recap.home_id)} æŠ•æ‰‹`, buildPitchingTable(recap.teams?.home))
    );
    body.append(grid);

    modal.style.display = 'flex';
    if (activeFocusTrap) activeFocusTrap();
    activeFocusTrap = focusTrap(modal);
    modal.dataset.gameKey = key;
    refreshIcons();
}

function showFinanceModal(config = {}) {
    const modal = $('#financeModal');
    const body = $('#financeModalBody');
    const title = $('#financeModalTitle');
    if (!modal || !body || !title) return;
    title.textContent = config.title || 'ãƒ•ãƒ­ãƒ³ãƒˆã‚ªãƒ•ã‚£ã‚¹æ“ä½œ';
    body.innerHTML = '';
    const content = typeof config.render === 'function' ? config.render(body) : config.content;
    if (content) body.append(content);
    modal.style.display = 'flex';
    if (activeFocusTrap) activeFocusTrap();
    activeFocusTrap = focusTrap(modal);
    refreshIcons();
}

function hideFinanceModal() {
    if (activeFocusTrap) {
        activeFocusTrap();
        activeFocusTrap = null;
    }
    const modal = $('#financeModal');
    if (modal) modal.style.display = 'none';
}

function buildFreeAgentRow(tid, player) {
    const overall = Math.round(getOverall(player));
    const expectation = valuePlayerContract(player, { overall: getOverall(player) });
    const row = el('tr');
    row.append(
        el('td', {}, player.name),
        el('td', {}, player.pos || player.role || '-'),
        el('td', {}, overall),
        el('td', {}, `${millionFormatter(expectation.AAV)}${expectation.incentives?.total ? ` (+${millionFormatter(expectation.incentives.total)})` : ''}`),
        (() => {
            const cell = el('td');
            const btn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'user-plus' }), 'å¥‘ç´„');
            btn.onclick = () => {
                const res = negotiateContract(tid, player.id, { AAV: expectation.AAV, incentives: expectation.incentives, years: expectation.years });
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    btn.textContent = 'æ¡ä»¶è¦‹ç›´ã—';
                }
            };
            cell.append(btn);
            return cell;
        })()
    );
    return row;
}

function openFreeAgentModal(tid) {
    ensureFreeAgents();
    const candidates = State.freeAgents.slice().sort((a, b) => getOverall(b) - getOverall(a)).slice(0, 25);
    showFinanceModal({
        title: 'FAå¸‚å ´',
        render: () => {
            const container = el('div', { class: 'finance-section' });
            if (!candidates.length) {
                container.append(el('div', { class: 'mini' }, 'ç¾åœ¨ç²å¾—å¯èƒ½ãªFAé¸æ‰‹ã¯ã„ã¾ã›ã‚“ã€‚'));
                return container;
            }
            const table = el('table', { class: 'contract-table' },
                el('thead', {}, el('tr', {},
                    el('th', {}, 'é¸æ‰‹'),
                    el('th', {}, 'å®ˆå‚™/å½¹å‰²'),
                    el('th', {}, 'ç·åˆ'),
                    el('th', {}, 'æƒ³å®šAAV'),
                    el('th', {}, 'æ“ä½œ')
                )),
                el('tbody')
            );
            candidates.forEach(player => table.lastChild.append(buildFreeAgentRow(tid, player)));
            container.append(el('div', { class: 'table-scroll', style: 'max-height:320px;' }, table));
            return container;
        }
    });
}

function openContractModal(tid, contract) {
    const player = findPlayerById(tid, contract.playerId) || State.freeAgents.find(p => p.id === contract.playerId);
    const expectation = player
        ? valuePlayerContract(player, { overall: getOverall(player) })
        : { AAV: contract.AAV || 12000000, years: contract.yearsRemaining || 1, incentives: contract.incentives || { total: 0 } };
    showFinanceModal({
        title: `${contract.name} å¥‘ç´„äº¤æ¸‰`,
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const currentIncentives = contract.incentives?.total ? ` +${millionFormatter(contract.incentives.total)}` : '';
            container.append(el('div', { class: 'finance-stat' }, el('span', {}, 'ç¾è¡Œæ¡ä»¶'), el('strong', {}, `${millionFormatter(contract.AAV || 0)}${currentIncentives} / ${contract.yearsRemaining ?? 1}å¹´`)));
            const aavInput = el('input', { type: 'number', min: '5000000', step: '1000000', value: contract.AAV || expectation.AAV || 10000000 });
            const yearInput = el('input', { type: 'number', min: '1', max: '6', value: Math.max(1, contract.yearsRemaining ?? 1) });
            const feedback = el('div', { class: 'mini' });
            const controls = el('div', { class: 'finance-actions' },
                el('label', { class: 'finance-stat' }, el('span', {}, 'æç¤ºAAV'), aavInput),
                el('label', { class: 'finance-stat' }, el('span', {}, 'å¥‘ç´„å¹´æ•°'), yearInput)
            );
            const submit = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'wallet' }), 'æç¤ºã‚’è¡Œã†');
            submit.onclick = () => {
                const offer = {
                    AAV: parseInt(aavInput.value, 10) || expectation.AAV,
                    years: parseInt(yearInput.value, 10) || expectation.years,
                    incentives: expectation.incentives
                };
                const res = negotiateContract(tid, contract.playerId, offer);
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    const expect = res.expectation || {};
                    feedback.textContent = `æç¤ºãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ç›®å®‰: Â¥${yenFormatter.format(expect.AAV || expectation.AAV)} / ${expect.years || offer.years}å¹´`;
                }
            };
            container.append(controls, submit, feedback);
            return container;
        }
    });
}

function tradeCandidates(teamId) {
    const roster = State.rosters[teamId];
    if (!roster) return [];
    const players = [...roster.bats, ...roster.pits];
    return players.sort((a, b) => getOverall(b) - getOverall(a)).slice(0, 20);
}

function populateTradeSelect(select, teamId) {
    select.innerHTML = '';
    tradeCandidates(teamId).forEach(player => {
        const label = `${player.name} (${player.pos || player.role || '-'} / ${Math.round(getOverall(player))})`;
        select.append(el('option', { value: player.id }, label));
    });
}

function openTradeModal(tid) {
    const otherTeams = State.teams.filter(t => t.team_id !== tid);
    if (!otherTeams.length) return;
    showFinanceModal({
        title: 'ãƒˆãƒ¬ãƒ¼ãƒ‰ææ¡ˆ',
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const partnerSelect = el('select');
            otherTeams.forEach(team => partnerSelect.append(el('option', { value: team.team_id }, team.team)));
            const userSelect = el('select', { multiple: true, size: 8, style: 'width:100%;' });
            const partnerPlayerSelect = el('select', { multiple: true, size: 8, style: 'width:100%;' });
            populateTradeSelect(userSelect, tid);
            populateTradeSelect(partnerPlayerSelect, parseInt(partnerSelect.value, 10));
            partnerSelect.onchange = () => populateTradeSelect(partnerPlayerSelect, parseInt(partnerSelect.value, 10));
            const cashInput = el('input', { type: 'number', min: '0', step: '10', value: '0', style: 'width:100%;' });
            const feedback = el('div', { class: 'mini' });
            const submit = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'handshake' }), 'äº¤æ¸‰ã™ã‚‹');
            submit.onclick = () => {
                const partnerTid = parseInt(partnerSelect.value, 10);
                const outgoing = Array.from(userSelect.selectedOptions).map(opt => opt.value);
                const incoming = Array.from(partnerPlayerSelect.selectedOptions).map(opt => opt.value);
                const cash = (parseInt(cashInput.value, 10) || 0) * 1000000;
                if (!outgoing.length && !incoming.length && cash === 0) {
                    feedback.textContent = 'é¸æ‰‹ã¾ãŸã¯é‡‘éŠ­ã‚’é¸æŠžã—ã¦ãã ã•ã„ã€‚';
                    return;
                }
                const res = proposeTrade(tid, partnerTid, outgoing, incoming, { cash });
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    feedback.textContent = `ãƒˆãƒ¬ãƒ¼ãƒ‰å¤±æ•—: ${res.reason || 'æ¡ä»¶ãŒåˆã„ã¾ã›ã‚“'}`;
                }
            };
            container.append(
                el('label', { class: 'finance-stat' }, el('span', {}, 'ç›¸æ‰‹ãƒãƒ¼ãƒ '), partnerSelect),
                el('div', { class: 'finance-stat' }, el('span', {}, 'æ”¾å‡ºå€™è£œ'), userSelect),
                el('div', { class: 'finance-stat' }, el('span', {}, 'ç²å¾—å€™è£œ'), partnerPlayerSelect),
                el('label', { class: 'finance-stat' }, el('span', {}, 'é‡‘éŠ­ (ç™¾ä¸‡å††å˜ä½)'), cashInput),
                submit,
                feedback
            );
            return container;
        }
    });
}

function openLedgerModal(tid) {
    const finance = State.teamFinances[tid];
    showFinanceModal({
        title: `${id2name(tid)} è²¡å‹™ãƒ¬ãƒãƒ¼ãƒˆ`,
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const ledger = finance?.ledger ? finance.ledger.slice(-40).reverse() : [];
            if (!ledger.length) {
                container.append(el('div', { class: 'mini' }, 'ã¾ã è²¡å‹™å–å¼•å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚'));
                return container;
            }
            const list = el('ul', { style: 'list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px;' });
            ledger.forEach(entry => {
                const amount = entry.amount || 0;
                const label = entry.label || (entry.type === 'expense' ? 'æ”¯å‡º' : 'åŽå…¥');
                list.append(el('li', { class: 'finance-stat' }, el('span', {}, `Day ${entry.day}: ${label}`), el('strong', {}, millionFormatter(amount))));
            });
            container.append(list);
            return container;
        }
    });
}

function hideGameRecapModal() {
    if (activeFocusTrap) {
        activeFocusTrap();
        activeFocusTrap = null;
    }
    const modal = $('#gameRecapModal');
    if (modal) {
        modal.style.display = 'none';
        delete modal.dataset.gameKey;
    }
}

function showRosterViolationModal(compliance){
  const modal=$('#rosterViolationModal');
  const body=$('#rosterViolationBody');
  const title=$('#rosterViolationModalTitle');
  if(!modal || !body || !title){
    alert('å¤–å›½äººæž è¶…éŽã®ãŸã‚é€²è¡Œã§ãã¾ã›ã‚“ã€‚');
    return;
  }
  const teamName=id2name(compliance?.teamId ?? (State.userTeamId ?? 0));
  title.textContent=`${teamName} ç™»éŒ²åˆ¶é™ã‚¢ãƒ©ãƒ¼ãƒˆ`;
  body.innerHTML='';

  const header=el('div',{class:'banner-header'}, el('i',{'data-lucide':'shield-alert',class:'mini-icon'}), `${compliance?.label || 'å¤–å›½äººæž '}è¶…éŽ`);
  const summary=el('div',{class:'banner-body'},`ç¾åœ¨ ${compliance?.foreignCount ?? 0}/${compliance?.limit ?? 'â€”'} æž ï¼ˆä¸€è»ç™»éŒ² ${compliance?.activeCount ?? 0}åï¼‰`);
  const banner=el('div',{class:'roster-compliance-banner error'}, header, summary);

  if(Array.isArray(compliance?.foreignPlayers) && compliance.foreignPlayers.length){
    const list=el('ul');
    compliance.foreignPlayers.forEach(player=>{
      const role=player.type==='PIT'?'æŠ•æ‰‹':'é‡Žæ‰‹';
      list.append(el('li',{},`${player.name} (${role})`));
    });
    banner.append(list);
  }

  const fixBtn=el('button',{class:'btn mini',onclick:()=>{
    const tid=compliance?.teamId ?? (State.userTeamId ?? 0);
    autoFixRosterViolations(tid);
    saveAndRerender();
    hideRosterViolationModal?.();
  }},'è‡ªå‹•ã§ç›´ã™');

  body.append(banner, el('p',{class:'mini'},'å¯¾è±¡é¸æ‰‹ã‚’äºŒè»ã¸ç§»ã™ã‹ã€å¤–å›½äººé¸æ‰‹ã®æ§‹æˆã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚'), fixBtn);
  modal.style.display='flex';
  if (activeFocusTrap) activeFocusTrap();
  activeFocusTrap = focusTrap(modal);
  modal.dataset.teamId=String(compliance?.teamId ?? '');
  refreshIcons();
}

function hideRosterViolationModal(){
  if (activeFocusTrap) {
      activeFocusTrap();
      activeFocusTrap = null;
  }
  const modal=$('#rosterViolationModal');
  if(modal) modal.style.display='none';
}

function showScoutReportModal(prospect, tid){
  ensureProspectStructure(prospect);
  const modal=$('#scoutReportModal');
  const body=$('#scoutReportBody');
  const title=$('#scoutReportTitle');
  if(!modal||!body||!title) return;
  const report=ensureProspectTeamReport(prospect, tid);
  const progressPercent=Math.round(clamp(report.progress||0,0,1)*100);
  const growthMap={prodigy:'æ€ªç‰©',late:'æ™©æˆ',standard:'æ¨™æº–',early:'æ—©ç†Ÿ',bust:'ä¼¸ã³æ‚©ã¿'};
  title.textContent=`${prospect.name} ã‚¹ã‚«ã‚¦ãƒˆãƒ¬ãƒãƒ¼ãƒˆ`;
  body.innerHTML='';

  const overviewSection=el('div',{class:'scout-report-section'});
  overviewSection.append(el('h4',{},'åŸºæœ¬æƒ…å ±'));
  const overviewBody=el('div',{class:'scout-report-body'});
  const infoLine=el('div',{class:'mini',style:'display:flex;flex-wrap:wrap;gap:8px;line-height:1.6;'});
  infoLine.append(
    el('span',{},`å¹´é½¢: ${prospect.age}`),
    el('span',{},`åˆ©ãæ‰‹: ${prospect.hand||'-'}`),
    el('span',{}, prospect.type==='BAT'?`å®ˆå‚™: ${prospect.pos}`:`å½¹å‰²: ${prospect.role}`),
    el('span',{},`æˆé•·: ${growthMap[prospect.growthCurve]||prospect.growthCurve}`)
  );
  const progressWrap=el('div',{style:'display:flex;flex-direction:column;gap:4px;'});
  progressWrap.append(el('div',{class:'scout-progress'}, el('span',{style:`width:${progressPercent}%`})));
  progressWrap.append(el('div',{class:'scout-progress-label',style:'text-align:left;'}, `é€²æ— ${progressPercent}%`));
  const attrTable=el('table',{}, el('tbody'));
  getProspectAttributeList(prospect).forEach(attr=>{
    const row=el('tr');
    row.append(el('td',{}, prospectAttributeLabel(prospect, attr)), scoutedStatTd(prospect, attr, tid));
    attrTable.lastChild.append(row);
  });
  overviewBody.append(infoLine, progressWrap, attrTable);
  overviewSection.append(overviewBody);
  body.append(overviewSection);

  const events=prospect.scouting.events || {};
  if(events.combine){
    const combineSection=el('div',{class:'scout-report-section'});
    combineSection.append(el('h4',{},'ã‚³ãƒ³ãƒã‚¤ãƒ³ / æ¸¬å®šçµæžœ'));
    const combineBody=el('div',{class:'scout-report-body'});
    if(events.combine.summary) combineBody.append(el('div',{class:'scout-note'}, events.combine.summary));
    if(Array.isArray(events.combine.metrics) && events.combine.metrics.length){
      const metricList=el('div',{class:'scout-metric-list'});
      events.combine.metrics.forEach(metric=>{
        metricList.append(el('div',{class:'scout-metric'}, el('strong',{}, metric.label||'-'), el('span',{}, `${metric.value||'-'} / è©•ä¾¡ ${metric.grade||'-'}`)));
      });
      combineBody.append(metricList);
    }
    combineSection.append(combineBody);
    body.append(combineSection);
  }

  if(Array.isArray(events.tournaments) && events.tournaments.length){
    const tourSection=el('div',{class:'scout-report-section'});
    tourSection.append(el('h4',{},'å¤§ä¼šãƒã‚¤ãƒ©ã‚¤ãƒˆ'));
    const tourBody=el('div',{class:'scout-report-body'});
    events.tournaments.forEach(tourney=>{
      tourBody.append(el('div',{class:'scout-tournament-item'},
        el('strong',{}, `${tourney.stage||'å¤§ä¼š'} / ${tourney.team||'-'}`),
        el('span',{class:'mini'}, tourney.stat||'-'),
        el('span',{class:'scout-note'}, tourney.highlight||'å°è±¡çš„ãªãƒ—ãƒ¬ãƒ¼')));
    });
    tourSection.append(tourBody);
    body.append(tourSection);
  }

  if(events.notes){
    const notesSection=el('div',{class:'scout-report-section'});
    notesSection.append(el('h4',{},'ã‚¹ã‚«ã‚¦ãƒˆãƒ¡ãƒ¢'));
    const notesBody=el('div',{class:'scout-report-body'}, el('div',{class:'scout-note'}, events.notes));
    notesSection.append(notesBody);
    body.append(notesSection);
  }

  modal.style.display='flex';
  if (activeFocusTrap) activeFocusTrap();
  activeFocusTrap = focusTrap(modal);
  refreshIcons();
}

function hideScoutReportModal(){
  if (activeFocusTrap) {
      activeFocusTrap();
      activeFocusTrap = null;
  }
  const modal=$('#scoutReportModal');
  if(modal) modal.style.display='none';
}

function showNarrativeLogModal(tid = State.userTeamId ?? 0){
  ensureNarrativeState();
  const modal = $('#narrativeLogModal');
  const body = $('#narrativeLogBody');
  const title = $('#narrativeLogTitle');
  if(!modal || !body || !title) return;
  const teamName = id2name(tid);
  title.textContent = `${teamName} ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°`;
  body.innerHTML = '';
  const log = (State.teamNarratives?.[tid]?.events || []).slice().reverse();
  if(!log.length){
    body.append(el('div',{class:'narrative-log-empty'},'è¨˜éŒ²ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚'));
  } else {
    log.forEach(evt => {
      const entry = el('div',{class:'narrative-modal-entry'});
      entry.append(el('span',{class:'narrative-tag'}, evt.tag || 'NARRATIVE'));
      entry.append(el('h4',{}, el('i',{ 'data-lucide': evt.icon || 'sparkles', class:'mini-icon' }), evt.title || evt.summary || 'ã‚¤ãƒ™ãƒ³ãƒˆ'));
      if(evt.summary) entry.append(el('p',{}, evt.summary));
      if(evt.detail) entry.append(el('p',{}, evt.detail));
      const metaBits=[`${evt.season}å¹´ç›® Day ${evt.day}`];
      if(evt.metadata?.opponentId != null) metaBits.push(`vs ${id2name(evt.metadata.opponentId)}`);
      entry.append(el('div',{class:'meta-line'}, metaBits.join(' ï½œ ')));
      if(Array.isArray(evt.players) && evt.players.length){
        entry.append(el('p',{class:'mini'}, `å¯¾è±¡: ${evt.players.join(', ')}`));
      }
      if(evt.effects){
        const effectBits=[];
        if(evt.effects.morale) effectBits.push(`å£«æ°— ${evt.effects.morale>0?'+':''}${evt.effects.morale}`);
        if(evt.effects.fatigue) effectBits.push(`ç–²åŠ´ ${evt.effects.fatigue>0?'+':''}${evt.effects.fatigue}`);
        if(Array.isArray(evt.effects.ability) && evt.effects.ability.length){
          effectBits.push('èƒ½åŠ›å¤‰åŒ–');
        }
        if(effectBits.length) entry.append(el('p',{class:'mini'}, effectBits.join(' ï¼ ')));
      }
      body.append(entry);
    });
  }
  modal.dataset.tid = String(tid);
  modal.style.display='flex';
  if (activeFocusTrap) activeFocusTrap();
  activeFocusTrap = focusTrap(modal);
  refreshIcons();
}

function hideNarrativeLogModal(){
  if (activeFocusTrap) {
      activeFocusTrap();
      activeFocusTrap = null;
  }
  const modal=$('#narrativeLogModal');
  if(modal) modal.style.display='none';
}


function renderStandings(target){ const host=resolveTarget(target,'#standings'); if(!host) return; const st=computeStandings(State.teams, State.results||[], State.league.rules); const leagues=["Central","Pacific"]; const container=document.createDocumentFragment();
  const showTies = State.league.rules.game.allowTie;
  leagues.forEach(lg=>{ const sub=st.filter(r=>r.league===lg); const title=el("div",{class:"mini",style:"padding:8px 12px;font-weight:bold;text-transform:uppercase;background: var(--card-header-bg); border-bottom: 2px solid var(--card-border);",html:`<b>${lg}</b>`});
    const headerItems = ["ãƒãƒ¼ãƒ ","W","L"];
    if (showTies) headerItems.push("T");
    headerItems.push("Pct", "GB");
    const tbl=el("table",{}, el("thead",{}, el("tr",{}, ...headerItems.map(h=>el('th',{},h)))), el("tbody"));
    for(const r of sub){
      const row = el("tr",{}, el("td",{},r.team), el("td",{},r.W), el("td",{},r.L));
      if (showTies) row.append(el("td",{}, r.T));
      row.append(el("td",{},r.Pct.toFixed(3)), el("td",{},(r.GB??0).toFixed(1)));
      tbl.lastChild.append(row);
    }
    container.append(title,tbl); });
  host.innerHTML=""; host.append(container);
}

function computeSeasonSummary(tid){
  if(!State || !Array.isArray(State.teams)) return null;
  const team = State.teams.find(t=>t.team_id===tid) || State.teams[0];
  if(!team) return null;
  tid = team.team_id;
  ensureTeamFinances();

  const record = teamRecord(tid);
  const results = (State.results||[]).filter(res=>res.home_id===tid || res.away_id===tid);
  const orderedResults = results.slice().sort((a,b)=> (a.day||0) - (b.day||0));
  const lastTen = orderedResults.slice(-10);
  const lastTenWins = lastTen.filter(r=>r.winner_id===tid).length;
  const winPct = record.total ? record.wins / record.total : 0;

  let streakCount = 0;
  let streakType = null;
  for(let i=orderedResults.length-1; i>=0; i--){
    const isWin = orderedResults[i].winner_id === tid;
    if(streakType===null){ streakType = isWin ? 'win' : 'loss'; streakCount = 1; }
    else if((isWin && streakType==='win') || (!isWin && streakType==='loss')){ streakCount++; }
    else break;
  }
  const streakText = streakType ? `${streakCount}${streakType==='win'?'é€£å‹':'é€£æ•—'}` : 'â€”';
  const streakMood = streakType ? (streakType==='win' ? 'å‹¢ã„ä¸Šæ˜‡ä¸­' : 'å·»ãè¿”ã—ãŒèª²é¡Œ') : 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³';
  const lastGame = orderedResults[orderedResults.length-1] || null;
  let lastGameText = 'è©¦åˆãªã—';
  if(lastGame){
    const opponentId = lastGame.home_id===tid ? lastGame.away_id : lastGame.home_id;
    const opponentName = id2name(opponentId);
    const marker = lastGame.winner_id===tid ? 'â—¯' : 'â—';
    const score = `${lastGame.away_runs}-${lastGame.home_runs}`;
    lastGameText = `Day ${lastGame.day} vs ${opponentName} ${marker} ${score}`;
  }

  const finance = State.teamFinances?.[tid];
  const reserves = finance?.budget?.reserves ?? 0;
  const netFlow = Math.round((finance?.revenue?.total||0) - (finance?.expenses?.total||0));
  const ledger = finance?.ledger || [];
  let lastLedgerText = 'å–å¼•å±¥æ­´ãªã—';
  if(ledger.length){
    const entry = ledger[ledger.length-1];
    const amount = entry?.amount || 0;
    const direction = entry?.type === 'income' ? 1 : entry?.type === 'expense' ? -1 : (amount>=0?1:-1);
    const label = entry?.label || (direction>=0 ? 'åŽå…¥' : 'æ”¯å‡º');
    const dayLabel = entry?.day != null ? `Day ${entry.day}` : 'Day ?';
    const displayAmount = millionFormatter(Math.abs(amount));
    lastLedgerText = `${dayLabel} ${label} ${direction>=0?'+':'-'}${displayAmount}`;
  }

  const narrative = State.teamNarratives?.[tid] || {};
  const moralePoints = (narrative.morale||[]).filter(p=>p.season===State.season);
  let moraleCurrent = Math.round(computeTeamAverageMorale(tid));
  let moraleDelta = 0;
  let moraleMeta = 'å£«æ°—ãƒ­ã‚°æœªè¨˜éŒ²';
  if(moralePoints.length){
    const lastPoint = moralePoints[moralePoints.length-1];
    moraleCurrent = lastPoint.value;
    const prevPoint = moralePoints.slice(0,-1).reverse().find(p=>p.season===lastPoint.season);
    if(prevPoint) moraleDelta = lastPoint.value - prevPoint.value;
    moraleMeta = `Day ${lastPoint.day} æ›´æ–°`;
  } else if(record.total){
    moraleMeta = 'è©¦åˆå¾Œã«è‡ªå‹•æ›´æ–°ã•ã‚Œã¾ã™';
  }

  const recentResults = orderedResults.slice(-12);
  const sparklineData = recentResults.map(res=>res.winner_id===tid ? 1 : -1);
  const recentWins = recentResults.filter(res=>res.winner_id===tid).length;
  const recentRecord = recentResults.length ? `${recentWins}-${recentResults.length-recentWins}` : '';

  const timelineEvents = [];
  if(moralePoints.length){
    const lastPoint = moralePoints[moralePoints.length-1];
    const prevPoint = moralePoints.slice(0,-1).reverse().find(p=>p.season===lastPoint.season);
    const delta = prevPoint ? lastPoint.value - prevPoint.value : 0;
    timelineEvents.push({
      icon:'smile',
      title:`å£«æ°— ${lastPoint.value}`,
      detail: delta ? `å‰å›žæ¯” ${delta>0?'+':''}${delta}` : 'å‰å›žæ¯” Â±0',
      meta:`Day ${lastPoint.day}`
    });
  }

  (narrative.events||[]).slice(-4).reverse().forEach(evt=>{
    const title = evt.tag ? `[${evt.tag}] ${evt.summary || evt.title || 'ã‚¤ãƒ™ãƒ³ãƒˆ'}` : (evt.summary || evt.title || 'ã‚¤ãƒ™ãƒ³ãƒˆ');
    timelineEvents.push({
      icon: evt.icon || 'sparkles',
      title,
      detail: evt.detail || evt.summary || '',
      meta: evt.day != null ? `${evt.season}å¹´ç›® Day ${evt.day}` : ''
    });
  });

  const teamName = id2name(tid);
  const devEntries = (State.devLogs||[])
    .filter(log=>log && typeof log === 'string' && log.includes(teamName))
    .slice(-3)
    .reverse();
  devEntries.forEach(log=>{
    timelineEvents.push({
      icon:'flame',
      title:'è‚²æˆãƒ­ã‚°',
      detail: log,
      meta:'æœ€è¿‘'
    });
  });

  if(timelineEvents.length>6) timelineEvents.length = 6;

  return {
    tid,
    teamName: team.team,
    record:{
      wins: record.wins,
      losses: record.losses,
      total: record.total,
      winPct,
      lastTen: record.total ? `${lastTenWins}-${lastTen.length-lastTenWins}` : '0-0'
    },
    streak:{
      text: streakText,
      kind: streakType,
      status: streakMood,
      lastGame: lastGameText
    },
    finances:{
      reserves,
      netFlow,
      lastLedgerText
    },
    morale:{
      current: Math.round(moraleCurrent),
      delta: Math.round(moraleDelta),
      meta: moraleMeta
    },
    timeline:{
      sparklineData,
      rangeLabel: recentResults.length ? `ç›´è¿‘${recentResults.length}è©¦åˆ` : '',
      recordSummary: recentResults.length ? `æˆç¸¾ ${recentRecord}` : '',
      events: timelineEvents
    }
  };
}

function renderSeasonTimeline(timeline){
  const card=el('div',{class:'season-timeline-card',id:'season-timeline'});
  const header=el('div',{class:'timeline-header'}, el('div',{class:'timeline-title'}, el('i',{ 'data-lucide':'calendar-range', class:'mini-icon' }), 'ã‚·ãƒ¼ã‚ºãƒ³ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³'));
  card.append(header);

  if(Array.isArray(timeline.sparklineData) && timeline.sparklineData.length>=2){
    const sparklineRow=el('div',{class:'timeline-sparkline'});
    sparklineRow.append(el('span',{class:'mini'}, timeline.rangeLabel || `ç›´è¿‘${timeline.sparklineData.length}è©¦åˆ`));
    sparklineRow.append(createSparklineSVG(timeline.sparklineData, 'var(--accent)', 220, 36));
    if(timeline.recordSummary){
      sparklineRow.append(el('span',{class:'mini'}, timeline.recordSummary));
    }
    card.append(sparklineRow);
  } else {
    card.append(el('div',{class:'timeline-empty'},'è©¦åˆãƒ‡ãƒ¼ã‚¿ãŒã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚'));
  }

  if(Array.isArray(timeline.events) && timeline.events.length){
    const eventsWrap=el('div',{class:'timeline-events'});
    timeline.events.forEach(evt=>{
      const eventCard=el('div',{class:'timeline-event'});
      eventCard.append(el('div',{class:'timeline-event-title'}, el('i',{ 'data-lucide':evt.icon||'sparkles', class:'mini-icon' }), evt.title||'ã‚¤ãƒ™ãƒ³ãƒˆ'));
      if(evt.detail) eventCard.append(el('div',{class:'timeline-event-detail'}, evt.detail));
      if(evt.meta) eventCard.append(el('div',{class:'timeline-event-meta'}, evt.meta));
      eventsWrap.append(eventCard);
    });
    card.append(eventsWrap);
  } else {
    card.append(el('div',{class:'timeline-empty'},'ã¾ã ãƒã‚¤ãƒ©ã‚¤ãƒˆãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'));
  }

  return card;
}

function renderDashboardOverview(){
  const container=$('#dashboard-overview');
  if(!container) return;
  ensureNarrativeState();
  const selManage=$('#selTeamManage');
  let tid = parseInt(selManage?.value||'',10);
  if(Number.isNaN(tid)) tid = State.userTeamId ?? 0;
  if(!State.teams.some(t=>t.team_id===tid) && State.teams.length){
    tid = State.teams[0].team_id;
  }

  const summary=computeSeasonSummary(tid);
  container.innerHTML='';
  if(!summary){
    container.append(el('div',{class:'timeline-empty'},'ãƒãƒ¼ãƒ æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'));
    return;
  }

  const formatSignedMillions=(val)=>{
    const sign=val>=0?'+':'-';
    return `${sign}${millionFormatter(Math.abs(val))}`;
  };

  const createCard=(icon,title,value,metaLines,valueClass='')=>{
    const classes=['summary-card-value'];
    if(valueClass) classes.push(valueClass);
    const card=el('div',{class:'summary-card'});
    card.append(el('div',{class:'summary-card-header'}, el('i',{ 'data-lucide':icon, class:'mini-icon' }), title));
    card.append(el('div',{class:classes.join(' ')}, value));
    if(Array.isArray(metaLines) && metaLines.length){
      const meta=el('div',{class:'summary-card-meta'});
      metaLines.filter(Boolean).forEach(line=>{
        if(line && typeof line === 'object' && 'nodeType' in line){
          meta.append(line);
        } else {
          meta.append(el('div',{}, line));
        }
      });
      card.append(meta);
    }
    return card;
  };

  const root=el('div',{class:'dashboard-overview'});
  root.append(el('div',{class:'dashboard-overview-header'}, `${summary.teamName} ãƒãƒ¼ãƒ çŠ¶æ³`));

  const cardsWrap=el('div',{class:'dashboard-overview-grid'});
  const pctText=summary.record.total ? summary.record.winPct.toFixed(3).slice(1) : '.---';
  cardsWrap.append(createCard('trophy','æˆ¦ç¸¾', `${summary.record.wins}-${summary.record.losses}`, [
    `å‹çŽ‡ ${pctText}`,
    `è©¦åˆæ•° ${summary.record.total}`
  ]));

  const streakClass=summary.streak.kind==='win'?'positive': summary.streak.kind==='loss'?'negative':'';
  cardsWrap.append(createCard('flame','é€£å‹ãƒ»é€£æ•—', summary.streak.text, [
    `ç›´è¿‘10æˆ¦ ${summary.record.lastTen}`,
    summary.streak.lastGame,
    summary.streak.status
  ], streakClass));

  const netFlowClass=summary.finances.netFlow>0?'positive': summary.finances.netFlow<0?'negative':'';
  const netFlowLine=el('div',{class:`summary-trend ${netFlowClass}`.trim()}, `åŽæ”¯ ${formatSignedMillions(summary.finances.netFlow||0)}`);
  cardsWrap.append(createCard('wallet','è²¡å‹™çŠ¶æ³', millionFormatter(summary.finances.reserves||0), [
    netFlowLine,
    summary.finances.lastLedgerText
  ]));

  const moraleTrendClass=summary.morale.delta>0?'positive': summary.morale.delta<0?'negative':'';
  const moraleDeltaLine=el('div',{class:`summary-trend ${moraleTrendClass}`.trim()}, `å‰å›žæ¯” ${summary.morale.delta>0?'+':''}${summary.morale.delta}`);
  cardsWrap.append(createCard('smile','ãƒãƒ¼ãƒ å£«æ°—', `${summary.morale.current}`, [
    moraleDeltaLine,
    summary.morale.meta
  ], moraleTrendClass));

  root.append(cardsWrap);
  root.append(renderSeasonTimeline(summary.timeline));
  container.append(root);
  refreshIcons();
}

const DASHBOARD_TAB_CONFIG={
  season:{ sections:[
    { selector:'#dashboard-standings', render:renderStandings },
    { selector:'#dashboard-playoffs', render:renderPlayoffs }
  ]},
  finance:{ sections:[
    { selector:'#dashboard-front-office', render:renderFrontOffice }
  ]},
  development:{ sections:[
    { selector:'#dashboard-recent', render:renderRecent },
    { selector:'#dashboard-highlights', render:renderHighlights }
  ]}
};

function renderDashboardTabs(activeTab){
  const tabsWrap=$('#dashboard-tabs');
  const panelsWrap=$('#dashboard-panels');
  if(!tabsWrap || !panelsWrap) return;
  if(!State.ui) State.ui={};
  const tabKey=activeTab && DASHBOARD_TAB_CONFIG[activeTab]? activeTab : (State.ui.dashboardTab && DASHBOARD_TAB_CONFIG[State.ui.dashboardTab]? State.ui.dashboardTab : 'season');
  State.ui.dashboardTab=tabKey;

  $$('#dashboard-tabs .dashboard-tab').forEach(btn=>{
    const isActive=btn.dataset.tab===tabKey;
    btn.classList.toggle('active',isActive);
    btn.setAttribute('aria-selected',isActive?'true':'false');
    btn.setAttribute('tabindex',isActive?'0':'-1');
  });

  $$('#dashboard-panels .dashboard-panel').forEach(panel=>{
    const isActive=panel.dataset.panel===tabKey;
    panel.classList.toggle('active',isActive);
    panel.setAttribute('aria-hidden',isActive?'false':'true');
  });

  const config=DASHBOARD_TAB_CONFIG[tabKey];
  if(config && Array.isArray(config.sections)){
    config.sections.forEach(section=>{
      const target=resolveTarget(section.selector, section.selector);
      if(target && typeof section.render==='function'){
        section.render(target);
      }
    });
  }

  refreshIcons();
}
function renderPlayoffSeries(series, isCurrentStage){
  const block=el('div',{class:'playoff-series'});
  block.append(el('h4',{}, series.name));
  const teamsWrap=el('div',{class:'series-teams'});
  series.teams.forEach(entry=>{
    const resolved=resolvePlayoffTeam(entry) || null;
    const tid=resolved?.team_id ?? entry.team_id ?? null;
    const name=resolved?.name || entry.name || 'æœªå®š';
    const wins=(tid!=null && series.wins)?(series.wins[tid]||0):0;
    const seedLabel=entry.seed?` (${entry.seed}ä½)`:'';
    const row=el('div',{class:'series-team'},
      el('span',{}, tid!=null ? `${name}${seedLabel}` : name),
      el('span',{class:'wins'}, `${wins}å‹`)
    );
    teamsWrap.append(row);
  });
  block.append(teamsWrap);
  if(series.games && series.games.length){
    const gameList=el('ul',{class:'series-games'});
    series.games.slice(-5).toReversed().forEach(g=>{
      const line=`G${g.game}: ${id2name(g.away_id)} ${g.away_runs} - ${id2name(g.home_id)} ${g.home_runs}`;
      gameList.append(el('li',{}, line));
    });
    block.append(gameList);
  }
  const info=el('div',{class:'series-status'}, `å…ˆã«${series.winsNeeded}å‹ã§æ±ºç€`);
  if(State.playoffs?.active && !series.completed && isCurrentStage){
    const action=el('div',{class:'series-action'});
    const btn=el('button',{class:'primary'}, el('i',{'data-lucide':'play'}), 'æ¬¡ã®è©¦åˆ');
    if(!playoffSeriesReady(series)){
      btn.disabled=true;
      btn.title='å¯¾æˆ¦ç›¸æ‰‹ãŒç¢ºå®šã™ã‚‹ã¾ã§å¾…æ©Ÿ';
    } else {
      btn.onclick=()=>{ playPlayoffGame(series.id); saveAndRerender(); };
    }
    action.append(btn, info);
    block.append(action);
  } else {
    block.append(info);
  }
  return block;
}
function renderPlayoffs(target){
  const container=resolveTarget(target,'#playoffsView');
  if(!container) return;
  const card=container.closest('[data-playoff-card]') || $("#playoffs-card");
  const playoffs=State.playoffs||defaultPlayoffState();
  const shouldShow=playoffs.started || playoffs.active || playoffs.completed;
  if(card) card.style.display=shouldShow?'' : 'none';
  container.innerHTML='';
  if(!shouldShow){ return; }
  const wrapper=el('div',{class:'playoffs-wrapper'});
  if(!playoffs.stages.length){
    wrapper.append(el('div',{class:'playoffs-empty'},'ãƒã‚¹ãƒˆã‚·ãƒ¼ã‚ºãƒ³ã¯æœªè¨­å®šã§ã™ã€‚'));
  } else {
    playoffs.stages.forEach((stage, idx)=>{
      const stageClasses=['playoff-stage'];
      if(stage.series.every(s=>s.completed)) stageClasses.push('done');
      else if(idx> (State.playoffs.stageIndex??0)) stageClasses.push('upcoming');
      const stageBlock=el('div',{class:stageClasses.join(' ')});
      const statusText = stage.series.every(s=>s.completed) ? 'çµ‚äº†' : (idx===(State.playoffs.stageIndex??0) && State.playoffs.active ? 'é€²è¡Œä¸­' : 'å¾…æ©Ÿä¸­');
      stageBlock.append(el('div',{class:'playoff-stage-header'}, el('span',{}, stage.name), el('span',{class:'series-status'}, statusText)));
      stage.series.forEach(series=> stageBlock.append(renderPlayoffSeries(series, idx===(State.playoffs.stageIndex??0))));
      wrapper.append(stageBlock);
    });
  }
  if(playoffs.completed && playoffs.champion!=null){
    const champName=id2name(playoffs.champion);
    const runner=playoffs.runnerUp!=null?id2name(playoffs.runnerUp):null;
    const banner=el('div',{class:'champion-banner'},
      el('div',{},`ðŸ† ${champName}`),
      el('div',{class:'mini'}, runner?`æº–å„ªå‹: ${runner}`:'ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼')
    );
    wrapper.append(banner);
  }
  container.append(wrapper);
}
function renderRecent(target){ const container=resolveTarget(target,'#recent'); if(!container) return; const last=(State.results||[]).slice(-20).toReversed(); const tbl=el("table",{}, el("thead",{}, el("tr",{}, el("th",{},"Day"), el("th",{},"Score"), el("th",{},"Inn"), el("th",{},"Key Moment"))), el("tbody"));
  for(const r of last){ const score=`${id2name(r.away_id)} ${r.away_runs} - ${id2name(r.home_id)} ${r.home_runs}`; const key=gameRecapKey(r.day, r.home_id, r.away_id); const hasRecap=!!(State.gameRecaps&&State.gameRecaps[key]); const attrs={ class:`recent-game-row${hasRecap?"":" disabled"}` };
    if(hasRecap){ attrs.role='button'; attrs.tabindex='0'; }
    let keyMomentText='-';
    if(hasRecap){
      const recap=State.gameRecaps[key];
      if(recap){
        if(Array.isArray(recap.keyMoments) && recap.keyMoments.length){
          const moment=recap.keyMoments[recap.keyMoments.length-1];
          if(moment){
            const halfText=moment.half==='top'?'è¡¨':'è£';
            keyMomentText=`${moment.inning}å›ž${halfText} ${moment.description}`;
          }
        } else if(recap.decidingPlay){
          keyMomentText=recap.decidingPlay;
        }
      }
    }
    const tr=el("tr",attrs, el("td",{},r.day||"?"), el("td",{style:"white-space:normal;"},score), el("td",{},r.innings||9), el("td",{style:"white-space:normal;"}, keyMomentText));
    if(hasRecap){ tr.dataset.gameKey=key; tr.onclick=()=>showGameRecapModal({ day:r.day, home_id:r.home_id, away_id:r.away_id, gameKey:key }); tr.onkeydown=(e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); tr.click(); } }; }
    tbl.lastChild.append(tr);
  }
  container.innerHTML=""; container.append(tbl);
}

function renderHighlights(target) {
    const feed = resolveTarget(target,'#highlightsFeed');
    if (!feed) return;
    feed.innerHTML = '';

    const narrativeSummary = (() => {
        const tid = State.userTeamId ?? 0;
        const narrative = State.teamNarratives?.[tid];
        if (!narrative) return null;
        const moralePoints = (narrative.morale || []).slice(-12);
        const events = (narrative.events || []).slice(-3).reverse();
        if (!moralePoints.length && !events.length) return null;

        const block = el('div', { class: 'narrative-feed-summary' });
        block.append(
            el('div', { class: 'daily-digest-header' },
                el('i', { 'data-lucide': 'drama', class: 'mini-icon' }),
                el('span', {}, `${id2name(tid)} å£«æ°—ãƒ­ã‚°`)
            )
        );

        if (moralePoints.length) {
            const values = moralePoints.map(p => p.value);
            const latest = values[values.length - 1];
            const avg = Math.round(values.reduce((a,b)=>a+b,0) / values.length);
            const meta = moralePoints[moralePoints.length - 1];
            const timeline = el('div', { class: 'morale-timeline' });
            timeline.append(el('span', {}, `æœ€æ–° ${latest}`));
            timeline.append(createSparklineSVG(values, 'var(--accent)', 160, 28));
            timeline.append(el('span', {}, `å¹³å‡ ${avg}`));
            block.append(timeline);
            block.append(el('p', { class: 'mini', style: 'margin:0 0 4px 0;color:var(--text-secondary);' }, `${meta.season}å¹´ç›® Day ${meta.day}`));
        }

        if (events.length) {
            const list = el('ul', { class: 'narrative-log-list' });
            events.forEach(evt => {
                const item = el('li', { class: 'narrative-log-item' });
                item.append(el('span', { class: 'narrative-tag' }, evt.tag || 'NARRATIVE'));
                const summary = evt.summary || evt.title || '';
                if (summary) item.append(document.createTextNode(` ${summary}`));
                item.append(el('div', { class: 'mini' }, `${evt.season}å¹´ç›® Day ${evt.day}`));
                list.append(item);
            });
            block.append(list);
        } else {
            block.append(el('div', { class: 'narrative-log-empty' }, 'æœ€æ–°ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚'));
        }

        const detailBtn = el('button', { class: 'ghost narrative-detail-button', type: 'button' },
            el('i', { 'data-lucide': 'notebook-text', class: 'mini-icon' }),
            'ã‚¤ãƒ™ãƒ³ãƒˆå±¥æ­´'
        );
        detailBtn.onclick = () => showNarrativeLogModal(tid);
        block.append(detailBtn);
        return block;
    })();

    if (narrativeSummary) feed.append(narrativeSummary);

    const buildDailyDigest = () => {
        const recaps = State.gameRecaps || {};
        const results = State.results || [];
        if (!results.length) return null;

        const byDay = new Map();
        for (let i = results.length - 1; i >= 0 && byDay.size < 7; i--) {
            const res = results[i];
            const key = gameRecapKey(res.day, res.home_id, res.away_id);
            const recap = recaps[key];
            if (!recap) continue;
            if (!byDay.has(res.day)) byDay.set(res.day, []);
            byDay.get(res.day).push({ recap, res, key });
        }
        if (!byDay.size) return null;

        const halfLabel = half => half === 'top' ? 'è¡¨' : half === 'bottom' ? 'è£' : '';
        const pickMoment = recap => {
            if (Array.isArray(recap.keyMoments) && recap.keyMoments.length) {
                const dramatic = [...recap.keyMoments].reverse().find(m => (m.description || '').includes('ã‚µãƒ¨ãƒŠãƒ©'));
                const candidate = dramatic || recap.keyMoments[recap.keyMoments.length - 1];
                const tid = candidate.side === 'home' ? recap.home_id : recap.away_id;
                const teamName = id2name(tid);
                const playerName = candidate.playerId ? (findPlayerById(tid, candidate.playerId)?.name || null) : null;
                return {
                    description: `${candidate.inning}å›ž${halfLabel(candidate.half)} ${candidate.description}`,
                    score: candidate.score,
                    before: candidate.before,
                    teamName,
                    playerName
                };
            }
            if (recap.decidingPlay) {
                const tid = recap.winner_id;
                const teamName = id2name(tid);
                const playerName = recap.decidingPlayerId ? (findPlayerById(tid, recap.decidingPlayerId)?.name || null) : null;
                return {
                    description: recap.decidingPlay,
                    score: recap.score,
                    before: null,
                    teamName,
                    playerName
                };
            }
            return null;
        };

        const block = el('div', { class: 'daily-digest' });
        block.append(
            el('div', { class: 'daily-digest-header' },
                el('i', { 'data-lucide': 'calendar-clock', class: 'mini-icon' }),
                el('span', {}, 'æ—¥æ¬¡ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆ')
            )
        );

        const list = el('div', { class: 'daily-digest-list' });
        const days = Array.from(byDay.keys()).sort((a, b) => b - a).slice(0, 5);
        days.forEach(day => {
            const entries = (byDay.get(day) || []).slice();
            entries.sort((a, b) => {
                const marginA = Math.abs((a.res.home_runs || 0) - (a.res.away_runs || 0));
                const marginB = Math.abs((b.res.home_runs || 0) - (b.res.away_runs || 0));
                if (marginA !== marginB) return marginA - marginB;
                const kmA = (a.recap.keyMoments || []).length;
                const kmB = (b.recap.keyMoments || []).length;
                return kmB - kmA;
            });

            const momentList = el('ul', { class: 'digest-moment-list' });
            let shown = 0;
            for (const entry of entries) {
                if (shown >= 3) break;
                const moment = pickMoment(entry.recap);
                if (!moment) continue;
                const scoreLine = entry.recap.scoreText || `${id2name(entry.res.away_id)} ${entry.res.away_runs} - ${id2name(entry.res.home_id)} ${entry.res.home_runs}`;
                const item = el('li', { class: 'digest-moment' });
                item.append(el('div', { class: 'digest-moment-score' }, scoreLine));

                let desc = moment.description;
                if (moment.teamName) desc = `${moment.teamName}ï¼š${desc}`;
                if (moment.before && moment.score) {
                    const beforeLine = `${moment.before.away}-${moment.before.home}`;
                    const afterLine = `${moment.score.away}-${moment.score.home}`;
                    desc += beforeLine !== afterLine ? `ï¼ˆ${beforeLine}â†’${afterLine}ï¼‰` : `ï¼ˆ${afterLine}ï¼‰`;
                } else if (moment.score) {
                    desc += `ï¼ˆ${moment.score.away}-${moment.score.home}ï¼‰`;
                }
                item.append(el('div', { class: 'digest-moment-desc' }, desc));

                if (moment.playerName) {
                    item.append(el('div', { class: 'digest-moment-hero' }, `ãƒ’ãƒ¼ãƒ­ãƒ¼: ${moment.playerName}`));
                }

                if (entry.key) {
                    const btn = el('button', { class: 'highlight-link ghost', type: 'button' },
                        el('i', { 'data-lucide': 'book-open', class: 'mini-icon' }),
                        'è©¦åˆè©³ç´°'
                    );
                    btn.style.alignSelf = 'flex-start';
                    btn.style.marginTop = '4px';
                    btn.onclick = () => showGameRecapModal({ gameKey: entry.key, day: entry.recap.day, home_id: entry.recap.home_id, away_id: entry.recap.away_id });
                    item.append(btn);
                }

                momentList.append(item);
                shown++;
            }

            if (momentList.childElementCount) {
                const dayBlock = el('div', { class: 'digest-day' },
                    el('div', { class: 'digest-day-header' },
                        el('span', {}, `Day ${day}`),
                        el('span', { class: 'mini' }, `${entries.length}è©¦åˆ`)
                    ),
                    momentList
                );
                list.append(dayBlock);
            }
        });

        if (!list.childElementCount) return null;
        block.append(list);
        return block;
    };

    const digestBlock = buildDailyDigest();
    if (digestBlock) feed.append(digestBlock);

    const highlights = (State.highlights || []).slice(-50).toReversed();

    if (highlights.length === 0) {
        const message = digestBlock ? 'æœ€æ–°ã®å˜ç‹¬ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ—¥æ¬¡ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚' : 'ã¾ã ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ¼ã‚ºãƒ³ã‚’é€²ã‚ã¾ã—ã‚‡ã†ï¼';
        feed.append(el('div', { class: 'digest-empty' }, message));
        return;
    }

    highlights.forEach(h => {
        const item = el('div', { class: 'feed-item' },
            el('div', { class: 'feed-icon' }, el('i', { 'data-lucide': h.icon, class: 'mini-icon' })),
            (() => {
                const message = el('p', {});
                if (h.category === 'finance') {
                    const label = h.financeType ? `FIN-${String(h.financeType).toUpperCase()}` : 'FINANCE';
                    const badge = el('span', { class: 'finance-tag', style: 'margin-right:6px;' }, label);
                    message.append(badge, document.createTextNode(h.text));
                } else if (h.category === 'narrative') {
                    const label = h.tag ? String(h.tag).toUpperCase() : 'NARRATIVE';
                    const badge = el('span', { class: 'narrative-tag', style: 'margin-right:6px;' }, label);
                    message.append(badge, document.createTextNode(h.text));
                } else {
                    message.textContent = h.text;
                }
                const metaBits = [`${h.season}å¹´ç›® Day ${h.day}`];
                if (h.team_id != null) metaBits.push(id2name(h.team_id));
                if (h.category === 'narrative' && h.tag) metaBits.push(String(h.tag));
                if (h.category === 'finance' && h.team_id != null) {
                    const reserves = State.teamFinances?.[h.team_id]?.budget?.reserves;
                    if (typeof reserves === 'number') {
                        metaBits.push(`æ®‹é«˜ Â¥${Math.round(reserves / 1000000)}M`);
                    }
                }
                const content = el('div', { class: 'feed-content', style: 'width: 100%;' },
                    message,
                    el('p', { class: 'mini' }, metaBits.join(' ï½œ '))
                );
                if (h.gameKey && State.gameRecaps?.[h.gameKey]) {
                    const btn = el('button', { class: 'highlight-link', type: 'button' },
                        el('i', { 'data-lucide': 'book-open-check', class: 'mini-icon' }),
                        'è©¦åˆè©³ç´°'
                    );
                    btn.onclick = () => showGameRecapModal(h);
                    content.append(btn);
                }
                return content;
            })()
        );
        feed.append(item);
    });
}

function renderFrontOffice(target) {
    ensureTeamMeta();
    ensureTeamFinances();
    ensureFreeAgents();
    const faState = ensureFreeAgencyState(State);
    const tid = parseInt($("#selTeamManage").value || State.userTeamId || 0);
    const meta = State.teamMeta[tid];
    const finance = State.teamFinances[tid];
    const frontOfficeEl = resolveTarget(target,'#frontOffice');
    if (!frontOfficeEl) return;
    frontOfficeEl.innerHTML = "";
    if (!finance) {
        frontOfficeEl.append(el('div', { class: 'mini' }, 'è²¡å‹™ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ¼ã‚ºãƒ³ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚'));
        return;
    }
    computeAttendanceForecast(tid);
    updateFinancialSnapshots(tid);
    const allowed = canControlTeam(tid);
    const wrap = el('div', { class: 'finance-section' });

    function createSummaryCard(icon, title, headline, stats) {
        const card = el('div', { class: 'finance-card' },
            el('h3', {}, el('i', { 'data-lucide': icon, class: 'mini-icon' }), title),
            el('div', { style: 'font-size:22px;font-weight:700;' }, headline)
        );
        stats.forEach(([label, value]) => card.append(el('div', { class: 'finance-stat' }, el('span', {}, label), el('strong', {}, value))));
        return card;
    }

    const summaryGrid = el('div', { class: 'finance-grid' });
    summaryGrid.append(
        createSummaryCard('piggy-bank', 'é‹è»¢è³‡é‡‘', millionFormatter(finance.budget.reserves || 0), [
            ['å¹´é–“åŽå…¥', millionFormatter(finance.revenue.total || 0)],
            ['å¹´é–“æ”¯å‡º', millionFormatter(finance.expenses.total || 0)]
        ]),
        createSummaryCard('wallet', 'å¹´ä¿¸ç·é¡', millionFormatter(finance.expenses.payroll || 0), [
            ['ã‚¹ã‚¿ãƒƒãƒ•', millionFormatter(finance.expenses.staff || 0)],
            ['æ–½è¨­æŠ•è³‡', millionFormatter(finance.expenses.facilities || 0)]
        ]),
        createSummaryCard('users', 'è¦³å®¢å‹•å“¡', `${yenFormatter.format(finance.attendance.forecast || 0)} äºº`, [
            ['å¹³å‡', `${yenFormatter.format(finance.attendance.average || 0)} äºº`],
            ['ç´¯è¨ˆ', `${yenFormatter.format(finance.attendance.seasonTotal || 0)} äºº`]
        ]),
        createSummaryCard('sprout', 'Devãƒã‚¤ãƒ³ãƒˆ', `${Math.floor(meta.dp || 0)} pt`, [
            ['FAå€™è£œ', `${State.freeAgents.length} å`],
            ['ãƒã‚±ãƒƒãƒˆ', `Â¥${yenFormatter.format(finance.ticketPrice || DEFAULT_TICKET_PRICE)}`]
        ])
    );
    wrap.append(summaryGrid);

    const budgetCard = el('div', { class: 'finance-card' });
    budgetCard.append(el('h3', {}, el('i', { 'data-lucide': 'pie-chart' }), 'äºˆç®—é…åˆ†'));
    const budgetLabels = { payroll: 'é¸æ‰‹å¹´ä¿¸', staff: 'ã‚¹ã‚¿ãƒƒãƒ•', facilities: 'æ–½è¨­æ•´å‚™', marketing: 'ãƒžãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°' };
    function setAllocation(cat, ratio) {
        finance.budget.allocations[cat] = ratio;
        const total = BUDGET_CATEGORIES.reduce((sum, key) => sum + (finance.budget.allocations[key] || 0), 0);
        if (Math.abs(total - 1) > 0.001) {
            const others = BUDGET_CATEGORIES.filter(c => c !== cat);
            const remainder = 1 - finance.budget.allocations[cat];
            const otherTotal = others.reduce((sum, key) => sum + (finance.budget.allocations[key] || 0), 0);
            others.forEach(key => {
                finance.budget.allocations[key] = otherTotal > 0 ? (finance.budget.allocations[key] || 0) / otherTotal * remainder : remainder / others.length;
            });
        }
        updateFinancialSnapshots(tid);
        saveAndRerender();
    }
    BUDGET_CATEGORIES.forEach(cat => {
        const ratio = finance.budget.allocations[cat] || 0;
        const percent = el('strong', {}, `${Math.round(ratio * 100)}%`);
        const slider = el('input', { type: 'range', min: '5', max: '80', value: Math.round(ratio * 100), class: 'budget-slider' });
        slider.oninput = () => percent.textContent = `${slider.value}%`;
        slider.onchange = () => setAllocation(cat, parseInt(slider.value, 10) / 100);
        slider.disabled = !allowed;
        const block = el('div', { style: 'display:flex; flex-direction:column; gap:4px; margin-bottom:6px;' },
            el('div', { class: 'finance-stat' }, el('span', {}, budgetLabels[cat] || cat), percent),
            slider
        );
        budgetCard.append(block);
    });
    wrap.append(budgetCard);

    const ticketCard = el('div', { class: 'finance-card' });
    ticketCard.append(el('h3', {}, el('i', { 'data-lucide': 'ticket' }), 'ãƒã‚±ãƒƒãƒˆä¾¡æ ¼ & éœ€è¦'));
    const ticketInput = el('input', { type: 'number', min: '1200', max: '7000', step: '100', value: finance.ticketPrice || DEFAULT_TICKET_PRICE });
    ticketInput.disabled = !allowed;
    ticketInput.onchange = () => {
        const val = clamp(parseInt(ticketInput.value, 10) || DEFAULT_TICKET_PRICE, 1200, 7000);
        finance.ticketPrice = val;
        computeAttendanceForecast(tid);
        updateFinancialSnapshots(tid);
        saveAndRerender();
    };
    ticketCard.append(el('div', { class: 'finance-stat' }, el('span', {}, 'ä¾¡æ ¼(å††)'), ticketInput));
    const forecastBlock = el('div', { class: 'finance-forecast' },
        el('span', {}, el('strong', {}, 'äºˆæ¸¬'), `${yenFormatter.format(finance.attendance.forecast || 0)} äºº`),
        el('span', {}, el('strong', {}, 'å¹³å‡'), `${yenFormatter.format(finance.attendance.average || 0)} äºº`),
        el('span', {}, el('strong', {}, 'ç´¯è¨ˆ'), `${yenFormatter.format(finance.attendance.seasonTotal || 0)} äºº`)
    );
    ticketCard.append(forecastBlock);
    wrap.append(ticketCard);

    const contractSection = el('div', { class: 'finance-section' });
    contractSection.append(el('h3', {}, el('i', { 'data-lucide': 'notebook-pen' }), 'å¥‘ç´„çŠ¶æ³'));
    const contractsHost = el('div', { id: 'contractsViewHost' });
    contractSection.append(contractsHost);
    const contractActions = el('div', { class: 'finance-actions' });
    const faBtn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'user-plus' }), 'FAå¸‚å ´');
    faBtn.disabled = !allowed;
    faBtn.onclick = () => openFreeAgentModal(tid);
    const tradeBtn = el('button', {}, el('i', { 'data-lucide': 'handshake' }), 'ãƒˆãƒ¬ãƒ¼ãƒ‰ææ¡ˆ');
    tradeBtn.disabled = !allowed;
    tradeBtn.onclick = () => openTradeModal(tid);
    const ledgerBtn = el('button', {}, el('i', { 'data-lucide': 'file-text' }), 'è²¡å‹™ãƒ¬ãƒãƒ¼ãƒˆ');
    ledgerBtn.onclick = () => openLedgerModal(tid);
    contractActions.append(faBtn, tradeBtn, ledgerBtn);
    contractSection.append(contractActions);
    wrap.append(contractSection);
    contractsView.render({
        container: contractsHost,
        roster: State.rosters?.[tid],
        finance,
        teamId: tid,
        season: State.season,
        day: State.curr_day,
        canControl: allowed,
    });

    const faSection = el('div', { class: 'finance-section' });
    faSection.append(el('h3', {}, el('i', { 'data-lucide': 'user-cog', class: 'mini-icon' }), 'FAå¸‚å ´ & è£œå„Ÿç®¡ç†'));
    const faHost = el('div', { id: 'faViewHost' });
    faSection.append(faHost);
    wrap.append(faSection);
    faView.render({
        container: faHost,
        roster: State.rosters?.[tid],
        freeAgents: State.freeAgents,
        faState,
        teamId: tid,
        canControl: allowed,
        season: State.season,
        state: State,
    });

    const staffCard = el('div', { class: 'finance-card' });
    staffCard.append(el('h3', {}, el('i', { 'data-lucide': 'briefcase-business' }), 'ã‚¹ã‚¿ãƒƒãƒ•é›‡ç”¨'));
    const staffLabels = { coaches: 'ã‚³ãƒ¼ãƒ', scouts: 'ã‚¹ã‚«ã‚¦ãƒˆ', analysts: 'ã‚¢ãƒŠãƒªã‚¹ãƒˆ', marketing: 'å–¶æ¥­/åºƒå ±' };
    Object.entries(staffLabels).forEach(([key, label]) => {
        const count = finance.staff[key] || 0;
        const cost = STAFF_COSTS[key] || 0;
        staffCard.append(el('div', { class: 'finance-stat' }, el('span', {}, label), el('strong', {}, `${count} å`)));
        const buttons = el('div', { class: 'finance-actions' });
        const hireBtn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'plus' }), 'æŽ¡ç”¨');
        hireBtn.disabled = !allowed || (finance.budget.reserves || 0) < cost;
        hireBtn.onclick = () => {
            if (!allowed || (finance.budget.reserves || 0) < cost) return;
            finance.staff[key] = (finance.staff[key] || 0) + 1;
            finance.budget.reserves -= cost;
            logHighlight('briefcase', `ã€ã‚¹ã‚¿ãƒƒãƒ•æŽ¡ç”¨ã€‘${id2name(tid)}ãŒ${label}ã‚’è¿½åŠ é›‡ç”¨ã€‚`, { category: 'finance', financeType: 'staff', tid, day: State.curr_day });
            updateFinancialSnapshots(tid);
            saveAndRerender();
        };
        const fireBtn = el('button', {}, el('i', { 'data-lucide': 'minus' }), 'å‰Šæ¸›');
        fireBtn.disabled = !allowed || count <= 0;
        fireBtn.onclick = () => {
            if (!allowed || finance.staff[key] <= 0) return;
            finance.staff[key]--;
            finance.budget.reserves += Math.round(cost * 0.3);
            logHighlight('briefcase', `ã€ã‚¹ã‚¿ãƒƒãƒ•å†ç·¨ã€‘${label}ä½“åˆ¶ã‚’è¦‹ç›´ã—ã¾ã—ãŸã€‚`, { category: 'finance', financeType: 'staff', tid, day: State.curr_day });
            updateFinancialSnapshots(tid);
            saveAndRerender();
        };
        buttons.append(hireBtn, fireBtn, el('span', { class: 'mini' }, `ã‚³ã‚¹ãƒˆ ${millionFormatter(cost)}`));
        staffCard.append(buttons);
    });
    wrap.append(staffCard);

    const upgradeCard = el('div', { class: 'finance-card' });
    upgradeCard.append(el('h3', {}, el('i', { 'data-lucide': 'wrench' }), 'è‚²æˆæŠ•è³‡ (DevP)'));
    upgradeCard.append(el('div', { class: 'finance-stat' }, el('span', {}, 'ä¿æœ‰Devãƒã‚¤ãƒ³ãƒˆ'), el('strong', {}, `${Math.floor(meta.dp || 0)} pt`)));
    const upgradeTable = el('table', { class: 'contract-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, 'ç¨®åˆ¥'),
            el('th', {}, 'ãƒ¬ãƒ™ãƒ«'),
            el('th', {}, 'åŠ¹æžœ'),
            el('th', {}, 'æ“ä½œ')
        )),
        el('tbody')
    );
    function upgradeRow(name, currentLevel, desc, updateFn) {
        const tr = el('tr');
        const level = currentLevel || 0;
        const maxLevel = 3;
        const cost = 20 + (level * 10);
        const btn = el('button', {}, el('i', { 'data-lucide': 'plus' }), level >= maxLevel ? 'MAX' : `å¼·åŒ–(${cost})`);
        if (level >= maxLevel) {
            btn.disabled = true;
        } else if (!allowed) {
            btn.disabled = true;
            btn.title = 'è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“ï¼ˆã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§å¯ï¼‰';
        } else {
            btn.onclick = () => {
                if (dpSpend(tid, cost)) {
                    updateFn();
                    State.devLogs.push(`[${id2name(tid)}] å¼·åŒ–: ${name} â†’ Lv${level + 1}`);
                    saveAndRerender();
                } else {
                    console.error(`ãƒã‚¤ãƒ³ãƒˆä¸è¶³ (å¿…è¦: ${cost})`);
                }
            };
        }
        tr.append(
            el('td', {}, name),
            el('td', {}, level),
            el('td', { style: 'white-space:normal;text-align:left' }, desc),
            el('td', {}, btn)
        );
        return tr;
    }
    upgradeTable.lastChild.append(
        upgradeRow('ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¸ãƒ ', meta.facilities.gym, 'ãƒ‘ãƒ¯ãƒ¼/çƒå¨/ä½“åŠ›ã®ä¼¸ã³+2%/Lv', () => meta.facilities.gym++),
        upgradeRow('ãƒ“ãƒ‡ã‚ªãƒ»ãƒ©ãƒœ', meta.facilities.video, 'ã‚³ãƒ³/é¸çƒ/åˆ¶çƒ/å¤‰åŒ–/å®ˆå‚™ã®ä¼¸ã³+2%/Lv', () => meta.facilities.video++),
        upgradeRow('ãƒ¡ãƒ‡ã‚£ã‚«ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼', meta.facilities.medical, 'é€±ã®å›žå¾© +6/Lvãƒ»æ•…éšœçŽ‡è»½æ¸›', () => { meta.facilities.medical++; meta.facilities.recovery = meta.facilities.medical; }),
        upgradeRow('æ‰“æ’ƒã‚³ãƒ¼ãƒ', meta.coaches.hit, 'æ‰“æ’ƒç³»ã®ä¼¸ã³+3%/Lv', () => meta.coaches.hit++),
        upgradeRow('æŠ•æ‰‹ã‚³ãƒ¼ãƒ', meta.coaches.pit, 'æŠ•æ‰‹ç³»ã®ä¼¸ã³+3%/Lv', () => meta.coaches.pit++),
        upgradeRow('ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ‹ãƒ³ã‚°', meta.coaches.cond, 'å…¨ä½“ã®ä¼¸ã³+1%/Lvãƒ»ç–²åŠ´è€æ€§', () => meta.coaches.cond++)
    );
    upgradeCard.append(el('div', { class: 'table-scroll', style: 'max-height:220px;' }, upgradeTable));
    wrap.append(upgradeCard);

    frontOfficeEl.append(wrap);
    refreshIcons();
}

function renderManagementView(){ const tab = $(".tab.active").getAttribute("data-tab"); const tid = parseInt($("#selTeamManage").value||0); const container = $("#management-content"); container.innerHTML = "";
  const narrativePanel = renderTeamNarrativePanel(tid);
  if(narrativePanel) container.append(narrativePanel);
  if(tab === "roster") container.append(renderRosterView(tid));
  if(tab === "training") container.append(renderTrainingView(tid));
  if(tab === "stats") container.append(renderStatsView(tid));
  if(tab === "draft") draftView.render({ container, teamId: tid, userTeamId: State.userTeamId??0, isCommissioner: !!State.commissioner });
  if(tab === "front") {
    const frontContainer = el('div', { class: 'front-office-view' });
    container.append(frontContainer);
    financeView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
    staffView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
    facilitiesView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
  }
  if(tab === "report") container.append(renderReportView());
}

function moraleBar(v){ const wrap=el("div",{style:"min-width:140px;text-align:left"}); wrap.append(el("div",{class:"mini",style:"margin-bottom:4px;"},`å£«æ°— ${v}`)); const bar=el("div",{class:"bar",style:"width:140px;"}, el("span",{style:`width:${v}%;`})); wrap.append(bar); return wrap; }
function fatigueBar(v){ const wrap=el("div",{style:"min-width:140px;text-align:left"}); wrap.append(el("div",{class:"mini",style:"margin-bottom:4px;"},`ç–²åŠ´ ${v}`)); const bar=el("div",{class:"bar",style:"width:140px;"}, el("span",{style:`width:${v}%;background:linear-gradient(90deg,#ef4444,#f59e0b);`})); wrap.append(bar); return wrap; }

function squadSelect(tid, pid, cur){
  const sl = el("select", {"data-id":pid, class:"squad", style:"width:80px;"});
  ["ä¸€è»","äºŒè»"].forEach(k=>sl.append(el("option", {value:k, selected:k===cur?true:null}, k)));
  const allowed = canControlTeam(tid);
  if(!allowed){
    sl.disabled = true;
    sl.title = "è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“ï¼ˆã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§å¯ï¼‰";
    return sl;
  }
  sl.dataset.prev = cur;
  sl.onchange = ()=>{
    const prevValue=sl.dataset.prev||cur;
    const result=moveSquad(tid, pid, sl.value);
    if(!result?.ok){
      sl.value=prevValue;
      const remaining=result?.remainingDays;
      let desc='';
      if(Number.isFinite(remaining)){
        desc=`ã‚ã¨${remaining}æ—¥å¿…è¦ã§ã™ã€‚`;
        if(result?.error?.availableDay){
          desc+=` (${result.error.availableDay}æ—¥ç›®ä»¥é™ã«ç§»å‹•å¯èƒ½)`;
        }
      }
      showToast(result?.reason||'ç§»å‹•ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚', { type:'error', description:desc || undefined, duration:5000 });
      return;
    }
    sl.dataset.prev=result.to||sl.value;
    if(!result.changed){
      return;
    }
    recomputeAllRatingsAll();
    saveAndRerender();
  };
  return sl;
}

function renderRosterView(tid){
  ensureSquads(); const R=State.rosters[tid]; const ichiSet=new Set(State.squads[tid].ichi); const niSet=new Set(State.squads[tid].ni); const frag=document.createDocumentFragment();
  const allowed = canControlTeam(tid);

  const controls = el("div", {class:"controls", style:"margin-bottom: 16px; justify-content: flex-start;"});
  const autoAssignBtn = el("button", {id:"btnRosterAutoAssign"}, el("i",{"data-lucide":"shuffle"}), "1è»/2è»ã‚’è‡ªå‹•ç·¨æˆ");
  autoAssignBtn.onclick = () => {
    if(!allowed){
      showToast('è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“', { type: 'error' });
      return;
    }
    autoAssignSquads(tid);
    recomputeAllRatingsAll();
    renderManagementView();
    save();
    showToast(`${id2name(tid)}ã®1è»/2è»ã‚’è‡ªå‹•ç·¨æˆã—ã¾ã—ãŸã€‚`, { type: 'info' });
  };
  if(!allowed){
      autoAssignBtn.disabled = true;
      autoAssignBtn.title = 'è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“ï¼ˆã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§å¯ï¼‰';
  }
  controls.append(autoAssignBtn);
  frag.append(controls);

  const compliance=getRosterCompliance(tid) || null;
  if(compliance && ((Array.isArray(compliance.errors) && compliance.errors.length) || (Array.isArray(compliance.warnings) && compliance.warnings.length))){
    const hasError=Array.isArray(compliance.errors) && compliance.errors.length>0;
    const severity=hasError?'error':'warning';
    const icon=hasError?'shield-alert':'alert-triangle';
    const headline=hasError?compliance.errors[0]:compliance.warnings[0];
    const banner=el('div',{class:`roster-compliance-banner ${severity}`});
    banner.append(
      el('div',{class:'banner-header'}, el('i',{'data-lucide':icon,class:'mini-icon'}), headline),
      el('div',{class:'banner-body'},`ç¾åœ¨ ${compliance.foreignCount}/${compliance.limit ?? 'â€”'} æž ï¼ˆä¸€è» ${compliance.activeCount ?? 0}åã€${compliance.label}ï¼‰`)
    );
    if(Array.isArray(compliance.foreignPlayers) && compliance.foreignPlayers.length){
      const list=el('ul');
      compliance.foreignPlayers.forEach(player=>{
        const role=player.type==='PIT'?'æŠ•æ‰‹':'é‡Žæ‰‹';
        list.append(el('li',{},`${player.name} (${role})`));
      });
      banner.append(list);
    }
    frag.append(banner);
  }
  const hBat=el("h3",{class:"mini",style:"padding:8px;font-weight:bold;",html:"<br>é‡Žæ‰‹"});
  const tBat=el("table",{},el("thead",{},el("tr",{},...['é¸æ‰‹','å¹´','å®ˆ','æŠ•','ãƒŸ','é¸','ãƒ‘','èµ°','å®ˆ','ãƒ','æ‰€å±ž', '<i data-lucide="trending-up" class="mini-icon"></i>', '<i data-lucide="battery-warning" class="mini-icon"></i>', '<i data-lucide="smile" class="mini-icon"></i>','ç‰¹èƒ½','ç‰¹è¨“'].map(h=>el('th',{html:h})))),el("tbody"));
  
  const prevSeason = State.season - 1;

  R.bats.slice().sort((a,b)=> battingScore(b,"R")-battingScore(a,"R")).forEach(batter=>{
    const tr = el('tr');
    if (batter.injury) tr.classList.add('injured');

    let statusIcon = '';
    if (batter.injury) statusIcon = 'ðŸ©¹';
    else if (batter.status?.hot > 0) statusIcon = 'ðŸ”¥';
    else if (batter.status?.slump > 0) statusIcon = 'â„ï¸';
    
    const nameTd = el('td', { style: 'display:flex; align-items:center; gap: 4px;'});
    const nameBtn = el('button', { class: 'ghost', style: 'text-decoration: underline; box-shadow: none; padding: 4px; text-align: left;', html: `${statusIcon} ${batter.name}` });
    nameBtn.onclick = () => showPlayerDetailModal(batter.id, tid);
    nameTd.append(nameBtn);
    if(batter.isForeign){
      nameTd.append(el('span',{class:'foreign-badge', title:'å¤–å›½äººæž å¯¾è±¡'},'å¤–'));
    }

    if (batter.recentGains && batter.recentGains.length > 0) {
        const statGain = batter.recentGains.find(g => /^[A-Za-z]+\+\d+$/.test(g));
        if (statGain) {
            let [stat, val] = statGain.split('+');
            const gainBadge = el('span', { class: 'pill', style: 'font-size: 9px; padding: 1px 4px; background: var(--good); color: #fff; border: none; font-weight: 700;' }, `${stat.slice(0,3)} +${val}`);
            nameTd.append(gainBadge);
        }
    }

    if (niSet.has(batter.id)) {
        const reveal = Math.round(batter.farmReveal || 0);
        if (Number.isFinite(reveal)) {
            const gain = Math.round(batter.farmLast?.revealGain || 0);
            const label = gain > 0 ? `æ½œåœ¨${reveal}% (+${gain})` : `æ½œåœ¨${reveal}%`;
            const badge = el('span', { class: 'pill farm', title: `äºŒè»æ½œåœ¨é–‹ç¤ºåº¦ ${reveal}%` }, label);
            nameTd.append(badge);
        }
        const recovered = Math.round(batter.farmLast?.fatigueRecovered || 0);
        if (recovered > 0) {
            nameTd.append(el('span', { class: 'pill farm-fatigue', title: 'äºŒè»è¿½åŠ å›žå¾©é‡' }, `å›žå¾©${recovered}`));
        }
        if (Array.isArray(batter.farmLast?.traitUnlocks) && batter.farmLast.traitUnlocks.length > 0) {
            const title = batter.farmLast.traitUnlocks.join(' / ');
            nameTd.append(el('span', { class: 'pill farm-trait', title }, 'è¦šé†’'));
        }
    }
    
    const prevHistory = State.historicalStats?.[prevSeason]?.[batter.id]?.history;

    tr.append( nameTd, el('td',{},batter.age), el('td',{},batter.pos), el('td',{},batter.hand), statTd(batter.con), statTd(batter.disc), statTd(batter.pwr), statTd(batter.spd), statTd(batter.fld), statTd(batter.pot), 
        el('td',{},squadSelect(tid, batter.id, ichiSet.has(batter.id)?'ä¸€è»':'äºŒè»')), 
        el('td', {}, createSparklineSVG(batter.history.overall, 'var(--primary)', 40, 16, prevHistory?.overall)),
        el('td', {}, createSparklineSVG(batter.history.fatigue, 'var(--warn)', 40, 16, prevHistory?.fatigue)),
        el('td', {}, createSparklineSVG(batter.history.morale, 'var(--accent)', 40, 16, prevHistory?.morale)),
        el('td',{style:'white-space:normal; font-size: 11px;'}, (batter.traits||[]).join(' '))
    );

    const btnWrap=el('td',{});
    const btn=el('button',{class:'ghost'}, el('i',{"data-lucide":"flame"}), 'ç‰¹è¨“(5)');
    if(!allowed || batter.injury){ btn.disabled=true; btn.title= batter.injury ? 'æ€ªæˆ‘ã®ãŸã‚ä¸å¯' : 'è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'; }
    else { btn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevPä¸è¶³'); return; } doSpecialTraining(tid, batter.id); }; }
    btnWrap.append(btn); 
    tr.append(btnWrap); 
    tBat.lastChild.append(tr);
  });
  const hPit=el("h3",{class:"mini",style:"padding:8px;font-weight:bold;",html:"<br>æŠ•æ‰‹"});
  const tPit=el("table",{},el("thead",{},el("tr",{},...['é¸æ‰‹','å¹´','å½¹','æŠ•','é€Ÿ','ã‚³','å¤‰','ä½“','ãƒ','æ‰€å±ž', '<i data-lucide="trending-up" class="mini-icon"></i>', '<i data-lucide="battery-warning" class="mini-icon"></i>', '<i data-lucide="smile" class="mini-icon"></i>','ç‰¹èƒ½','ç‰¹è¨“'].map(h=>el('th',{html:h})))),el("tbody"));

  R.pits.slice().sort((a,b)=> (b.velo*0.45+b.mov*0.35+b.ctrl*0.2)-(a.velo*0.45+a.mov*0.35+a.ctrl*0.2)).forEach(p=>{
    const tr = el('tr');
    if (p.injury) tr.classList.add('injured');

    let statusIcon = '';
    if (p.injury) statusIcon = 'ðŸ©¹';
    else if (p.status?.hot > 0) statusIcon = 'ðŸ”¥';
    else if (p.status?.slump > 0) statusIcon = 'â„ï¸';

    const nameTd = el('td', { style: 'display:flex; align-items:center; gap: 4px;'});
    const nameBtn = el('button', { class: 'ghost', style: 'text-decoration: underline; box-shadow: none; padding: 4px; text-align: left;', html: `${statusIcon} ${p.name}` });
    nameBtn.onclick = () => showPlayerDetailModal(p.id, tid);
    nameTd.append(nameBtn);
    if(p.isForeign){
      nameTd.append(el('span',{class:'foreign-badge', title:'å¤–å›½äººæž å¯¾è±¡'},'å¤–'));
    }

    if (p.recentGains && p.recentGains.length > 0) {
        const statGain = p.recentGains.find(g => /^[A-Za-z]+\+\d+$/.test(g));
        if (statGain) {
            let [stat, val] = statGain.split('+');
            const gainBadge = el('span', { class: 'pill', style: 'font-size: 9px; padding: 1px 4px; background: var(--good); color: #fff; border: none; font-weight: 700;' }, `${stat.slice(0,3)} +${val}`);
            nameTd.append(gainBadge);
        }
    }

    if (niSet.has(p.id)) {
        const reveal = Math.round(p.farmReveal || 0);
        if (Number.isFinite(reveal)) {
            const gain = Math.round(p.farmLast?.revealGain || 0);
            const label = gain > 0 ? `æ½œåœ¨${reveal}% (+${gain})` : `æ½œåœ¨${reveal}%`;
            nameTd.append(el('span', { class: 'pill farm', title: `äºŒè»æ½œåœ¨é–‹ç¤ºåº¦ ${reveal}%` }, label));
        }
        const recovered = Math.round(p.farmLast?.fatigueRecovered || 0);
        if (recovered > 0) {
            nameTd.append(el('span', { class: 'pill farm-fatigue', title: 'äºŒè»è¿½åŠ å›žå¾©é‡' }, `å›žå¾©${recovered}`));
        }
        if (Array.isArray(p.farmLast?.traitUnlocks) && p.farmLast.traitUnlocks.length > 0) {
            nameTd.append(el('span', { class: 'pill farm-trait', title: p.farmLast.traitUnlocks.join(' / ') }, 'è¦šé†’'));
        }
    }
    
    const roleCell = el('td');
    if (p.role === 'SP') {
        roleCell.textContent = 'SP';
    } else {
        const subRoleSelect = el('select', { style: 'width: 110px;' });
        const subRoles = ['ä¸­ç¶™ãŽ', 'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ‘ãƒ¼', 'ã‚¯ãƒ­ãƒ¼ã‚¶ãƒ¼'];
        subRoles.forEach(sr => {
            subRoleSelect.append(el('option', { value: sr, selected: (p.sub_role || 'ä¸­ç¶™ãŽ') === sr }, sr));
        });
        if (!allowed) {
            subRoleSelect.disabled = true;
        } else {
            subRoleSelect.onchange = () => {
                p.sub_role = subRoleSelect.value;
                recomputeAllRatingsAll();
                save();
            };
        }
        roleCell.append(subRoleSelect);
    }

    const prevHistory = State.historicalStats?.[prevSeason]?.[p.id]?.history;

    tr.append( nameTd, el('td',{},p.age), roleCell, el('td',{},p.hand), statTd(p.velo), statTd(p.ctrl), statTd(p.mov), statTd(p.stam), statTd(p.pot), 
        el('td',{},squadSelect(tid, p.id, ichiSet.has(p.id)?'ä¸€è»':'äºŒè»')), 
        el('td', {}, createSparklineSVG(p.history.overall, 'var(--primary)', 40, 16, prevHistory?.overall)),
        el('td', {}, createSparklineSVG(p.history.fatigue, 'var(--warn)', 40, 16, prevHistory?.fatigue)),
        el('td', {}, createSparklineSVG(p.history.morale, 'var(--accent)', 40, 16, prevHistory?.morale)),
        el('td',{style:'white-space:normal; font-size: 11px;'}, (p.traits||[]).join(' '))
    );
    
    const btnWrap=el('td',{});
    const btn=el('button',{class:'ghost'}, el('i',{"data-lucide":"flame"}), 'ç‰¹è¨“(5)');
    if(!allowed || p.injury){ btn.disabled=true; btn.title= p.injury ? 'æ€ªæˆ‘ã®ãŸã‚ä¸å¯' : 'è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'; }
    else { btn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevPä¸è¶³'); return; } doSpecialTraining(tid, p.id); }; }
    btnWrap.append(btn); 
    tr.append(btnWrap); 
    tPit.lastChild.append(tr);
  });
  frag.append(el("div",{class:"table-scroll"}, hBat, tBat), el("div", {class:"table-scroll", style:"margin-top:16px;"}, hPit, tPit));
  return frag;
}

function renderTrainingView(tid){
  ensureSquads(); ensureTrainingDefaults(tid); const R=State.rosters[tid]; const tp=State.trainingPlans[tid]; const ichiSet=new Set(State.squads[tid].ichi); const frag=document.createDocumentFragment();
  const allowed = canControlTeam(tid);

  ensureTeamStrategy(tid);
  const strategy = State.teamStrategy[tid];

  const steps = el('ol', { class: 'training-steps', 'aria-label': 'è‚²æˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼' });
  ['æ–¹é‡è¨­å®š','ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼','é¸æ‰‹æ“ä½œ','è©³ç´°'].forEach((label, idx) => {
    const step = el('li', { class: `training-step${idx===0?' active':''}` });
    step.append(el('span', { class: 'training-step-number' }, String(idx+1)), el('span', {}, label));
    steps.append(step);
  });

  const controls=el("div",{class:"controls"},
    el("button",{id:"btnAutoAssign"}, el("i",{"data-lucide":"shuffle"}), "1è»/2è»ã‚’è‡ªå‹•ç·¨æˆ"),
    el("button",{id:"btnAutoPlan"}, el("i",{"data-lucide":"brain-circuit"}), "å…¨å“¡ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°è‡ªå‹•å‰²å½“"),
    el("button",{id:"btnTrainWeek", class:"primary"}, el("i",{"data-lucide":"arrow-right"}), "è‚²æˆã‚’1é€±é€²ã‚ã‚‹"),
    el("button",{id:"btnSpringCamp", style:"background-color:#166534; border-color:#14532d; color: #fff;"}, el("i",{"data-lucide":"sprout"}),"æ˜¥å­£ã‚­ãƒ£ãƒ³ãƒ—")
  );
  const topBar = el('div', { class: 'training-top' }, steps, controls);

  controls.querySelector("#btnAutoAssign").onclick=()=>{
    if(!allowed){ console.error('è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'); return; }
    autoAssignSquads(tid);
    recomputeAllRatingsAll();
    renderManagementView();
    save();
  };
  controls.querySelector("#btnAutoPlan").onclick=()=>{ if(!allowed){ console.error('è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'); return; } autoPlan(tid); renderManagementView(); };
  controls.querySelector("#btnTrainWeek").onclick=()=>{ if(!allowed){ console.error('è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'); return; } applyTrainingWeek(tid, 1, "æ‰‹å‹•é€±æ¬¡è‚²æˆ"); recomputeAllRatingsAll(); renderAll(); };
  controls.querySelector("#btnSpringCamp").onclick=()=>{ if(!allowed){ console.error('è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“'); return; }State.squads[tid].ichi.forEach(pid=>{ addWeekXP(pid, 8); }); State.squads[tid].ni.forEach(pid=>{ addWeekXP(pid, 16); }); applyTrainingWeek(tid, 5, "æ˜¥å­£ã‚­ãƒ£ãƒ³ãƒ—"); recomputeAllRatingsAll(); renderAll(); };
  if(!allowed){ controls.querySelectorAll('button').forEach(b=>{ b.disabled=true; b.title='è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“ï¼ˆã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§å¯ï¼‰'; }); }

  const policyContainer = el('div', { class: 'card', style: 'margin-bottom: 24px;' });
  const policyHeader = el('div', { class: 'card-header' }, el('h2', {}, el('i', { 'data-lucide': 'clipboard-list' }), 'ãƒãƒ¼ãƒ æ–¹é‡'));
  const policyContent = el('div', { class: 'card-content', style: 'display: flex; flex-direction: column; gap: 12px;' });

  const rosterLabel = el('label', { style: 'display:flex; justify-content: space-between; align-items: center;' }, 'æ˜‡é™æ ¼æ–¹é‡');
  const rosterSelect = el('select', { style: 'width: 180px;' });
  const rosterOptions = { 'default': 'AIç·åˆè©•ä¾¡', 'youth': 'è‹¥æ‰‹è‚²æˆé‡è¦–', 'veteran': 'ãƒ™ãƒ†ãƒ©ãƒ³é‡è¦–' };
  for (const [value, text] of Object.entries(rosterOptions)) {
      rosterSelect.append(el('option', { value, selected: strategy.roster === value }, text));
  }
  rosterSelect.onchange = () => { strategy.roster = rosterSelect.value; save(); };
  rosterLabel.append(rosterSelect);

  const lineupLabel = el('label', { style: 'display:flex; justify-content: space-between; align-items: center;' }, 'ã‚¹ã‚¿ãƒ¡ãƒ³æ–¹é‡');
  const lineupSelect = el('select', { style: 'width: 180px;' });
  const lineupOptions = { 'condition': 'ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³é‡è¦–', 'best_member': 'ãƒ™ã‚¹ãƒˆãƒ¡ãƒ³ãƒãƒ¼é‡è¦–' };
  for (const [value, text] of Object.entries(lineupOptions)) {
      lineupSelect.append(el('option', { value, selected: strategy.lineup === value }, text));
  }
  lineupSelect.onchange = () => { strategy.lineup = lineupSelect.value; save(); };
  lineupLabel.append(lineupSelect);

  if (!allowed) {
      rosterSelect.disabled = true;
      lineupSelect.disabled = true;
  }
  policyContent.append(rosterLabel, lineupLabel);
  policyContainer.append(policyHeader, policyContent);

  function focusSelect(id, isPitch, cur){ const sl=el("select",{"data-id":id,class:"focus",style:"width:100%;"}); const arr=isPitch?FOCUS_PIT:FOCUS_BAT; arr.forEach(k=>sl.append(el("option",{value:k,selected:k===cur?true:null},k))); if(!allowed){ sl.disabled=true; sl.title='è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯å¤‰æ›´ä¸å¯'; } return sl; }
  function intensSelect(id, cur){ const sl=el("select",{"data-id":id,class:"intens",style:"width:100%;"}); ["è»½","æ¨™æº–","å¼·"].forEach(k=>sl.append(el("option",{value:k,selected:k===cur?true:null},k))); if(!allowed){ sl.disabled=true; sl.title='è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯å¤‰æ›´ä¸å¯'; } return sl; }
  function boostTxt(pid){ return ((appearanceBoost(pid)-1)*100).toFixed(0)+"%"; }

  const rosterMap = new Map();
  R.bats.forEach(p=> rosterMap.set(p.id, { player:p, type:'BAT' }));
  R.pits.forEach(p=> rosterMap.set(p.id, { player:p, type:'PIT' }));

  const grouped={ ichi:{ bats:[], pits:[] }, ni:{ bats:[], pits:[] } };
  const assigned=new Set();
  ['ichi','ni'].forEach(key=>{
    (State.squads[tid][key]||[]).forEach(pid=>{
      const entry=rosterMap.get(pid);
      if(entry){
        grouped[key][entry.type==='BAT'?'bats':'pits'].push(entry.player);
        assigned.add(pid);
      }
    });
  });
  rosterMap.forEach((entry,pid)=>{
    if(!assigned.has(pid)){
      const key=ichiSet.has(pid)?'ichi':'ni';
      grouped[key][entry.type==='BAT'?'bats':'pits'].push(entry.player);
    }
  });

  ensureWeekXPLog();
  const prevSeason=(State.season||0)-1;
  function createSparklineItem(label, series, color, prev){
    const wrap=el('div',{class:'sparkline-item'});
    wrap.append(el('span',{},label), createSparklineSVG(series, color, 100, 24, prev));
    return wrap;
  }
  function createControl(labelText, inputEl, id){
    const wrap=el('div',{class:'player-card-control'});
    if(id){ inputEl.id=id; }
    const label=el('label',{for:id},labelText);
    wrap.append(label, inputEl);
    return wrap;
  }
  function createFilterControl(labelText, inputEl){
    const wrap=el('div',{class:'training-filter'});
    wrap.append(el('label',{},labelText), inputEl);
    return wrap;
  }
  const filterDefaults={ role:'all', squad:'all', focus:'all', moraleMax:100, fatigueMin:0, sort:'name' };
  if(!State.ui) State.ui={};
  if(!State.ui.trainingFilters) State.ui.trainingFilters={};
  const existingFilters=State.ui.trainingFilters[tid];
  const mergedFilters={ ...filterDefaults, ...(existingFilters||{}) };
  const moraleVal=parseInt(mergedFilters.moraleMax,10);
  const fatigueVal=parseInt(mergedFilters.fatigueMin,10);
  mergedFilters.moraleMax=Number.isFinite(moraleVal)?clamp(moraleVal,0,100):100;
  mergedFilters.fatigueMin=Number.isFinite(fatigueVal)?clamp(fatigueVal,0,100):0;
  State.ui.trainingFilters[tid]=mergedFilters;
  State.ui.trainingFiltersActiveTid=tid;
  const filters=State.ui.trainingFilters[tid];
  const focusOptions=Array.from(new Set([...FOCUS_BAT, ...FOCUS_PIT]));
  function ensurePlan(player, type){
    return tp[player.id]||(tp[player.id]={ focus:(type==='PIT'?FOCUS_PIT:FOCUS_BAT)[0], intens:'æ¨™æº–' });
  }
  function createConditionBadge(kind, value){
    if(value===undefined || value===null) return null;
    if(kind==='fatigue'){
      if(value>=90) return el('span',{class:'condition-badge danger', title:'æ¥µåº¦ã®ç–²åŠ´: æ€ªæˆ‘ãƒªã‚¹ã‚¯ãŒé«˜ã¾ã‚Šã¾ã™'},`ç–²åŠ´ ${value}`);
      if(value>=75) return el('span',{class:'condition-badge warn', title:'ç–²åŠ´ãŒè“„ç©ã—ã¦ã„ã¾ã™ã€‚èª¿æ•´ã‚’æ¤œè¨Žã—ã¦ãã ã•ã„'},`ç–²åŠ´ ${value}`);
      return null;
    }
    if(kind==='morale'){
      if(value<=30) return el('span',{class:'condition-badge danger', title:'å£«æ°—ä½Žä¸‹: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹ã«æ‚ªå½±éŸ¿ãŒå‡ºã¦ã„ã¾ã™'},`å£«æ°— ${value}`);
      if(value<=45) return el('span',{class:'condition-badge warn', title:'å£«æ°—ãŒè½ã¡ã¦ã„ã¾ã™ã€‚èµ·ç”¨ã‚„ã‚±ã‚¢ã‚’å†æ¤œè¨Žã—ã¾ã—ã‚‡ã†'},`å£«æ°— ${value}`);
      return null;
    }
    return null;
  }
  function computeProgress(player, plan){
    const xp=State.weekXP[player.id]||0;
    const intensityValue=INTENS[plan.intens]||1;
    const xpGoal=Math.max(1, Math.round(20*intensityValue));
    const xpProgress=clamp(xp/xpGoal,0,1);
    const boost=appearanceBoost(player.id);
    const boostProgress=clamp((boost-1)/0.2,0,1);
    const intensityProgress=clamp((intensityValue-0.7)/0.6,0,1);
    const score=clamp((xpProgress*0.5)+(boostProgress*0.3)+(intensityProgress*0.2),0,1);
    const percent=clamp(Math.round(score*100),0,100);
    const series=getWeekXPSeries(player.id).slice(-WEEK_XP_LOG_WINDOW);
    return { xp, xpGoal, boost, percent, score, xpSeries:series, focus:plan.focus, intensity:plan.intens, intensityValue };
  }
  function createPlayerCard(player, type, squadKey, plan, progress){
    const card=el('article',{class:`player-card${player.injury?' injured':''}`});
    const header=el('div',{class:'player-card-header'});
    const title=el('div',{class:'player-card-title'});
    let statusIcon='';
    if(player.injury) statusIcon='ðŸ©¹';
    else if(player.status?.hot>0) statusIcon='ðŸ”¥';
    else if(player.status?.slump>0) statusIcon='â„ï¸';
    const nameBtn=el('button',{class:'player-name-button', html:`${statusIcon} ${player.name}`});
    nameBtn.onclick=()=>showPlayerDetailModal(player.id, tid);
    title.append(nameBtn);
    if(player.recentGains && player.recentGains.length>0){
      const statGain=player.recentGains.find(g=>/^[A-Za-z]+\+\d+$/.test(g));
      if(statGain){
        const [stat,val]=statGain.split('+');
        title.append(el('span',{class:'pill', style:'font-size:9px; padding:1px 4px; background:var(--good); color:#fff; border:none; font-weight:700; align-self:flex-start;'}, `${stat.slice(0,3)} +${val}`));
      }
    }
    header.append(title);
    const roleText= type==='BAT' ? (player.pos||'') : (player.role==='SP'?'SP':(player.sub_role||player.role||''));
    if(roleText){ header.append(el('span',{class:'player-card-role'}, roleText)); }
    card.append(header);

    const meta=el('div',{class:'player-card-meta'});
    const prevHistory=State.historicalStats?.[prevSeason]?.[player.id]?.history||{};
    const sparkWrap=el('div',{class:'sparkline-pair'});
    if(player.history?.morale){ sparkWrap.append(createSparklineItem('å£«æ°—', player.history.morale, 'var(--accent)', prevHistory.morale)); }
    if(player.history?.fatigue){ sparkWrap.append(createSparklineItem('ç–²åŠ´', player.history.fatigue, 'var(--warn)', prevHistory.fatigue)); }
    if(sparkWrap.children.length>0) meta.append(sparkWrap);
    meta.append(el('span',{class:'boost-chip'},`å®Ÿæˆ¦è£œæ­£ ${boostTxt(player.id)}`));
    const fatigueBadge=createConditionBadge('fatigue', player.fatigue);
    const moraleBadge=createConditionBadge('morale', player.morale);
    if(fatigueBadge) meta.append(fatigueBadge);
    if(moraleBadge) meta.append(moraleBadge);
    card.append(meta);

    const controlsRow=el('div',{class:'player-card-controls'});
    const squadCurrent=squadKey==='ichi'?'ä¸€è»':'äºŒè»';
    const squadSel=squadSelect(tid, player.id, squadCurrent);
    squadSel.style.width='100%';
    const focusSel=focusSelect(player.id, type==='PIT', plan.focus);
    const intensSel=intensSelect(player.id, plan.intens);
    const squadId=`squad-${player.id}`;
    const focusId=`focus-${player.id}`;
    const intensId=`intens-${player.id}`;
    controlsRow.append(
      createControl('æ‰€å±ž', squadSel, squadId),
      createControl('ç„¦ç‚¹', focusSel, focusId),
      createControl('å¼·åº¦', intensSel, intensId)
    );
    card.append(controlsRow);

    if(allowed){
      focusSel.onchange=()=>{ plan.focus=focusSel.value; State.trainingPlans[tid]=tp; save(); rebuildSections(); };
      intensSel.onchange=()=>{ plan.intens=intensSel.value; State.trainingPlans[tid]=tp; save(); rebuildSections(); };
    }

    const progressBlock=el('div',{class:'training-progress-block'});
    const headerLine=el('div',{class:'training-progress-header'});
    headerLine.append(el('span',{},`é€²æ— ${progress.percent}%`), el('span',{},`XP ${progress.xp}/${progress.xpGoal}`));
    progressBlock.append(headerLine);
    progressBlock.append(el('div',{class:'training-progress-bar'}, el('span',{style:`width:${progress.percent}%`})));
    const metaLine=el('div',{class:'training-progress-meta'});
    metaLine.append(
      el('span',{},`ç„¦ç‚¹ ${plan.focus}`),
      el('span',{},`å¼·åº¦ ${plan.intens}`),
      el('span',{},`å®Ÿæˆ¦è£œæ­£ +${Math.round((progress.boost-1)*100)}%`)
    );
    progressBlock.append(metaLine);
    const xpSeries=progress.xpSeries.length>=2?progress.xpSeries:(progress.xpSeries.length===1?[progress.xpSeries[0],progress.xpSeries[0]]:[]);
    if(xpSeries.length>=2){
      progressBlock.append(el('div',{class:'training-progress-spark'}, el('span',{},'æœ€è¿‘XP'), createSparklineSVG(xpSeries,'var(--primary)',140,32)));
    }
    card.append(progressBlock);

    const actions=el('div',{class:'player-card-actions'});
    const detailBtn=el('button',{class:'ghost'}, el('i',{'data-lucide':'user-round'}),'è©³ç´°');
    detailBtn.onclick=()=>showPlayerDetailModal(player.id, tid);
    const trainBtn=el('button',{class:'ghost'}, el('i',{'data-lucide':'flame'}),'ç‰¹è¨“(5)');
    if(!allowed || player.injury){
      trainBtn.disabled=true;
      trainBtn.title= player.injury ? 'æ€ªæˆ‘ã®ãŸã‚ä¸å¯' : 'è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“';
    }else{
      trainBtn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevPä¸è¶³'); return; } doSpecialTraining(tid, player.id); };
    }
    actions.append(detailBtn, trainBtn);
    card.append(actions);

    return card;
  }
  function passesFilters(player, type, squadKey, plan){
    if(filters.role==='BAT' && type!=='BAT') return false;
    if(filters.role==='PIT' && type!=='PIT') return false;
    if(filters.squad!=='all' && filters.squad!==squadKey) return false;
    if(filters.focus!=='all' && plan.focus!==filters.focus) return false;
    const morale=player.morale??60;
    const fatigue=player.fatigue??0;
    if(filters.moraleMax<100 && morale>filters.moraleMax) return false;
    if(filters.fatigueMin>0 && fatigue<filters.fatigueMin) return false;
    return true;
  }
  const intensityOrder={ 'è»½':0,'æ¨™æº–':1,'å¼·':2 };
  function compareEntries(a,b){
    const mode=filters.sort||'name';
    if(mode==='progress'){
      if(b.progress.score!==a.progress.score) return b.progress.score-a.progress.score;
    }else if(mode==='focus'){
      const cmp=a.plan.focus.localeCompare(b.plan.focus,'ja');
      if(cmp!==0) return cmp;
    }else if(mode==='intensity'){
      const diff=(intensityOrder[b.plan.intens]??0)-(intensityOrder[a.plan.intens]??0);
      if(diff!==0) return diff;
    }
    return a.player.name.localeCompare(b.player.name,'ja');
  }
  function prepareEntries(players, type, squadKey){
    const entries=[];
    players.forEach(player=>{
      const plan=ensurePlan(player, type);
      if(!passesFilters(player, type, squadKey, plan)) return;
      const progress=computeProgress(player, plan);
      entries.push({ player, type, plan, progress });
    });
    entries.sort(compareEntries);
    return entries;
  }
  function createRoleGroup(label, entries, squadKey, roleKey, roleState){
    const group=el('details',{class:'training-role-group'});
    group.dataset.role=roleKey;
    const stateKey=`${squadKey}:${roleKey}`;
    const previous=roleState?.get(stateKey);
    group.open=previous!==undefined?previous:entries.length>0;
    const summary=el('summary',{},
      el('span',{},label),
      el('span',{class:'mini'},`${entries.length}äºº`),
      el('span',{class:'summary-icon'}, el('i',{'data-lucide':'chevron-down'}))
    );
    group.append(summary);
    if(entries.length===0){
      group.append(el('div',{class:'training-empty'},`ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã«ä¸€è‡´ã™ã‚‹${label}ãŒã„ã¾ã›ã‚“ã€‚`));
    }else{
      const grid=el('div',{class:'player-card-grid'});
      entries.forEach(entry=>{ grid.append(createPlayerCard(entry.player, entry.type, squadKey, entry.plan, entry.progress)); });
      group.append(grid);
    }
    return group;
  }
  const filterBar=el('div',{class:'training-filter-bar'});
  const disabledHint='è‡ªãƒãƒ¼ãƒ ä»¥å¤–ã¯é–²è¦§ã®ã¿ã§ã™ï¼ˆã‚³ãƒŸãƒƒã‚·ãƒ§ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§å¯ï¼‰';
  function persistFilters(){ save(); rebuildSections(); }
  const roleSelect=el('select',{});
  [['all','å…¨ã¦'],['BAT','é‡Žæ‰‹'],['PIT','æŠ•æ‰‹']].forEach(([value,text])=>{
    roleSelect.append(el('option',{value, selected:filters.role===value},text));
  });
  if(allowed){ roleSelect.onchange=()=>{ filters.role=roleSelect.value; persistFilters(); }; } else { roleSelect.disabled=true; roleSelect.title=disabledHint; }
  const squadFilter=el('select',{});
  [['all','å…¨ã¦'],['ichi','ä¸€è»'],['ni','äºŒè»']].forEach(([value,text])=>{
    squadFilter.append(el('option',{value, selected:filters.squad===value},text));
  });
  if(allowed){ squadFilter.onchange=()=>{ filters.squad=squadFilter.value; persistFilters(); }; } else { squadFilter.disabled=true; squadFilter.title=disabledHint; }
  const focusFilter=el('select',{});
  focusFilter.append(el('option',{value:'all', selected:filters.focus==='all'},'å…¨ã¦'));
  focusOptions.forEach(opt=>{ focusFilter.append(el('option',{value:opt, selected:filters.focus===opt}, opt)); });
  if(allowed){ focusFilter.onchange=()=>{ filters.focus=focusFilter.value; persistFilters(); }; } else { focusFilter.disabled=true; focusFilter.title=disabledHint; }
  const moraleInput=el('input',{type:'number', min:0, max:100, step:5, value:filters.moraleMax});
  moraleInput.placeholder='100';
  if(allowed){ moraleInput.onchange=()=>{ const val=parseInt(moraleInput.value,10); filters.moraleMax=Number.isFinite(val)?clamp(val,0,100):100; moraleInput.value=filters.moraleMax; persistFilters(); }; } else { moraleInput.disabled=true; moraleInput.title=disabledHint; }
  const fatigueInput=el('input',{type:'number', min:0, max:100, step:5, value:filters.fatigueMin});
  fatigueInput.placeholder='0';
  if(allowed){ fatigueInput.onchange=()=>{ const val=parseInt(fatigueInput.value,10); filters.fatigueMin=Number.isFinite(val)?clamp(val,0,100):0; fatigueInput.value=filters.fatigueMin; persistFilters(); }; } else { fatigueInput.disabled=true; fatigueInput.title=disabledHint; }
  const sortSelect=el('select',{});
  [['name','åå‰é †'],['focus','ç„¦ç‚¹é †'],['intensity','å¼·åº¦é †'],['progress','é€²æ—é †']].forEach(([value,text])=>{
    sortSelect.append(el('option',{value, selected:filters.sort===value},text));
  });
  if(allowed){ sortSelect.onchange=()=>{ filters.sort=sortSelect.value; persistFilters(); }; } else { sortSelect.disabled=true; sortSelect.title=disabledHint; }
  filterBar.append(
    createFilterControl('å½¹å‰²', roleSelect),
    createFilterControl('æ‰€å±ž', squadFilter),
    createFilterControl('ç„¦ç‚¹', focusFilter),
    createFilterControl('å£«æ°—â‰¦', moraleInput),
    createFilterControl('ç–²åŠ´â‰§', fatigueInput),
    createFilterControl('ä¸¦ã³æ›¿ãˆ', sortSelect)
  );

  const sections=el('div',{class:'training-sections'});
  function rebuildSections(){
    const sectionState=new Map();
    const roleState=new Map();
    sections.querySelectorAll('.training-section').forEach(section=>{
      const key=section.dataset.key;
      sectionState.set(key, section.open);
      section.querySelectorAll('.training-role-group').forEach(group=>{
        roleState.set(`${key}:${group.dataset.role}`, group.open);
      });
    });
    sections.innerHTML='';
    [
      { key:'ichi', label:'ä¸€è»' },
      { key:'ni', label:'äºŒè»' }
    ].forEach(cfg=>{
      const baseBats=grouped[cfg.key].bats;
      const basePits=grouped[cfg.key].pits;
      const batEntries=prepareEntries(baseBats, 'BAT', cfg.key);
      const pitEntries=prepareEntries(basePits, 'PIT', cfg.key);
      const baseTotal=baseBats.length+basePits.length;
      const filteredTotal=batEntries.length+pitEntries.length;
      const section=el('details',{class:'training-section'});
      section.dataset.key=cfg.key;
      section.open=sectionState.has(cfg.key)?sectionState.get(cfg.key):(cfg.key==='ichi');
      const summary=el('summary',{},
        el('span',{},cfg.label),
        el('span',{class:'mini'},`${filteredTotal}/${baseTotal}äºº`),
        el('span',{class:'summary-icon'}, el('i',{'data-lucide':'chevron-down'}))
      );
      section.append(summary);
      const body=el('div',{class:'training-section-body'});
      body.append(
        createRoleGroup('é‡Žæ‰‹', batEntries, cfg.key, 'bats', roleState),
        createRoleGroup('æŠ•æ‰‹', pitEntries, cfg.key, 'pits', roleState)
      );
      section.append(body);
      sections.append(section);
    });
    setTimeout(refreshIcons,0);
  }

  rebuildSections();

  frag.append(topBar, policyContainer, filterBar, sections, el("div",{class:"mini",style:"margin-top:8px;"}, "å®Ÿæˆ¦è£œæ­£ = å‡ºå ´æ•°ã«å¿œã˜æœ€å¤§+20%ï¼ˆ1è»ã¯1è©¦åˆ=+4ptæ›ç®— / 2è»ã¯é€±ã‚ãŸã‚Š+12ptæ›ç®—ï¼‰"));
  return frag;
}


function renderReportView(){ const frag=document.createDocumentFragment();
  // Summary box
  const box=el("div",{class:"controls",style:"margin-bottom:8px;gap:16px;flex-wrap:wrap;"});
  const topGainers=collectTopGainers(12); // last ~100 logs already
  box.append(el("span",{class:"pill"},`ç›´è¿‘ã®è‚²æˆã‚¤ãƒ™ãƒ³ãƒˆ: ${topGainers.events}`), el("span",{class:"pill"},`ç›´è¿‘ã®ä¼¸ã³æœ€å¤§: ${topGainers.max}`));
  frag.append(box);
  const tbl=el("table",{}, el("thead",{}, el("tr",{}, el("th",{},"ãƒ­ã‚°ï¼ˆæœ€æ–°100ä»¶ï¼‰"))), el("tbody"));
  (State.devLogs||[]).slice(-100).toReversed().forEach(m=> tbl.lastChild.append(el("tr",{}, el("td",{style:"font-size:13px;text-align:left;white-space:normal;"}, m))));
  frag.append(el("div",{class:"table-scroll"},tbl));
  return frag;
}
function collectTopGainers(n){ const arr=(State.devLogs||[]).slice(-150); let events=0, maxGain="-"; for(const s of arr){ if(s.includes("ç‰¹è¨“")||s.includes("é–‹çœ¼")||s.includes("ãƒ•ã‚©ãƒ¼ãƒ å´©ã‚Œ")) events++; const m=s.match(/([A-Za-zã-ã‚“ã‚¡-ãƒ³ä¸€-é¾¥ã€…]+)(\+\d+)/); if(m){ if(maxGain==="-"|| parseInt(m[2].slice(1))>parseInt(maxGain.slice(1))) maxGain=m[2]; } } return {events, max:maxGain}; }

// ====== Stats View (Enhanced) ======
function ensureStatsViewState(tid){
  if(!State.ui) State.ui={};
  if(!State.ui.statsView) State.ui.statsView={};
  if(!State.ui.statsView[tid]){
    State.ui.statsView[tid]={ tab:'overview', period:'total', selected:[null,null] };
  }
  const view=State.ui.statsView[tid];
  view.tab=view.tab||'overview';
  view.period=view.period||'total';
  if(!Array.isArray(view.selected)) view.selected=[null,null];
  view.selected=view.selected.slice(0,2);
  while(view.selected.length<2) view.selected.push(null);
  if(view.selected[0] && view.selected[1] && view.selected[0]===view.selected[1]) view.selected[1]=null;
  return view;
}

function filterLogsByPeriod(logs, period){
  if(!Array.isArray(logs) || logs.length===0) return [];
  if(period==='recent') return logs.slice(-10);
  if(period==='month'){
    const currDay=State.curr_day||1;
    const currentMonth=Math.floor((currDay-1)/30);
    return logs.filter(log=>{
      if(!log || typeof log.day!=='number') return false;
      return Math.floor((log.day-1)/30)===currentMonth;
    });
  }
  return logs;
}

function ipToOuts(ip){
  if(!Number.isFinite(ip)) return 0;
  const whole=Math.trunc(ip);
  const decimal=Math.round((ip-whole)*10);
  return whole*3 + Math.max(0, Math.min(2, decimal));
}

function outsToIP(outs){
  if(!Number.isFinite(outs) || outs<=0) return 0;
  const whole=Math.floor(outs/3);
  const remainder=outs%3;
  return whole + remainder/10;
}

function aggregateBatterLogs(logs){
  const totals={ games:0, ab:0, h:0, hr:0, bb:0, so:0, r:0, rbi:0 };
  if(!Array.isArray(logs)) return { ...totals, pa:0 };
  for(const log of logs){
    if(!log) continue;
    totals.games++;
    totals.ab += log.AB||0;
    totals.h += log.H||0;
    totals.hr += log.HR||0;
    totals.bb += log.BB||0;
    totals.so += log.SO||0;
    totals.r += log.R||0;
    totals.rbi += log.RBI||0;
  }
  totals.pa=totals.ab+totals.bb;
  return totals;
}

function aggregatePitcherLogs(logs){
  const totals={ games:0, outs:0, er:0, hr:0, bb:0, so:0, h:0, wins:0, losses:0, saves:0 };
  if(!Array.isArray(logs)) return { ...totals, ip:0 };
  for(const log of logs){
    if(!log) continue;
    totals.games++;
    totals.outs += ipToOuts(log.IP||0);
    totals.er += log.ER||0;
    totals.hr += log.HR||0;
    totals.bb += log.BB||0;
    totals.so += log.SO||0;
    totals.h += log.H||0;
    totals.wins += log.W||0;
    totals.losses += log.L||0;
    totals.saves += log.SV||0;
  }
  totals.ip=outsToIP(totals.outs);
  return totals;
}

function computeBatterRates(totals){
  const singles=Math.max(0,(totals.h||0)-(totals.hr||0));
  const obpDen=(totals.ab||0)+(totals.bb||0);
  const obp=obpDen>0?((totals.h||0)+(totals.bb||0))/obpDen:0;
  const slgDen=totals.ab||0;
  const slg=slgDen>0?(singles+(totals.hr||0)*4)/slgDen:0;
  const ops=obp+slg;
  const avgDen=totals.ab||0;
  const avg=avgDen>0?(totals.h||0)/avgDen:0;
  return { avg, obp, slg, ops };
}

function ensureLeagueMetrics(){
  if(!State.cachedMetrics) State.cachedMetrics={};
  const key=`season-${State.season||1}`;
  const day=State.curr_day||1;
  const resultCount=(State.results||[]).length;
  const cached=State.cachedMetrics[key];
  if(cached && cached.day===day && cached.resultCount===resultCount) return cached;
  let batNumer=0, batDenom=0, batPA=0, totalRuns=0;
  let leagueHR=0, leagueBB=0, leagueSO=0, leagueOuts=0, leagueER=0, leagueHits=0;
  const logsObj=State.playerGameLogs||{};
  for(const logs of Object.values(logsObj)){
    if(!Array.isArray(logs)) continue;
    for(const log of logs){
      if(!log) continue;
      const ab=log.AB||0;
      const h=log.H||0;
      const hr=log.HR||0;
      const bb=log.BB||0;
      const singles=Math.max(0,h-hr);
      const pa=ab+bb;
      batNumer += 0.69*bb + 0.89*singles + 2.1*hr;
      batDenom += pa;
      batPA += pa;
      totalRuns += log.R||0;
      if(log.IP!=null || log.ER!=null){
        leagueOuts += ipToOuts(log.IP||0);
        leagueER += log.ER||0;
        leagueHits += log.H||0;
        leagueHR += log.HR||0;
        leagueBB += log.BB||0;
        leagueSO += log.SO||0;
      }
    }
  }
  if(totalRuns<=0){
    totalRuns=(State.results||[]).reduce((sum,res)=>sum+(res.home_runs||0)+(res.away_runs||0),0);
  }
  const leagueWoba=batDenom>0?batNumer/batDenom:0;
  const runsPerPA=batPA>0?totalRuns/batPA:0.12;
  const ip=leagueOuts/3;
  const leagueERA=ip>0?(leagueER*9)/ip:0;
  const denom=ip>0?ip:1;
  const fipConst=denom>0?leagueERA-((13*leagueHR+3*leagueBB-2*leagueSO)/denom):0;
  const metrics={
    day,
    resultCount,
    batting:{ woba:leagueWoba, wobaScale:1.15, runsPerPA:runsPerPA||0.12 },
    pitching:{ fipConst, era:leagueERA }
  };
  State.cachedMetrics[key]=metrics;
  return metrics;
}

function computeAdvancedBattingMetrics(totals, league){
  const rates=computeBatterRates(totals);
  const singles=Math.max(0,(totals.h||0)-(totals.hr||0));
  const numerator=0.69*(totals.bb||0)+0.89*singles+2.1*(totals.hr||0);
  const denom=totals.pa||0;
  const woba=denom>0?numerator/denom:0;
  const leagueRef=league||{ woba:0, wobaScale:1.15, runsPerPA:0.12 };
  const wobaScale=leagueRef.wobaScale||1.15;
  const leagueRuns=leagueRef.runsPerPA>0?leagueRef.runsPerPA:0.12;
  const wRCPlus=leagueRuns>0?(((woba-(leagueRef.woba||0))/wobaScale)+leagueRuns)/leagueRuns*100:0;
  return { ...rates, woba, wrcPlus:Number.isFinite(wRCPlus)?wRCPlus:0 };
}

function computeAdvancedPitchingMetrics(totals, league){
  const ip=totals.outs/3;
  const era=ip>0?(totals.er*9)/ip:null;
  const whip=ip>0?((totals.bb+totals.h)/ip):null;
  const fip=ip>0?((13*totals.hr+3*totals.bb-2*totals.so)/ip)+((league&&league.fipConst)||0):null;
  const kbb=totals.bb>0?totals.so/totals.bb:(totals.so>0?Infinity:null);
  const k9=ip>0?(totals.so*9)/ip:null;
  const bb9=ip>0?(totals.bb*9)/ip:null;
  return { era, whip, fip, kbb, k9, bb9, ip, games:totals.games, wins:totals.wins, losses:totals.losses, saves:totals.saves };
}

function computeRollingSeries(logs, windowSize, reducer){
  if(!Array.isArray(logs) || logs.length===0) return { series:[], labels:[] };
  const series=[], labels=[];
  for(let i=0;i<logs.length;i++){
    const slice=logs.slice(Math.max(0,i-windowSize+1), i+1);
    const value=reducer(slice);
    series.push(Number.isFinite(value)?value:0);
    const day=logs[i]?.day;
    labels.push(day!=null?`Day ${day}`:`#${i+1}`);
  }
  return { series, labels };
}

function createSparklineWithTooltip(data, labels, color, width=160, height=32, formatter=(v)=>v.toFixed(2)){
  if(!Array.isArray(data) || data.length<2) return el('span',{class:'mini', style:'color:var(--text-secondary);'},'ãƒ‡ãƒ¼ã‚¿ä¸è¶³');
  const valid=data.map(v=>Number.isFinite(v)?v:0);
  const wrap=el('div',{class:'sparkline-hover'});
  const svg=createSparklineSVG(valid, color, width, height);
  const tooltip=el('div',{class:'sparkline-tooltip'});
  wrap.append(svg, tooltip);
  attachSparklineTooltip(wrap, valid, labels, formatter);
  return wrap;
}

function attachSparklineTooltip(wrapper, data, labels, formatter){
  const tooltip=wrapper.querySelector('.sparkline-tooltip');
  if(!tooltip) return;
  wrapper.addEventListener('mousemove',ev=>{
    const rect=wrapper.getBoundingClientRect();
    if(rect.width<=0) return;
    let ratio=(ev.clientX-rect.left)/rect.width;
    ratio=Math.max(0, Math.min(1, ratio));
    const idx=Math.min(data.length-1, Math.round(ratio*(data.length-1)));
    const label=labels && labels[idx]?labels[idx]:`#${idx+1}`;
    tooltip.textContent=`${label}: ${formatter(data[idx])}`;
    tooltip.style.left=`${ratio*100}%`;
    tooltip.style.opacity=1;
  });
  wrapper.addEventListener('mouseleave',()=>{ tooltip.style.opacity=0; });
}

function resolvePitcherHand(entry, tid){
  if(!entry) return null;
  const player=findPlayerById(tid, entry.id);
  return player?.hand||null;
}

function computeLineupHandRatio(list, tid){
  if(!Array.isArray(list) || !tid) return 0.5;
  let left=0,total=0;
  for(const entry of list){
    const player=findPlayerById(tid, entry?.id);
    const hand=player?.hand||'R';
    if(hand==='L') left++;
    total++;
  }
  if(total===0) return 0.5;
  return left/total;
}

function buildGameMetaMap(){
  const map=new Map();
  const results=State.results||[];
  for(const res of results){
    if(!res) continue;
    const detail=res.detailed||null;
    const homeLineup=detail?.lineups?.away;
    const awayLineup=detail?.lineups?.home;
    map.set(`${res.day}-${res.home_id}`,{
      location:'home',
      opponentId:res.away_id,
      starterHand:resolvePitcherHand(homeLineup?.pitchers?.[0], res.away_id),
      lineupHandRatio:computeLineupHandRatio(homeLineup?.batting, res.away_id)
    });
    map.set(`${res.day}-${res.away_id}`,{
      location:'away',
      opponentId:res.home_id,
      starterHand:resolvePitcherHand(awayLineup?.pitchers?.[0], res.home_id),
      lineupHandRatio:computeLineupHandRatio(awayLineup?.batting, res.home_id)
    });
  }
  return map;
}

function accumulateBatterSplit(target, entry){
  target.games=(target.games||0)+1;
  target.ab=(target.ab||0)+entry.ab;
  target.h=(target.h||0)+entry.h;
  target.hr=(target.hr||0)+entry.hr;
  target.bb=(target.bb||0)+entry.bb;
}

function computeBatterSplits(logs, metaMap, tid){
  const makeSplit=()=>({ games:0, ab:0, h:0, hr:0, bb:0, pa:0 });
  const splits={ vsLeft:makeSplit(), vsRight:makeSplit(), home:makeSplit(), away:makeSplit() };
  if(!Array.isArray(logs)) return splits;
  for(const log of logs){
    if(!log) continue;
    const meta=metaMap.get(`${log.day}-${tid}`);
    if(!meta) continue;
    const entry={ ab:log.AB||0, h:log.H||0, hr:log.HR||0, bb:log.BB||0 };
    if(meta.starterHand){
      const key=meta.starterHand==='L'?'vsLeft':'vsRight';
      accumulateBatterSplit(splits[key], entry);
    }
    const locKey=meta.location==='home'?'home':'away';
    accumulateBatterSplit(splits[locKey], entry);
  }
  const result={};
  Object.entries(splits).forEach(([key,tot])=>{
    tot.pa=(tot.ab||0)+(tot.bb||0);
    const rates=computeBatterRates({ ...tot, pa:tot.pa, games:tot.games, hr:tot.hr, h:tot.h, bb:tot.bb, ab:tot.ab, so:0, r:0, rbi:0 });
    result[key]={ totals:tot, metrics:rates };
  });
  return result;
}

function accumulatePitcherSplit(target, entry){
  target.games=(target.games||0)+1;
  target.outs=(target.outs||0)+entry.outs;
  target.er=(target.er||0)+entry.er;
  target.hr=(target.hr||0)+entry.hr;
  target.bb=(target.bb||0)+entry.bb;
  target.so=(target.so||0)+entry.so;
  target.h=(target.h||0)+entry.h;
}

function computePitcherSplits(logs, metaMap, tid, league){
  const makeSplit=()=>({ games:0, outs:0, er:0, hr:0, bb:0, so:0, h:0 });
  const splits={ vsLeft:makeSplit(), vsRight:makeSplit(), home:makeSplit(), away:makeSplit() };
  if(!Array.isArray(logs)) return splits;
  const leagueRef=league||ensureLeagueMetrics().pitching;
  for(const log of logs){
    if(!log) continue;
    const meta=metaMap.get(`${log.day}-${tid}`);
    if(!meta) continue;
    const entry={ outs:ipToOuts(log.IP||0), er:log.ER||0, hr:log.HR||0, bb:log.BB||0, so:log.SO||0, h:log.H||0 };
    const vsKey=(meta.lineupHandRatio||0.5)>=0.5?'vsLeft':'vsRight';
    accumulatePitcherSplit(splits[vsKey], entry);
    const locKey=meta.location==='home'?'home':'away';
    accumulatePitcherSplit(splits[locKey], entry);
  }
  const result={};
  Object.entries(splits).forEach(([key,tot])=>{
    const totals={ outs:tot.outs, er:tot.er, hr:tot.hr, bb:tot.bb, so:tot.so, h:tot.h, games:tot.games, wins:0, losses:0, saves:0 };
    result[key]={ totals:tot, metrics:computeAdvancedPitchingMetrics(totals, leagueRef) };
  });
  return result;
}

function formatAverage(value){
  if(!Number.isFinite(value) || value<0) return '.---';
  return value.toFixed(3).substring(1);
}

function formatRate(value){
  if(!Number.isFinite(value)) return '-';
  return value.toFixed(3);
}

function formatNumber(value, decimals=1){
  if(!Number.isFinite(value)) return '-';
  return value.toFixed(decimals);
}

function formatERA(value){
  if(!Number.isFinite(value)) return '-.--';
  return value.toFixed(2);
}

function formatSignedNumber(value, decimals=1){
  if(!Number.isFinite(value)) return '-';
  const fixed=value.toFixed(decimals);
  if(Number(fixed)===0) return decimals>0?`0.${'0'.repeat(decimals)}`:'0';
  return value>0?`+${fixed}`:fixed;
}

function createStatsTableWrapper(icon, title, table){
  const wrapper=el('div',{class:'stats-table-wrapper'});
  wrapper.append(el('div',{class:'table-header'}, el('i',{ 'data-lucide':icon, class:'mini-icon'}), title));
  const body=el('div',{class:'table-body'});
  body.append(table);
  wrapper.append(body);
  return wrapper;
}

function renderStatsView(tid){
  const frag=document.createDocumentFragment();
  const roster=State.rosters[tid]||{ bats:[], pits:[] };
  const viewState=ensureStatsViewState(tid);
  const leagueMetrics=ensureLeagueMetrics();
  const gameMeta=buildGameMetaMap();
  const tabConfigs=[
    { key:'overview', label:'æ¦‚è¦', icon:'layout-dashboard' },
    { key:'trend', label:'ãƒˆãƒ¬ãƒ³ãƒ‰', icon:'activity' },
    { key:'advanced', label:'é«˜åº¦æŒ‡æ¨™', icon:'radar' },
    { key:'compare', label:'æ¯”è¼ƒ', icon:'users' }
  ];
  const tabBar=el('div',{class:'stats-tab-bar'});
  const tabButtons=new Map();
  tabConfigs.forEach(cfg=>{
    const btn=el('button',{class:`stats-tab ${viewState.tab===cfg.key?'active':''}`, 'data-tab':cfg.key}, el('i',{ 'data-lucide':cfg.icon, class:'mini-icon'}), cfg.label);
    btn.onclick=()=>{
      if(viewState.tab===cfg.key) return;
      viewState.tab=cfg.key;
      State.ui.statsView[tid]=viewState;
      save();
      setActiveTab(cfg.key);
    };
    tabButtons.set(cfg.key, btn);
    tabBar.append(btn);
  });

  const panels={
    overview:el('div',{class:'stats-panel'}),
    trend:el('div',{class:'stats-panel'}),
    advanced:el('div',{class:'stats-panel'}),
    compare:el('div',{class:'stats-panel'})
  };
  const panelHost=el('div',{class:'stats-panels'}, panels.overview, panels.trend, panels.advanced, panels.compare);
  frag.append(tabBar, panelHost);

  const renderers={
    overview:()=>{
      const panel=panels.overview;
      panel.innerHTML='';
      const periods={ total:'ã‚·ãƒ¼ã‚ºãƒ³ç´¯è¨ˆ', recent:'ç›´è¿‘10è©¦åˆ', month:'æœˆé–“' };
      const periodBar=el('div',{class:'stats-period-filter'});
      periodBar.append(el('span',{class:'mini'},'æœŸé–“é¸æŠž'));
      Object.entries(periods).forEach(([key,label])=>{
        const btn=el('button',{class:viewState.period===key?'active':''},label);
        btn.onclick=()=>{
          if(viewState.period===key) return;
          viewState.period=key;
          State.ui.statsView[tid]=viewState;
          save();
          renderers.overview();
        };
        periodBar.append(btn);
      });
      panel.append(periodBar);

      const batterRows=roster.bats.map(player=>{
        const logs=filterLogsByPeriod(State.playerGameLogs[player.id]||[], viewState.period);
        const totals=aggregateBatterLogs(logs);
        const rates=computeBatterRates(totals);
        return { player, totals, rates };
      }).sort((a,b)=> (b.totals.pa||0)-(a.totals.pa||0) || a.player.name.localeCompare(b.player.name));

      const batTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'G'),
          el('th',{},'æ‰“çŽ‡'),
          el('th',{class:'col-secondary'},'HR'),
          el('th',{class:'col-secondary'},'æ‰“ç‚¹'),
          el('th',{},'OPS')
        )),
        el('tbody')
      );
      batterRows.forEach(row=>{
        const { player, totals, rates }=row;
        const AVG=totals.ab>0?formatAverage(rates.avg):'.---';
        const OPS=totals.pa>0?formatRate(rates.ops):'-';
        batTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, totals.games||0),
          el('td',{}, AVG),
          el('td',{class:'col-secondary'}, totals.hr||0),
          el('td',{class:'col-secondary'}, totals.rbi||0),
          el('td',{}, OPS)
        ));
      });
      panel.append(createStatsTableWrapper('users','é‡Žæ‰‹æ¦‚è¦', batTable));

      const pitcherRows=roster.pits.map(player=>{
        const logs=filterLogsByPeriod(State.playerGameLogs[player.id]||[], viewState.period);
        const totals=aggregatePitcherLogs(logs);
        const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
        return { player, totals, metrics };
      }).sort((a,b)=> (b.totals.outs||0)-(a.totals.outs||0) || a.player.name.localeCompare(b.player.name));

      const pitTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'W-L-SV'),
          el('th',{},'G'),
          el('th',{},'IP'),
          el('th',{},'ERA'),
          el('th',{class:'col-secondary'},'K/BB')
        )),
        el('tbody')
      );
      pitcherRows.forEach(row=>{
        const { player, totals, metrics }=row;
        const ip=totals.ip?totals.ip.toFixed(1):'0.0';
        const era=(metrics.era!=null)?formatERA(metrics.era):'-.--';
        let kbb='0.00';
        if(metrics.kbb===Infinity) kbb='âˆž';
        else if(metrics.kbb!=null) kbb=formatNumber(metrics.kbb,2);
        pitTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{},`${totals.wins||0}-${totals.losses||0}-${totals.saves||0}`),
          el('td',{}, totals.games||0),
          el('td',{}, ip),
          el('td',{}, era),
          el('td',{class:'col-secondary'}, kbb)
        ));
      });
      panel.append(createStatsTableWrapper('flame','æŠ•æ‰‹æ¦‚è¦', pitTable));
      setTimeout(refreshIcons,0);
    },
    trend:()=>{
      const panel=panels.trend;
      panel.innerHTML='';
      const batterSectionTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'activity', class:'mini-icon'}),'é‡Žæ‰‹ãƒˆãƒ¬ãƒ³ãƒ‰');
      panel.append(batterSectionTitle);
      const batterGrid=el('div',{class:'stats-trend-grid'});
      let batterCount=0;
      roster.bats.forEach(player=>{
        const logs=(State.playerGameLogs[player.id]||[]).slice();
        if(logs.length<3) return;
        const totals=aggregateBatterLogs(logs);
        if((totals.pa||0)<12) return;
        const { series, labels }=computeRollingSeries(logs,7, slice=>{
          const t=aggregateBatterLogs(slice);
          return t.ab>0?(t.h||0)/(t.ab||1):0;
        });
        if(series.length<2) return;
        batterCount++;
        const latest=series[series.length-1];
        const card=el('div',{class:'stats-trend-card'});
        card.append(el('h4',{}, el('i',{ 'data-lucide':'user', class:'mini-icon'}), player.name));
        card.append(el('div',{class:'trend-meta'},
          el('span',{},`æœ€æ–°AVG ${formatAverage(latest)}`),
          el('span',{},`è©¦åˆ ${logs.length}`)
        ));
        card.append(createSparklineWithTooltip(series, labels, 'var(--primary)', 180, 36, val=>`AVG ${formatAverage(val)}`));
        batterGrid.append(card);
      });
      if(batterCount===0) batterGrid.append(el('div',{class:'stats-empty'},'æ‰“è€…ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚'));
      panel.append(batterGrid);

      const pitcherSectionTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'trending-up', class:'mini-icon'}),'æŠ•æ‰‹ãƒˆãƒ¬ãƒ³ãƒ‰');
      panel.append(pitcherSectionTitle);
      const pitcherGrid=el('div',{class:'stats-trend-grid'});
      let pitcherCount=0;
      roster.pits.forEach(player=>{
        const logs=(State.playerGameLogs[player.id]||[]).slice();
        if(logs.length<2) return;
        const totals=aggregatePitcherLogs(logs);
        if((totals.outs||0)<9) return;
        const { series, labels }=computeRollingSeries(logs,5, slice=>{
          const t=aggregatePitcherLogs(slice);
          return t.outs>0?(t.er*9)/(t.outs/3):0;
        });
        if(series.length<2) return;
        pitcherCount++;
        const latest=series[series.length-1];
        const card=el('div',{class:'stats-trend-card'});
        card.append(el('h4',{}, el('i',{ 'data-lucide':'shield', class:'mini-icon'}), player.name));
        card.append(el('div',{class:'trend-meta'},
          el('span',{},`æœ€æ–°ERA ${formatERA(latest)}`),
          el('span',{},`ç™»æ¿ ${logs.length}`)
        ));
        card.append(createSparklineWithTooltip(series, labels, 'var(--accent)', 180, 36, val=>`ERA ${formatERA(val)}`));
        pitcherGrid.append(card);
      });
      if(pitcherCount===0) pitcherGrid.append(el('div',{class:'stats-empty'},'æŠ•æ‰‹ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚'));
      panel.append(pitcherGrid);
      setTimeout(refreshIcons,0);
    },
    advanced:()=>{
      const panel=panels.advanced;
      panel.innerHTML='';
      const batAdvancedTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'sparkles', class:'mini-icon'}),'é‡Žæ‰‹é«˜åº¦æŒ‡æ¨™');
      panel.append(batAdvancedTitle);
      const batTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'PA'),
          el('th',{},'wOBA'),
          el('th',{},'wRC+'),
          el('th',{class:'col-secondary'},'OBP'),
          el('th',{class:'col-secondary'},'SLG')
        )),
        el('tbody')
      );
      roster.bats.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const totals=aggregateBatterLogs(logs);
        if((totals.pa||0)===0) return;
        const metrics=computeAdvancedBattingMetrics(totals, leagueMetrics.batting);
        batTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, totals.pa||0),
          el('td',{}, formatRate(metrics.woba)),
          el('td',{}, formatNumber(metrics.wrcPlus,0)),
          el('td',{class:'col-secondary'}, formatRate(metrics.obp)),
          el('td',{class:'col-secondary'}, formatRate(metrics.slg))
        ));
      });
      if(!batTable.lastChild.hasChildNodes()) batTable.lastChild.append(el('tr',{}, el('td',{colspan:6},'ãƒ‡ãƒ¼ã‚¿ãªã—')));
      panel.append(createStatsTableWrapper('bar-chart-3','é‡Žæ‰‹æŒ‡æ¨™ã¾ã¨ã‚', batTable));

      const pitAdvancedTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'gauge', class:'mini-icon'}),'æŠ•æ‰‹é«˜åº¦æŒ‡æ¨™');
      panel.append(pitAdvancedTitle);
      const pitTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'IP'),
          el('th',{},'FIP'),
          el('th',{},'ERA'),
          el('th',{},'WHIP'),
          el('th',{class:'col-secondary'},'K/BB')
        )),
        el('tbody')
      );
      roster.pits.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const totals=aggregatePitcherLogs(logs);
        if((totals.outs||0)===0) return;
        const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
        let kbb='-';
        if(metrics.kbb===Infinity) kbb='âˆž';
        else if(metrics.kbb!=null) kbb=formatNumber(metrics.kbb,2);
        pitTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, (totals.ip||0).toFixed(1)),
          el('td',{}, metrics.fip!=null?formatERA(metrics.fip):'-.--'),
          el('td',{}, metrics.era!=null?formatERA(metrics.era):'-.--'),
          el('td',{}, metrics.whip!=null?formatRate(metrics.whip):'-'),
          el('td',{class:'col-secondary'}, kbb)
        ));
      });
      if(!pitTable.lastChild.hasChildNodes()) pitTable.lastChild.append(el('tr',{}, el('td',{colspan:6},'ãƒ‡ãƒ¼ã‚¿ãªã—')));
      panel.append(createStatsTableWrapper('pie-chart','æŠ•æ‰‹æŒ‡æ¨™ã¾ã¨ã‚', pitTable));

      const splitTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'grid', class:'mini-icon'}),'ã‚¹ãƒ—ãƒªãƒƒãƒˆãƒ»ãƒ’ãƒ¼ãƒˆãƒžãƒƒãƒ—');
      panel.append(splitTitle);
      const splitGrid=el('div',{class:'stats-split-grid'});

      const batterSplitTable=el('table',{class:'heatmap-table'},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'vså·¦'),
          el('th',{},'vså³'),
          el('th',{},'ãƒ›ãƒ¼ãƒ '),
          el('th',{},'ãƒ“ã‚¸ã‚¿ãƒ¼')
        )),
        el('tbody')
      );
      roster.bats.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const splits=computeBatterSplits(logs, gameMeta, tid);
        const values=['vsLeft','vsRight','home','away'].map(key=>splits[key]?.metrics?.ops||0).filter(v=>v>0);
        const max=Math.max(0,...values);
        const hasData=['vsLeft','vsRight','home','away'].some(key=>(splits[key]?.totals?.pa||0)>0);
        if(!hasData) return;
        const row=el('tr',{});
        row.append(el('th',{style:'text-align:left;'},player.name));
        ['vsLeft','vsRight','home','away'].forEach(key=>{
          const entry=splits[key];
          const ops=entry?.metrics?.ops||0;
          const avg=entry?.metrics?.avg||0;
          const pa=entry?.totals?.pa||0;
          const cell=el('td',{'data-heat':''}, el('div',{}, pa>0?formatRate(ops):'-'), el('div',{class:'mini'},`AVG ${pa>0?formatAverage(avg):'.---'} / PA ${pa}`));
          const heat=max>0?Math.max(0, Math.min(1, ops/max)):0;
          cell.style.setProperty('--heat-level', `${Math.round(heat*100)}%`);
          row.append(cell);
        });
        batterSplitTable.lastChild.append(row);
      });
      if(!batterSplitTable.lastChild.hasChildNodes()) batterSplitTable.lastChild.append(el('tr',{}, el('td',{colspan:5},'ãƒ‡ãƒ¼ã‚¿ä¸è¶³')));
      splitGrid.append(createStatsTableWrapper('table','é‡Žæ‰‹ã‚¹ãƒ—ãƒªãƒƒãƒˆ', batterSplitTable));

      const pitcherSplitTable=el('table',{class:'heatmap-table'},
        el('thead',{}, el('tr',{},
          el('th',{},'é¸æ‰‹'),
          el('th',{},'vså·¦'),
          el('th',{},'vså³'),
          el('th',{},'ãƒ›ãƒ¼ãƒ '),
          el('th',{},'ãƒ“ã‚¸ã‚¿ãƒ¼')
        )),
        el('tbody')
      );
      roster.pits.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const splits=computePitcherSplits(logs, gameMeta, tid, leagueMetrics.pitching);
        const eras=['vsLeft','vsRight','home','away'].map(key=>splits[key]?.metrics?.era).filter(v=>Number.isFinite(v));
        const minEra=eras.length?Math.min(...eras):null;
        const maxEra=eras.length?Math.max(...eras):null;
        const hasData=['vsLeft','vsRight','home','away'].some(key=>(splits[key]?.totals?.outs||0)>0);
        if(!hasData) return;
        const row=el('tr',{});
        row.append(el('th',{style:'text-align:left;'},player.name));
        ['vsLeft','vsRight','home','away'].forEach(key=>{
          const entry=splits[key];
          const era=entry?.metrics?.era;
          const whip=entry?.metrics?.whip;
          const ip=outsToIP(entry?.totals?.outs||0);
          const cell=el('td',{'data-heat':''},
            el('div',{}, era!=null?formatERA(era):'-.--'),
            el('div',{class:'mini'},`WHIP ${whip!=null?formatRate(whip):'-'} / IP ${ip.toFixed(1)}`)
          );
          if(minEra!=null && maxEra!=null && maxEra>minEra){
            const heat=1-((era||maxEra)-minEra)/(maxEra-minEra);
            cell.style.setProperty('--heat-level', `${Math.round(Math.max(0,Math.min(1,heat))*100)}%`);
          } else {
            cell.style.setProperty('--heat-level','50%');
          }
          row.append(cell);
        });
        pitcherSplitTable.lastChild.append(row);
      });
      if(!pitcherSplitTable.lastChild.hasChildNodes()) pitcherSplitTable.lastChild.append(el('tr',{}, el('td',{colspan:5},'ãƒ‡ãƒ¼ã‚¿ä¸è¶³')));
      splitGrid.append(createStatsTableWrapper('table','æŠ•æ‰‹ã‚¹ãƒ—ãƒªãƒƒãƒˆ', pitcherSplitTable));

      panel.append(splitGrid);
      setTimeout(refreshIcons,0);
    },
    compare:()=>{
      const panel=panels.compare;
      panel.innerHTML='';
      const controls=el('div',{class:'stats-compare-controls'});
      const selectA=el('select',{'data-slot':'0'});
      const selectB=el('select',{'data-slot':'1'});
      selectA.append(el('option',{value:''},'é¸æ‰‹ã‚’é¸æŠž'));
      selectB.append(el('option',{value:''},'é¸æ‰‹ã‚’é¸æŠž'));
      const options=[...roster.bats.map(p=>({ id:p.id, label:`é‡Žæ‰‹ / ${p.name}` })), ...roster.pits.map(p=>({ id:p.id, label:`æŠ•æ‰‹ / ${p.name}` }))];
      options.forEach(opt=>{
        selectA.append(el('option',{value:opt.id}, opt.label));
        selectB.append(el('option',{value:opt.id}, opt.label));
      });
      selectA.value=viewState.selected[0]||'';
      selectB.value=viewState.selected[1]||'';
      function handleChange(e){
        const slot=parseInt(e.target.dataset.slot,10)||0;
        const value=e.target.value||null;
        viewState.selected[slot]=value;
        if(viewState.selected[0] && viewState.selected[0]===viewState.selected[1]){
          const other=slot===0?1:0;
          viewState.selected[other]=null;
        }
        State.ui.statsView[tid]=viewState;
        save();
        renderers.compare();
      }
      selectA.onchange=handleChange;
      selectB.onchange=handleChange;
      controls.append(selectA, selectB);
      panel.append(controls);

      const selectedPlayers=viewState.selected.map(pid=>pid? (roster.bats.find(b=>b.id===pid)||roster.pits.find(p=>p.id===pid)||null) : null).filter(Boolean);
      if(selectedPlayers.length<2){
        panel.append(el('div',{class:'stats-empty'},'æ¯”è¼ƒã™ã‚‹é¸æ‰‹ã‚’2åé¸æŠžã—ã¦ãã ã•ã„ã€‚'));
        setTimeout(refreshIcons,0);
        return;
      }
      const grid=el('div',{class:'stats-compare-grid'});
      const cards=[];
      const metricsCache=[];
      selectedPlayers.forEach(player=>{
        const isBatter=roster.bats.some(b=>b.id===player.id);
        if(isBatter){
          const logs=State.playerGameLogs[player.id]||[];
          const totals=aggregateBatterLogs(logs);
          const metrics=computeAdvancedBattingMetrics(totals, leagueMetrics.batting);
          metricsCache.push({ player, type:'BAT', totals, metrics });
          const card=el('div',{class:'stats-compare-card'});
          card.append(el('header',{}, el('h4',{},`${player.name} (${player.pos||'-'})`), el('span',{class:'mini'},'é‡Žæ‰‹')));
          const list=el('div',{class:'stats-compare-metrics'});
          const avgDisplay=totals.ab>0?formatAverage(metrics.avg):'.---';
          list.append(
            el('span',{}, el('strong',{},'AVG'), avgDisplay),
            el('span',{}, el('strong',{},'OPS'), totals.pa>0?formatRate(metrics.ops):'-'),
            el('span',{}, el('strong',{},'HR'), totals.hr||0),
            el('span',{}, el('strong',{},'RBI'), totals.rbi||0),
            el('span',{}, el('strong',{},'wOBA'), totals.pa>0?formatRate(metrics.woba):'-'),
            el('span',{}, el('strong',{},'wRC+'), totals.pa>0?formatNumber(metrics.wrcPlus,0):'-')
          );
          card.append(list);
          cards.push(card);
        } else {
          const logs=State.playerGameLogs[player.id]||[];
          const totals=aggregatePitcherLogs(logs);
          const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
          metricsCache.push({ player, type:'PIT', totals, metrics });
          const card=el('div',{class:'stats-compare-card'});
          card.append(el('header',{}, el('h4',{},`${player.name} (${player.role||'-'})`), el('span',{class:'mini'},'æŠ•æ‰‹')));
          const list=el('div',{class:'stats-compare-metrics'});
          list.append(
            el('span',{}, el('strong',{},'IP'), (totals.ip||0).toFixed(1)),
            el('span',{}, el('strong',{},'ERA'), metrics.era!=null?formatERA(metrics.era):'-.--'),
            el('span',{}, el('strong',{},'FIP'), metrics.fip!=null?formatERA(metrics.fip):'-.--'),
            el('span',{}, el('strong',{},'WHIP'), metrics.whip!=null?formatRate(metrics.whip):'-'),
            el('span',{}, el('strong',{},'K'), totals.so||0),
            el('span',{}, el('strong',{},'BB'), totals.bb||0)
          );
          cards.push(card);
        }
      });
      cards.forEach(card=>grid.append(card));

      if(metricsCache.length===2 && metricsCache[0].type===metricsCache[1].type){
        const [a,b]=metricsCache;
        const diffCard=el('div',{class:'stats-compare-card'});
        diffCard.append(el('header',{}, el('h4',{},'å·®åˆ†ãƒã‚¤ãƒ©ã‚¤ãƒˆ'), el('span',{class:'mini'},'é¸æ‰‹A - é¸æ‰‹B')));
        const list=el('div',{class:'stats-compare-metrics'});
        if(a.type==='BAT'){
          const paA=a.totals.pa||0;
          const paB=b.totals.pa||0;
          const hasSample=paA>0 && paB>0;
          list.append(
            el('span',{}, el('strong',{},'AVG Î”'), hasSample?formatSignedNumber((a.metrics.avg||0)-(b.metrics.avg||0),3):'-'),
            el('span',{}, el('strong',{},'OPS Î”'), hasSample?formatSignedNumber((a.metrics.ops||0)-(b.metrics.ops||0),3):'-'),
            el('span',{}, el('strong',{},'HR Î”'), formatSignedNumber((a.totals.hr||0)-(b.totals.hr||0),0)),
            el('span',{}, el('strong',{},'wRC+ Î”'), hasSample?formatSignedNumber((a.metrics.wrcPlus||0)-(b.metrics.wrcPlus||0),0):'-')
          );
        } else {
          const outsA=a.totals.outs||0;
          const outsB=b.totals.outs||0;
          const hasSample=outsA>0 && outsB>0;
          const eraDiff=(hasSample && a.metrics.era!=null && b.metrics.era!=null)?formatSignedNumber((a.metrics.era||0)-(b.metrics.era||0),2):'-';
          const fipDiff=(hasSample && a.metrics.fip!=null && b.metrics.fip!=null)?formatSignedNumber((a.metrics.fip||0)-(b.metrics.fip||0),2):'-';
          const whipDiff=(hasSample && a.metrics.whip!=null && b.metrics.whip!=null)?formatSignedNumber((a.metrics.whip||0)-(b.metrics.whip||0),3):'-';
          let kbbDiff='-';
          if(a.metrics.kbb===Infinity || b.metrics.kbb===Infinity){ kbbDiff='âˆž'; }
          else if(hasSample && a.metrics.kbb!=null && b.metrics.kbb!=null){ kbbDiff=formatSignedNumber((a.metrics.kbb||0)-(b.metrics.kbb||0),2); }
          list.append(
            el('span',{}, el('strong',{},'ERA Î”'), eraDiff),
            el('span',{}, el('strong',{},'FIP Î”'), fipDiff),
            el('span',{}, el('strong',{},'WHIP Î”'), whipDiff),
            el('span',{}, el('strong',{},'K/BB Î”'), kbbDiff)
          );
        }
        diffCard.append(list);
        grid.append(diffCard);
      }

      panel.append(grid);
      setTimeout(refreshIcons,0);
    }
  };

  function setActiveTab(key){
    viewState.tab=key;
    State.ui.statsView[tid]=viewState;
    tabButtons.forEach((btn,tabKey)=>btn.classList.toggle('active', tabKey===key));
    Object.entries(panels).forEach(([panelKey,node])=>{
      if(panelKey===key){
        node.classList.add('active');
        renderers[panelKey]();
      } else {
        node.classList.remove('active');
        node.innerHTML='';
      }
    });
    setTimeout(refreshIcons,0);
  }

  setActiveTab(viewState.tab||'overview');
  return frag;
}


// ====== Draft System (v12) ======
function draftOrderFromStandings(){
  const st = computeStandings(State.teams, State.results||[], State.league.rules);
  if(st && st.length){ return st.slice().sort((a,b)=> a.Pct-b.Pct || a.W-b.W).map(r=>r.team_id); }
  const ids = State.teams.map(t=>t.team_id); const rng=mulberry32(State.seed+999);
  for(let i=ids.length-1;i>0;i--){ const j=Math.floor(rng()*(i+1)); [ids[i],ids[j]]=[ids[j],ids[i]]; }
  return ids;
}
function gradeFromValue(val){ if(val>=90) return 'S'; if(val>=82) return 'A'; if(val>=74) return 'B'; if(val>=66) return 'C'; return 'D'; }
function pickRandom(arr, rng){ return arr[Math.floor((rng?.() ?? Math.random())*arr.length)]; }
function generateProspectEvents(type, ratings, rng=mulberry32(hashString(`${ratings.pot||70}:${type}`))){
  const events={};
  const roll=()=>rng();
  if(type==='BAT'){
    const dash=(6.75 - (ratings.spd-55)/190 + (roll()-0.5)*0.14).toFixed(2);
    const exit=(145 + (ratings.pwr-60)*0.8 + (roll()-0.5)*6).toFixed(1);
    const vert=(80 + (ratings.spd-55)*0.4 + (roll()-0.5)*6).toFixed(1);
    events.combine={
      summary:`60ydèµ°${dash}ç§’ã€æ‰“çƒé€Ÿåº¦${exit}km/hã‚’è¨˜éŒ²ã€‚æŸ”è»Ÿæ€§ãƒ†ã‚¹ãƒˆã§ã‚‚ä¸Šä½è©•ä¾¡ã‚’ç²å¾—ã€‚`,
      metrics:[
        { label:'60ydèµ°', value:`${dash}ç§’`, grade:gradeFromValue(ratings.spd) },
        { label:'æ‰“çƒé€Ÿåº¦', value:`${exit}km/h`, grade:gradeFromValue(ratings.pwr) },
        { label:'åž‚ç›´è·³ã³', value:`${vert}cm`, grade:gradeFromValue(ratings.spd) },
        { label:'é¸çƒã‚¹ã‚³ã‚¢', value:`${(ratings.disc + (roll()*10|0))}`, grade:gradeFromValue(ratings.disc) }
      ]
    };
    const koshienTeams=['æ˜Ÿé™µå­¦é™¢','äº¬å—é«˜æ ¡','åŒ—æµ·å­¦åœ’','æ˜Žæ±å•†æ¥­','é³³å‡°å­¦åœ’'];
    const stages=['ç”²å­åœ’æº–æ±ºå‹','ç”²å­åœ’æ±ºå‹','åœ°æ–¹å¤§ä¼šæ±ºå‹','å›½ä½“æº–ã€…æ±ºå‹'];
    const avg=(0.285 + (ratings.con-60)/600 + (roll()-0.5)*0.04).toFixed(3).slice(1);
    const hr=Math.max(0, Math.round((ratings.pwr-60)/8 + roll()*2));
    events.tournaments=[
      {
        stage: pickRandom(stages, rng),
        team: pickRandom(koshienTeams, rng),
        stat:`æ‰“çŽ‡.${avg} / æœ¬å¡æ‰“${hr}æœ¬ / ç›—å¡${Math.max(0,Math.round((ratings.spd-55)/10 + roll()*1.5))}`,
        highlight: pickRandom([
          'çµ‚ç›¤ã«å‹ã¡è¶Šã—ã¨ãªã‚‹é€†æ–¹å‘ã¸ã®2ç‚¹é©æ™‚æ‰“ã‚’æ”¾ã¤ã€‚',
          'å¤§ä¼šé€šç®—ã§æ‰“çŽ‡4å‰²è¶…ãˆã®æ´»èºã€‚',
          'æ±ºå‹ã§3æ‰“æ•°3å®‰æ‰“ã¨å¤§æš´ã‚Œã€‚'
        ], rng)
      }
    ];
    events.notes=pickRandom([
      'ãƒŸãƒ¼ãƒˆã‚»ãƒ³ã‚¹ãŒé«˜ãã€æ‰“å¸­ã§ã®å¯¾å¿œåŠ›ãŒè©•ä¾¡ã•ã‚Œã¦ã„ã¾ã™ã€‚ä½“ã¥ãã‚ŠãŒé€²ã‚ã°ã•ã‚‰ã«é•·æ‰“åŠ›ãŒä¼¸ã³ãã†ã§ã™ã€‚',
      'åºƒè§’ã¸ã®æ‰“ã¡åˆ†ã‘ãŒæŒã¡å‘³ã€‚å®ˆå‚™ã§ã¯æŸ”ã‚‰ã‹ã„ã‚°ãƒ©ãƒ–æŒãã‚‚è¦‹ã›ã¦ãŠã‚Šã€å°†æ¥çš„ã«å†…å¤–é‡Žã‚’ä»»ã›ã‚‰ã‚Œã‚‹ã¨ã®å£°ã€‚',
      'ã‚³ãƒ³ãƒã‚¤ãƒ³ã§ã¯ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—é¢ã‚‚é«˜è©•ä¾¡ã€‚ã‚¯ãƒ©ãƒ–ãƒã‚¦ã‚¹ã‚’æ˜Žã‚‹ãã™ã‚‹ã‚¿ã‚¤ãƒ—ã§ãƒãƒ¼ãƒ ã¸ã®ãƒ•ã‚£ãƒƒãƒˆæ„ŸãŒæœŸå¾…ã•ã‚Œã¦ã„ã¾ã™ã€‚'
    ], rng);
  } else {
    const velo=(ratings.velo + 6 + (roll()-0.5)*4).toFixed(1);
    const spin=(2100 + (ratings.mov-55)*18 + (roll()-0.5)*120)|0;
    const ctrlScore=(ratings.ctrl + (roll()-0.5)*8)|0;
    events.combine={
      summary:`ãƒ–ãƒ«ãƒšãƒ³ã§æœ€é€Ÿ${velo}km/hã‚’è¨ˆæ¸¬ã€‚ã‚¹ãƒ”ãƒ³ãƒ¬ãƒ¼ãƒˆã¯${spin}rpmã¨ä¸Šä½æ°´æº–ã€‚`,
      metrics:[
        { label:'æœ€é€Ÿçƒé€Ÿ', value:`${velo}km/h`, grade:gradeFromValue(ratings.velo) },
        { label:'ã‚¹ãƒ”ãƒ³ãƒ¬ãƒ¼ãƒˆ', value:`${spin}rpm`, grade:gradeFromValue(ratings.mov) },
        { label:'åˆ¶çƒæŒ‡æ•°', value:`${ctrlScore}`, grade:gradeFromValue(ratings.ctrl) },
        { label:'ã‚¹ã‚¿ãƒŸãƒŠãƒ†ã‚¹ãƒˆ', value:`${(ratings.stam + (roll()-0.5)*6)|0}pt`, grade:gradeFromValue(ratings.stam) }
      ]
    };
    const schools=['æµªé€Ÿå·¥æ¥­','é’å³°é«˜æ ¡','ä»™åŒ—å­¦é™¢','ä¿®å¾³é¤¨','å ±å¾³å¤§ä»˜å±ž'];
    const tourneys=['æ˜¥ã®ã‚»ãƒ³ãƒãƒ„','ç”²å­åœ’æ±ºå‹','éƒ½å¸‚å¯¾æŠ—äºˆé¸','U18ä»£è¡¨å¼·åŒ–åˆå®¿'];
    const era=(1.90 + (100-ratings.ctrl)/180 + (roll()-0.5)*0.6).toFixed(2);
    const so=Math.max(5, Math.round(12 + (ratings.mov-60)/3 + roll()*4));
    events.tournaments=[
      {
        stage: pickRandom(tourneys, rng),
        team: pickRandom(schools, rng),
        stat:`é˜²å¾¡çŽ‡${era} / å¥ªä¸‰æŒ¯${so} / ä¸Žå››çƒ${Math.max(1,Math.round((100-ratings.ctrl)/15 + roll()*2))}`,
        highlight: pickRandom([
          'æœ€é€Ÿ154km/hã‚’è¨ˆæ¸¬ã—ã€7å›ž1å¤±ç‚¹ã§å®ŒæŠ•å‹åˆ©ã€‚',
          'ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ãƒ•ã‚©ãƒ¼ã‚¯ã®ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã§å¥ªä¸‰æŒ¯ã‚·ãƒ§ãƒ¼ã‚’æŠ«éœ²ã€‚',
          'çƒæ•°åˆ¶é™ã®ä¸­ã§ã‚‚ãƒ†ãƒ³ãƒã‚ˆãæŠ•ã’è¾¼ã¿ã€æ‰“è€…ã‚’ç¿»å¼„ã—ãŸã€‚'
        ], rng)
      }
    ];
    events.notes=pickRandom([
      'ã‚¹ã‚«ã‚¦ãƒˆé™£ã‹ã‚‰ã¯ã€Œä¸‹åŠèº«ä¸»å°Žã®å®‰å®šã—ãŸãƒ•ã‚©ãƒ¼ãƒ ã€ã¨è©•ä¾¡ã€‚å¤‰åŒ–çƒã®ç²¾åº¦ã‚‚å‘ä¸Šä½™åœ°ã‚ã‚Šã€‚',
      'æŠ•çƒãƒ†ãƒ³ãƒãŒè‰¯ãã€æ‰“è€…ã‚’è¿½ã„è¾¼ã‚“ã§ã‹ã‚‰ã®æ±ºã‚çƒãŒå…‰ã‚Šã¾ã™ã€‚ã‚¹ã‚¿ãƒŸãƒŠé¢ã‚’æ•´ãˆã‚Œã°å…ˆç™ºãƒ­ãƒ¼ãƒ†å€™è£œã€‚',
      'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‡ã‚£ãƒ³ã‚°ã‚‚ãã¤ãªãã“ãªã—ã€ç‰½åˆ¶ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒä¸Šæ‰‹ã„ã¨ã®è©•ä¾¡ã€‚ã‚¯ãƒ©ãƒƒãƒå ´é¢ã§å¼·ã•ã‚’è¦‹ã›ã¾ã™ã€‚'
    ], rng);
  }
  return events;
}

function resolveProspectLevel(prospect){
  const existing=(prospect?.level||'').trim();
  if(existing) return existing;
  const age=Number.isFinite(prospect?.age)?prospect.age:20;
  if(age<=19) return 'é«˜æ ¡';
  if(age<=21) return 'å¤§å­¦';
  if(age<=24) return 'ç¤¾ä¼šäºº';
  return 'ç‹¬ç«‹ãƒªãƒ¼ã‚°';
}

function createScoutingProfile(trueRatings, type, level, rng){
  const attrs=type==='BAT'?['con','disc','pwr','spd','fld','pot']:['velo','ctrl','mov','stam','pot'];
  const baseGrades={}, errors={}, hiddenAttrs={}, revealThreshold={};
  const normalizedLevel=(level||'').trim();
  const spreadMultipliers={ é«˜æ ¡:1.35, å¤§å­¦:1, ç¤¾ä¼šäºº:0.75, ç‹¬ç«‹ãƒªãƒ¼ã‚°:1.1, æµ·å¤–:1.2 };
  attrs.forEach(attr=>{
    const trueVal=trueRatings[attr]??60;
    const baseSpread=attr==='pot'?14:10;
    const multiplier=spreadMultipliers[normalizedLevel]??1;
    const rawSpread=Math.round(baseSpread*multiplier);
    const spread=clamp(rawSpread, attr==='pot'?6:4, attr==='pot'?22:16);
    const err=Math.round(((rng?.()??Math.random())-0.5)*2*spread);
    const baseVal=clamp(trueVal+err,20,99);
    baseGrades[attr]=baseVal;
    errors[attr]=baseVal-trueVal;
    const hidden=((rng?.()??Math.random())< (attr==='pot'?0.55:0.35));
    hiddenAttrs[attr]=hidden;
    revealThreshold[attr]= hidden ? 0.3 + ((rng?.()??Math.random())*0.45) : 0;
  });
  return { baseGrades, errors, hiddenAttrs, revealThreshold, teams:{}, events: generateProspectEvents(type, trueRatings, rng) };
}

function generateProspects(){
  const seed = (State.seed||2025) + (State.season||1)*31 + 777;
  const rng=mulberry32(seed>>>0);
  const prospects=[]; const used=new Set();
  function makeIdentity(){ return makeFictionalIdentity(rng, used); }

  function assignGrowthCurve(pot) {
    const r = rng();
    if (pot >= 95) return 'prodigy';
    if (pot >= 88) return r < 0.6 ? 'late' : 'standard';
    if (pot >= 80) return r < 0.5 ? 'standard' : (r < 0.8 ? 'late' : 'early');
    if (pot >= 70) return r < 0.6 ? 'standard' : (r < 0.85 ? 'early' : 'bust');
    return r < 0.5 ? 'early' : 'bust';
  }

  function mkBat(){
    const trueRatings={
      con: clamp(40+Math.floor(rng()*35),30,90),
      disc: clamp(35+Math.floor(rng()*30),30,88),
      pwr: clamp(40+Math.floor(rng()*40),30,94),
      spd: clamp(40+Math.floor(rng()*40),30,94),
      fld: clamp(40+Math.floor(rng()*40),30,94),
      pot: clamp(70+Math.floor(rng()*26),60,99)
    };
    const pos = randPos(rng);
    const identity=makeIdentity();
    const age=18+Math.floor(rng()*5);
    const prospectLevel=resolveProspectLevel({ age });
    const prospect={
      pid:`PR-B-${Math.floor(rng()*1e9)}`,
      name:identity.name,
      type:'BAT',
      age,
      hand:randHand(rng),
      pos,
      growthCurve: assignGrowthCurve(trueRatings.pot),
      trueRatings,
      level:prospectLevel,
      isForeign: identity.isForeign,
      origin: identity.origin,
      scouting:createScoutingProfile(trueRatings, 'BAT', prospectLevel, rng)
    };
    return prospect;
  }
  function mkPit(){
    const trueRatings={
      velo:clamp(40+Math.floor(rng()*42),30,94),
      ctrl:clamp(35+Math.floor(rng()*34),30,90),
      mov:clamp(40+Math.floor(rng()*42),30,94),
      stam:clamp(40+Math.floor(rng()*38),30,92),
      pot:clamp(70+Math.floor(rng()*26),60,99)
    };
    const role=(rng()<0.65?"SP":"RP");
    const identity=makeIdentity();
    const age=18+Math.floor(rng()*5);
    const prospectLevel=resolveProspectLevel({ age });
    const prospect={
      pid:`PR-P-${Math.floor(rng()*1e9)}`,
      name:identity.name,
      type:'PIT',
      age,
      role,
      hand:randHand(rng),
      growthCurve: assignGrowthCurve(trueRatings.pot),
      isForeign: identity.isForeign,
      origin: identity.origin,
      trueRatings,
      level:prospectLevel,
      scouting:createScoutingProfile(trueRatings, 'PIT', prospectLevel, rng)
    };
    return prospect;
  }
  ensureTeamMeta();
  Object.values(State.teamMeta||{}).forEach(meta=>{ if(meta?.scouting){ meta.scouting.assignments={}; } });
  for(let i=0;i<60;i++) prospects.push(mkBat());
  for(let i=0;i<40;i++) prospects.push(mkPit());
  return prospects;
}
function ensureDraft(){
  const draft = ensureDraftStateRecord(State);
  if(!Array.isArray(draft.order) || draft.order.length===0){
    draft.order = draftOrderFromStandings();
  }
  if(draft.round === 1){
    const needsInit = !Array.isArray(draft.pendingFirstRound) || draft.pendingFirstRound.length===0;
    if(needsInit && draft.bids.length===0){
      draft.pendingFirstRound = draft.order.slice();
    }
  }
  if(!Array.isArray(draft.pool)) draft.pool = [];
  draft.prospects = draft.pool;
  if(typeof draft.completed!=='boolean') draft.completed=false;
  return draft;
}
function handleDraftEvent(type, payload){
  draftView?.pushEvent?.(type, payload);
  if(type==='lottery'){
    const winnerName=id2name(payload.winner.teamId);
    const loserNames=(payload.losers||[]).map(id2name).join('ã€');
    const suffix=loserNames?`ï¼ˆæ•—è€…: ${loserNames}ï¼‰`:'';
    State.devLogs.push(`ã€ãƒ‰ãƒ©ãƒ•ãƒˆæŠ½é¸ã€‘${payload.prospect.name}ã®äº¤æ¸‰æ¨©ã¯${winnerName}ãŒç²å¾—${suffix}`);
    return;
  }
  if(type==='selection'){
    const { round, teamId, prospect } = payload;
    const prefix = round===1 ? '1å·¡ç›®æŠ½é¸çµæžœ' : `${round}å·¡ç›®æŒ‡å`;
    State.devLogs.push(`ã€ãƒ‰ãƒ©ãƒ•ãƒˆ${prefix}ã€‘${id2name(teamId)} -> ${prospect.name}`);
    if(round===1){
      logHighlight('pen-tool', `ã€ãƒ‰ãƒ©ãƒ•ãƒˆ1å·¡ç›®ã€‘${id2name(teamId)}ãŒ${prospect.name}ã‚’æŒ‡åï¼æœªæ¥ã®ãƒãƒ¼ãƒ ã‚’èƒŒè² ã†é€¸æã§ã™ã€‚`);
    }
  }
}
function applyDraftSelection(team_id, prospect, selection){
  if(!prospect) return false;
  ensureProspectStructure(prospect);
  const ratings=prospect.trueRatings||{};
  if(prospect.type==='BAT'){
    const id=`B${team_id}-N${State.rosters[team_id].bats.length}`;
    const player={id,name:prospect.name,age:prospect.age,hand:prospect.hand,con:ratings.con,disc:ratings.disc,pwr:ratings.pwr,spd:ratings.spd,fld:ratings.fld,pos:prospect.pos,pot:ratings.pot,traits:[],morale:65,fatigue:15, injury: null, recentGains:[], isForeign:Boolean(prospect.isForeign), origin: prospect.origin || (prospect.isForeign?'international':'domestic')};
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale] };
    ensurePlayerPersona(player, mulberry32(hashString(id)));
    State.rosters[team_id].bats.push(player); if(!State.squads[team_id]) ensureSquads(); State.squads[team_id].ni.push(id);
  } else {
    const id=`P${team_id}-N${State.rosters[team_id].pits.length}`;
    const player={id,name:prospect.name,age:prospect.age,role:prospect.role,velo:ratings.velo,ctrl:ratings.ctrl,mov:ratings.mov,stam:ratings.stam,hand:prospect.hand,pot:ratings.pot,traits:[],morale:65,fatigue:15, sub_role: 'ä¸­ç¶™ãŽ', injury: null, recentGains:[], isForeign:Boolean(prospect.isForeign), origin: prospect.origin || (prospect.isForeign?'international':'domestic')};
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale] };
    ensurePlayerPersona(player, mulberry32(hashString(id)));
    State.rosters[team_id].pits.push(player); if(!State.squads[team_id]) ensureSquads(); State.squads[team_id].ni.push(id);
  }
  Object.values(State.teamMeta||{}).forEach(meta=>{ if(meta?.scouting?.assignments){ delete meta.scouting.assignments[prospect.pid]; }});
  ensureTrainingDefaults(team_id);
  const teamObj = State.teams.find(t=>t.team_id===team_id);
  if(teamObj){
    recomputeTeamRatings(teamObj, State.rosters[team_id], new Set(State.squads[team_id].ichi));
  }
  updateTeamNeeds(team_id);
  return true;
}
function completeDraftSelection(team_id, selectionResult) {
    if (!selectionResult) return false;
    const { prospect, selection } = selectionResult;
    const applied = applyDraftSelection(team_id, prospect, selection);
    if (applied) save();
    return applied;
}

function chooseBestProspectForTeam(teamId) {
    return chooseBestProspectForTeamLogic(teamId, State, {
        evaluateProspectForTeam: (p, tid) => evaluateProspectForTeam(p, tid, State, { ensureProspectStructure, ensureTeamNeedsAll, clamp }),
        ensureProspectStructure,
        ensureTeamNeedsAll,
        clamp,
    });
}

function processFirstRoundResolution() {
    const result = resolveDraftFirstRound(State, { random: Math.random, onLog: handleDraftEvent });
    result.winners.forEach(entry => {
        completeDraftSelection(entry.teamId, { prospect: entry.prospect, selection: entry.selection });
    });
    return result;
}

function checkDraftCompletion() {
    const draft = ensureDraft();
    if (isDraftComplete(State) && !draft.completed) {
        State.devLogs.push('ãƒ‰ãƒ©ãƒ•ãƒˆå®Œäº†');
        draft.active = false;
        draft.completed = true;
        save();
        return true;
    }
    return false;
}

function autoDraftStep(stopTeamId) {
    ensureDraft();
    const dependencies = {
        showToast,
        chooseBestProspectForTeam: (tid) => chooseBestProspectForTeam(tid),
        completeDraftSelection,
        checkDraftCompletion,
        handleDraftEvent,
        evaluateProspectForTeam: (p, tid) => evaluateProspectForTeam(p, tid, State, { ensureProspectStructure, ensureTeamNeedsAll, clamp }),
        ensureProspectStructure,
        ensureTeamNeedsAll,
        clamp
    };
    return autoDraftStepLogic(stopTeamId, State, dependencies);
}

function autoUntilUserTurn(userTid) {
    ensureDraft();
    const dependencies = {
        showToast,
        chooseBestProspectForTeam: (tid) => chooseBestProspectForTeam(tid),
        completeDraftSelection,
        checkDraftCompletion,
        handleDraftEvent,
        evaluateProspectForTeam: (p, tid) => evaluateProspectForTeam(p, tid, State, { ensureProspectStructure, ensureTeamNeedsAll, clamp }),
        ensureProspectStructure,
        ensureTeamNeedsAll,
        clamp,
        autoDraftStep: (stopTid) => autoDraftStep(stopTid),
    };
    autoUntilUserTurnLogic(userTid, State, dependencies);
}

// ====== Recompute & Render All ======
function recomputeAllRatingsAll(){
  State.teams.forEach(t=>recomputeTeamRatings(t, State.rosters[t.team_id], new Set(State.squads[t.team_id].ichi)));
  recomputeTeamModsAll();
}
function renderAll(){
  ensureNarrativeState();
  renderSeasonSettings();

  const ruleSetDisplay = document.querySelector('#ruleSetDisplay');
  if (ruleSetDisplay) {
    const rules = rulesStore.get();
    const ruleset = getRulesetById(State.ruleId);
    ruleSetDisplay.textContent = ruleset ? ruleset.name : 'Default Rules';
  }

  scheduleView.renderToday(State);
  const selT=$("#selTeamManage"); if(selT && selT.options.length===0){ teamOptions(selT); selT.selectedIndex=0; }
  renderUserControls();
  renderDashboardOverview();
  const activeTab=(State.ui && State.ui.dashboardTab) || 'season';
  renderDashboardTabs(activeTab);
  renderManagementView();
  refreshIcons();
  updateAdvanceButtonsState();
}

// ====== Progression: Day/Season Buttons ======
function advanceSeason() {
    if(!State.historicalStats) State.historicalStats = {};
    State.season = (State.season || 1) + 1;
    State.historicalStats[State.season - 1] = {};
    State.playoffs = defaultPlayoffState();
    normalizeLeagueState(State);
    State.seasonInfo = defaultSeasonInfo();
    normalizeSeasonInfo(State);
    State.gameRecaps = {};

    const rosters = Object.values(State.rosters || {});
    rosters.forEach(roster => {
        const bats = Array.isArray(roster?.bats) ? roster.bats : [];
        const pits = Array.isArray(roster?.pits) ? roster.pits : [];
        for (const p of [...bats, ...pits]) {
            // Archive last season's data
            State.historicalStats[State.season - 1][p.id] = { history: p.history };
            // Age players
            p.age++;
            // Reset for new season
            p.history = { overall: [getOverall(p)], fatigue: [p.fatigue], morale: [p.morale] };
        }
    });
    ensureTeamFinances();
    State.teams.forEach(team => {
        const tid = team.team_id;
        const finance = State.teamFinances[tid];
        if(!finance) return;
        finance.attendance.seasonTotal = 0;
        finance.attendance.average = 0;
        finance.attendance.homeGames = 0;
        finance.attendance.lastGame = 0;
        finance.revenue = { ticket:0, merch:0, media:0, other:0, total:0 };
        finance.expenses.total = 0;
        finance.ledger = [];
        const expired = [];
        finance.contracts.forEach(contract => {
            if(contract.yearsRemaining > 0) contract.yearsRemaining--;
            if(contract.yearsRemaining <= 0){
                expired.push(contract.playerId);
                contract.status = 'expired';
            } else {
                contract.status = 'active';
                if(contract.yearsRemaining <= 1) contract.daysRemaining = 90;
            }
        });
        expired.forEach(pid => releasePlayerToFreeAgency(tid, pid, 'å¥‘ç´„æº€äº†'));
        finance.contracts = finance.contracts.filter(c=>c.status!=='expired');
        updateFinancialSnapshots(tid);
    });
}

$("#btnGen").onclick=()=>{
  logUserAction('ButtonClick', 'StartNewSeason');
  const hasSchedule = Array.isArray(State.schedule) && State.schedule.length > 0;
  const hasCurrDay = typeof State.curr_day === 'number';
  if (hasSchedule && hasCurrDay && State.curr_day <= maxDay()) {
      if (!confirm("ã‚·ãƒ¼ã‚ºãƒ³ãŒã¾ã çµ‚ã‚ã£ã¦ã„ã¾ã›ã‚“ã€‚æœ¬å½“ã«æ¬¡ã®ã‚·ãƒ¼ã‚ºãƒ³ã«é€²ã¿ã¾ã™ã‹ï¼Ÿ")) return;
  }
  advanceSeason();
  const seed=parseInt($("#seed").value)||2025;
  const reps=parseInt($("#repeats").value)||6;
  State.seed=seed;
  normalizeLeagueState(State);
  const rules = LeagueRules.ensureLeagueRules(State.league);

  const { schedule, calendarInfo } = generateSchedule({
    teams: State.teams,
    rules,
    seed: seed + State.season,
    repeats: reps
  });

  State.seasonInfo = calendarInfo;
  normalizeSeasonInfo(State);

  State.league.rules = {
    ...rules,
    gamesPerTeam: calendarInfo.gamesPerTeam || rules.gamesPerTeam,
  };
  State.schedule = schedule;
  State.results=[];
  State.curr_day=1;
  State.weekXP={}; State.weekXPLog={};
  State.devLogs=[];
  State.squadsInit=false;
  State.playerGameLogs = {};
  ensureSquads();
  recomputeAllRatingsAll();
  Object.keys(State.rosters||{}).forEach(tid => autoFixRosterViolations(parseInt(tid, 10)));
  updateAdvanceButtonsState();
  saveAndRerender();
};

$("#btnToday").onclick=()=>{
  logUserAction('ButtonClick', 'AdvanceDay');
  const complianceMap = refreshRosterComplianceAll();
  const tid = State.userTeamId ?? 0;
  const compliance = complianceMap[tid] || State.rosterCompliance?.[tid] || null;
  if(compliance && Array.isArray(compliance.errors) && compliance.errors.length){
    showRosterViolationModal(compliance);
    save();
    renderManagementView();
    updateAdvanceButtonsState();
    return;
  }
  const hasSchedule=State.schedule.length>0;
  const seasonDone=hasSchedule && State.curr_day > maxDay();

  if(seasonDone){
    if(!State.playoffs?.started){
      startPlayoffs();
      saveAndRerender();
      return;
    }
    if(State.playoffs.active){
      const progressed=playNextPlayoffGame();
      if(progressed){
        saveAndRerender();
        return;
      }
    }
    checkPlayoffStageCompletion();
    saveAndRerender();
    return;
  }

  if(!hasSchedule){
    if(State.playoffs?.active){
      if(playNextPlayoffGame()){
        saveAndRerender();
      }
    }
    return;
  }

  const {events, restDay}=tickDay();

  ensureSquads();
  recomputeAllRatingsAll();
  const day=State.curr_day||1;
  const gamesToday=events.filter(evt=>(evt?.type||'game')==='game');
  State.home_adv=clamp((parseInt($("#homeAdv").value)||5)/100,0,0.2);

  if(!restDay){
    for(const row of gamesToday){
      const seed=State.seed+day*97+row.home_id*17+row.away_id*13;
      const res=simulateGameDetailed(row, seed, State.league.rules.game);
      State.results.push(res);
      dpGain(res.winner_id, 0.3);
      const loser=(res.winner_id===row.home_id?row.away_id:row.home_id);
      dpGain(loser,0.1);
      allocateGameStats(res);
      applyGameFinancials(res);
    }
  }

  if(day%7===0){
    State.teams.forEach(t=> applyTrainingWeek(t.team_id,1,"è‡ªå‹•é€±æ¬¡è‚²æˆ"));
    recomputeAllRatingsAll();
    runScoutingTask('weekly');
  }
  updateDailyFinancials(day, gamesToday, restDay);
  processContractCountdown(day);
  runScoutingTask('daily');
  const resultsToday = (State.results||[]).filter(r=>r.day===day);
  const narrativeEvents = evaluateDailyNarrativeEvents({ day, restDay, gamesToday, resultsToday });
  let abilityChanged=false;
  narrativeEvents.forEach(evt=>{ if(applyNarrativeEvent(evt)) abilityChanged=true; });
  captureDailyMoraleSnapshot(day);
  if(abilityChanged) recomputeAllRatingsAll();
  State.curr_day=day+1;
  saveAndRerender();
};
$("#btnEnd").onclick=()=>{
  logUserAction('ButtonClick', 'AdvanceToEnd');
  if(!State.schedule.length) return;
  if(hasBlockingRosterViolations()){
    const tid=State.userTeamId ?? 0;
    const compliance=getRosterCompliance(tid,{ refresh:true });
    if(compliance && Array.isArray(compliance.errors) && compliance.errors.length){
      showRosterViolationModal(compliance);
      save();
      renderManagementView();
      updateAdvanceButtonsState();
      return;
    }
  }
  const end=maxDay();
  for(let d=State.curr_day||1; d<=end; d++){
    if(State.curr_day>end) break;
    $("#btnToday").click();
    if(hasBlockingRosterViolations()) break;
  }
};
// ====== Save/Load ======
function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(State)); }
function saveAndRerender(){ refreshRosterComplianceAll(); save(); renderAll(); }

// ====== Tabs/Listeners ======
$$('.tab').forEach(tab=> tab.onclick=()=>{ logUserAction('SceneChanged', `TeamManagementScene: ${tab.dataset.tab}`); $$('.tab').forEach(t=>t.classList.remove('active')); tab.classList.add('active'); renderManagementView(); });
$$('#dashboard-tabs .dashboard-tab').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const tab=btn.dataset.tab;
    logUserAction('SceneChanged', `DashboardScene: ${tab}`);
    if(!tab) return;
    if(!State.ui) State.ui={};
    const changed=State.ui.dashboardTab!==tab;
    State.ui.dashboardTab=tab;
    if(changed) save();
    renderDashboardTabs(tab);
  });
});

// ====== Boot ======
(async function init(){
  const { runStartupTest } = await import('./tests/startup_test.js');
  const errors = await runStartupTest();
  if (errors.length > 0) {
    const errorDiv = document.getElementById('startup-error');
    errorDiv.innerHTML = `<strong>Startup Test Failed:</strong><br>${errors.join('<br>')}`;
    errorDiv.style.display = 'block';
    return; // Stop further execution
  }

  await loadSpecials();

  DebugPanel.init({
    State,
    advanceDay: () => $('#btnToday').click(),
    advanceToEnd: () => $('#btnEnd').click(),
    updateAll: renderAll,
    id2name,
    applyNarrativeEvent,
  });
  
  // Modal Listeners
  $('#modalCloseBtn').onclick = hidePlayerDetailModal;
  $('#playerDetailModal').onclick = (e) => {
      if (e.target === $('#playerDetailModal')) {
          hidePlayerDetailModal();
      }
  };
  $('#gameRecapCloseBtn').onclick = hideGameRecapModal;
  $('#gameRecapModal').onclick = (e) => {
      if (e.target === $('#gameRecapModal')) {
          hideGameRecapModal();
      }
  };
  $('#financeModalCloseBtn').onclick = hideFinanceModal;
  $('#scoutReportCloseBtn').onclick = hideScoutReportModal;
  $('#scoutReportModal').onclick = (e) => {
      if (e.target === $('#scoutReportModal')) {
          hideScoutReportModal();
      }
  };
  $('#narrativeLogCloseBtn').onclick = hideNarrativeLogModal;
  $('#narrativeLogModal').onclick = (e) => {
      if (e.target === $('#narrativeLogModal')) {
          hideNarrativeLogModal();
      }
  };
  $('#rosterViolationCloseBtn').onclick = hideRosterViolationModal;
  $('#rosterViolationModal').onclick = (e) => {
      if (e.target === $('#rosterViolationModal')) {
          hideRosterViolationModal();
      }
  };

  // Shift + Wheel to scroll horizontally on tables
  document.body.addEventListener('wheel', (e) => {
    const target = e.target.closest('.table-scroll');
    if (target && e.shiftKey) {
      e.preventDefault();
      target.scrollLeft += e.deltaY;
    }
  }, { passive: false });

  document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
          if ($('#playerDetailModal').style.display === 'flex') hidePlayerDetailModal();
          if ($('#gameRecapModal').style.display === 'flex') hideGameRecapModal();
          if ($('#financeModal').style.display === 'flex') hideFinanceModal();
          if ($('#scoutReportModal').style.display === 'flex') hideScoutReportModal();
          if ($('#narrativeLogModal').style.display === 'flex') hideNarrativeLogModal();
          if ($('#rosterViolationModal').style.display === 'flex') hideRosterViolationModal();
          return; // Prevent other handlers when closing a modal
      }

      // Skip-link / Landmark navigation shortcuts
      const focusableSections = [
        '#skip-target-progression',
        '#skip-target-settings',
        '#skip-target-user-settings',
        '#dashboard-overview-card',
        '#dashboard-panels-card',
        '#management-card'
      ];

      if(e.ctrlKey || e.metaKey){
        const num = parseInt(e.key, 10);
        if(num >= 1 && num <= focusableSections.length){
          e.preventDefault();
          const target = $(focusableSections[num-1]);
          if(target) target.focus();
        }
      }

      if(e.key === 'Home'){
        e.preventDefault();
        const firstSidebarCard = $('.sidebar > .card');
        if(firstSidebarCard) firstSidebarCard.focus();
      }
      if(e.key === 'End'){
        e.preventDefault();
        const mainCards = $$('.main > .card');
        if(mainCards.length > 0) mainCards[mainCards.length-1].focus();
      }
  });

   // Sound event listener
  document.body.addEventListener('click', (e) => {
      if (typeof process === 'undefined') { // Simple check to detect non-Node.js env
        try {
            setupSound().catch(err => {
                console.warn('Sound setup failed on click:', err);
            });
        } catch (err) {
            console.warn('Sound setup threw an unexpected synchronous error; continuing without audio.', err);
        }
      }

      const target = e.target.closest('button, .tab, select');
      if (target) {
          if (target.matches('button')) {
              const button = target;
              if (button.id === 'btnReset') {
                  playSound('G2', '8n');
                  logUserAction('ButtonClick', 'ResetAllData');
                  if(confirm("æœ¬å½“ã«å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚")){
                      localStorage.removeItem(SAVE_KEY);
                      window.location.reload();
                  }
              } else if (button.classList.contains('primary')) {
                  playSound('G4', '16n');
              } else if (button.id === 'btnToday' || button.id === 'btnEnd') {
                  playSound('C5', '16n');
              } else if (button.textContent.includes('ç‰¹è¨“')) {
                  playSound('A4', '16n');
              }
              else {
                  playSound('C4', '16n');
              }
          } else if (target.matches('.tab')) {
              playSound('E4', '16n');
          } else if (target.matches('select')) {
                playSound('D4', '16n');
          }
      }
  }, true); // Use capture phase

  // ======== Team Selection Sync ========
  const selUserTeam = document.querySelector('#selUserTeam');
  const selTeamManage = document.querySelector('#selTeamManage');

  if(selUserTeam.options.length === 0) { teamOptions(selUserTeam); }
  if(selTeamManage.options.length === 0) { teamOptions(selTeamManage); }

  teamSelectionStore.subscribe((newTeamId, source) => {
    const newTeamIdStr = String(newTeamId);
    if (selUserTeam.value !== newTeamIdStr) {
      selUserTeam.value = newTeamIdStr;
    }
    if (selTeamManage.value !== newTeamIdStr) {
      selTeamManage.value = newTeamIdStr;
    }
    // Update State.userTeamId which is used by other parts of the application
    State.userTeamId = newTeamId;

    // Re-render relevant parts of the UI when team selection changes
    renderDashboardOverview();
    renderDashboardTabs((State.ui && State.ui.dashboardTab) || 'season');
    renderManagementView();
    save(); // Save the state change
  });

  selUserTeam.addEventListener('change', () => {
    const newTeamId = parseInt(selUserTeam.value, 10);
    teamSelectionStore.set(newTeamId, 'selUserTeam');
  });

  selTeamManage.addEventListener('change', () => {
    const newTeamId = parseInt(selTeamManage.value, 10);
    teamSelectionStore.set(newTeamId, 'selTeamManage');
  });

  // Set initial state from store
  const initialTeamId = teamSelectionStore.get();
  teamSelectionStore.set(initialTeamId, 'init');
  // ======== End Team Selection Sync ========


  ensureSquads();
  refreshRosterComplianceAll();
  save();
  renderAll();

  rulesStore.subscribe((newRules) => {
    console.log('Rules updated:', newRules);
    const ruleSetDisplay = document.querySelector('#ruleSetDisplay');
    if (ruleSetDisplay) {
      // The new rules are passed directly to the subscriber, no need to read global state
      const ruleset = getRulesetById(newRules.game.id || State.ruleId);
      ruleSetDisplay.textContent = ruleset ? ruleset.name : 'Default Rules';
    }
  });
})();
</script>

<!-- ==== Debug Helper injected by ChatGPT ==== -->
<style>
  .debug-floating-btn { position: fixed; right: 16px; bottom: 16px; z-index: 5000; 
    border: 2px solid #334155; background: #111827; color: #fff; padding: 10px 14px; 
    border-radius: 12px; font-size: 12px; cursor: pointer; box-shadow: 0 6px 16px rgba(0,0,0,.3); }
  .debug-panel { position: fixed; right: 16px; bottom: 70px; width: 380px; max-height: 50vh; 
    overflow: auto; background: #0f172a; color: #e2e8f0; border: 2px solid #334155; 
    border-radius: 12px; padding: 10px; z-index: 5000; display: none; }
  .debug-panel h4 { margin: 0 0 8px; font-size: 13px; }
  .debug-panel pre { white-space: pre-wrap; word-break: break-word; font-size: 12px; }
  .debug-panel button { margin-right: 8px; }
</style>
<div id="__debug_panel" class="debug-panel">
  <h4>Debug Console</h4>
  <div style="margin-bottom:8px;">
    <button id="__dbg_reset" class="mini">ã‚»ãƒ¼ãƒ–å‰Šé™¤ &amp; ãƒªãƒ­ãƒ¼ãƒ‰</button>
    <button id="__dbg_copy" class="mini">ãƒ­ã‚°ã‚’ã‚³ãƒ”ãƒ¼</button>
  </div>
  <pre id="__debug_log"></pre>
</div>
<button id="__debug_toggle" class="debug-floating-btn">ðŸ›  Debug</button>
<script>
(function(){
  const LOG = [];
  const logEl = () => document.getElementById("__debug_log");

  function addLog(kind, msg) { 
    const line = `[${new Date().toLocaleString()}] ${kind}: ${msg}`;
    LOG.push(line);
    if (logEl()) logEl().textContent = LOG.join("\n");
    try {
      console[kind === 'ERROR' ? 'error' : 'log'](line);
      if (kind === 'ERROR') {
        if (typeof window.showToast === 'function') {
          window.showToast('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', { type: 'error', description: msg });
        }
      }
    } catch (e) {}
  }

  window.addEventListener("error", (ev)=>{
    addLog("ERROR", (ev.message||"") + " @ " + (ev.filename||"") + ":" + (ev.lineno||""));
  });
  window.addEventListener("unhandledrejection", (ev)=>{
    addLog("ERROR", "Unhandled Rejection: " + (ev.reason && (ev.reason.stack||ev.reason.message) || ev.reason));
  });

  document.getElementById("__debug_toggle").onclick = ()=>{
    const p = document.getElementById("__debug_panel");
    p.style.display = (p.style.display === "none" || !p.style.display) ? "block" : "none";
  };
  document.getElementById("__dbg_reset").onclick = ()=>{
    try { localStorage.removeItem("pennantsim-lite-web-v12-training-plus"); } catch(e) {}
    location.reload();
  };
  document.getElementById("__dbg_copy").onclick = async ()=>{
    try { await navigator.clipboard.writeText(LOG.join("\n")); addLog("INFO", "Copied to clipboard"); } catch(e) { addLog("ERROR", e.message||e); }
  };

  addLog("INFO", "Debug helper ready. SAVE_KEY=pennantsim-lite-web-v12-training-plus");
})();
</script>
<!-- ==== /Debug Helper ==== -->

<!-- Debug Panel -->
<div id="debug-panel" class="collapsible">
  <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #334155;">
    <h4 style="margin: 0; font-size: 13px; font-weight: 700; display: flex; align-items: center; gap: 6px;"><i data-lucide="wrench" class="mini-icon"></i>Debug Panel</h4>
    <button id="debug-panel-toggle" class="ghost" aria-label="ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹" aria-expanded="true" aria-controls="debug-panel-body" style="padding: 2px;">
      <i data-lucide="x" class="mini-icon"></i>
    </button>
  </div>
  <div id="debug-panel-body" style="padding: 0 12px 12px; display: flex; flex-direction: column; gap: 8px;">
    <div id="debug-gamestate" style="padding: 6px 8px; background: rgba(30, 41, 59, 0.8); border-radius: 6px;"></div>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
    <button id="debug-adv-day" class="ghost mini">1æ—¥é€²ã‚ã‚‹</button>
    <button id="debug-adv-season" class="ghost mini">1ã‚·ãƒ¼ã‚ºãƒ³é€²ã‚ã‚‹</button>
    <button id="debug-skip-games" class="ghost mini">è©¦åˆã‚¹ã‚­ãƒƒãƒ—</button>
    <button id="debug-add-money" class="ghost mini">ãŠé‡‘+10000</button>
    <button id="debug-reveal-players" class="ghost mini">å…¨é¸æ‰‹èƒ½åŠ›è¡¨ç¤º</button>
    <button id="debug-force-event" class="ghost mini">ã‚¤ãƒ™ãƒ³ãƒˆå¼·åˆ¶ç™ºç«</button>
  </div>
  <div id="debug-log-viewer" style="height: 120px; overflow-y: auto; background: rgba(30, 41, 59, 0.8); border-radius: 6px; padding: 6px 8px; font-family: monospace; line-height: 1.4;"></div>
  </div>
</div>
<style>
  #debug-panel.collapsed {
    transform: translateX(100%);
    opacity: 0.5;
    pointer-events: none;
  }
  #debug-panel.collapsed #debug-panel-body {
    display: none;
  }
</style>

<!-- Jules' Debug Console -->
<div id="jules-debug-console">
  <div id="jules-debug-header">
    <h4><i data-lucide="bug" class="mini-icon"></i>Jules' Debug Console</h4>
    <button id="jules-debug-close-btn" class="ghost" style="padding: 2px;"><i data-lucide="x" class="mini-icon"></i></button>
  </div>
  <div id="jules-debug-body">
    <div class="jules-debug-section">
      <h5><i data-lucide="history" class="mini-icon"></i>Recent Logs</h5>
      <div id="jules-debug-log-output">No logs yet.</div>
    </div>
    <div class="jules-debug-section">
      <h5><i data-lucide="shield-alert" class="mini-icon"></i>Last Error</h5>
      <div id="jules-debug-error-output">No errors recorded.</div>
    </div>
    <div class="jules-debug-section">
      <h5><i data-lucide="database" class="mini-icon"></i>Game State Summary</h5>
      <div id="jules-debug-state-output">State not available.</div>
    </div>
    <div class="jules-debug-section">
      <h5><i data-lucide-icon="list" class="mini-icon"></i>User Actions</h5>
      <div id="jules-debug-action-log-output">No actions logged yet.</div>
    </div>
  </div>
  <div id="jules-debug-footer">
    <button id="jules-debug-copy-btn" class="primary mini"><i data-lucide="copy" class="mini-icon"></i>Copy for AI</button>
  </div>
</div>

</body>
</html>

