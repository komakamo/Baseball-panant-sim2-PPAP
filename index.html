<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PennantSim Lite Web v12 — Training Plus</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
  <style>
    :root{
      --bg:#f0f4f8;--card-bg:#ffffff;--card-header-bg:#e4e9f2;
      --card-border:#d1d9e6;--text-primary:#1e293b;--text-secondary:#475569;--border:#b8c1d1;
      --accent:#ff477e;--primary:#00a8f3;--primary-hover:#0082c1;
      --good:#00c47b;--bad:#ff5c5c;--warn:#ffc23d;
      --shadow-color: #9fb3c8;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:'Inter','Noto Sans JP',sans-serif;background:var(--bg);color:var(--text-primary);
      background-image: linear-gradient(rgba(0,0,0, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0, 0.03) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    header{padding:16px 24px;border-bottom:2px solid var(--border);position:sticky;top:0;background:rgba(240, 244, 248, .8);backdrop-filter:saturate(180%) blur(10px);z-index:1000}
    h1{margin:0;font-family: 'Press Start 2P', cursive; font-size:16px;letter-spacing:0;display:flex;align-items:center;gap:12px;font-weight:400; text-shadow: 2px 2px 0px rgba(0,0,0,0.05);}
    h1 .logo-icon{color:var(--accent)}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:24px;padding:24px;max-width:1600px;margin:0 auto}
    .sidebar{display:flex;flex-direction:column;gap:24px}
    .main{display:flex;flex-direction:column;gap:24px}
    .dashboard-overview{display:flex;flex-direction:column;gap:20px}
    .dashboard-overview-header{font-size:13px;font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:0.08em}
    .dashboard-overview-grid{display:grid;grid-template-columns:repeat(4,minmax(180px,1fr));gap:16px}
    .dashboard-overview-grid::-webkit-scrollbar{height:6px}
    .dashboard-overview-grid::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.45);border-radius:999px}
    .dashboard-tabs{display:flex;gap:8px;margin-bottom:16px;border-bottom:2px solid var(--border);flex-wrap:wrap}
    .dashboard-tab{border:none;background:transparent;padding:10px 16px;border-radius:10px 10px 0 0;font-weight:600;color:var(--text-secondary);cursor:pointer;display:inline-flex;align-items:center;gap:8px;position:relative;transition:color .2s ease, background .2s ease}
    .dashboard-tab::after{content:"";position:absolute;left:0;right:0;bottom:-2px;height:3px;background:transparent;transition:background .2s ease}
    .dashboard-tab:hover{color:var(--text-primary)}
    .dashboard-tab:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
    .dashboard-tab.active{color:var(--primary);background:rgba(0,168,243,0.12)}
    .dashboard-tab.active::after{background:var(--primary)}
    .dashboard-panels{display:flex;flex-direction:column;gap:16px}
    .dashboard-panel{display:none}
    .dashboard-panel.active{display:block}
    .dashboard-panel-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .dashboard-panel-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.95);box-shadow:0 6px 0 0 var(--shadow-color);display:flex;flex-direction:column;min-height:0}
    .dashboard-panel-card-header{display:flex;align-items:center;gap:8px;padding:12px 16px;font-weight:700;font-size:14px;background:var(--card-header-bg);border-bottom:2px solid var(--card-border)}
    .dashboard-panel-card-body{padding:16px;overflow:auto;max-height:100%;position:relative}
    .dashboard-panel-card-body table{background:transparent}
    .training-top { display: flex; gap: 16px; flex-wrap: wrap; align-items: stretch; margin-bottom: 16px; }
    .training-top .training-steps { flex: 1 1 320px; }
    .training-top .controls { flex: 1 1 320px; justify-content: flex-end; }
    .training-steps { list-style: none; margin: 0; padding: 12px 16px; display: flex; gap: 12px; flex-wrap: wrap; border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.92); box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.15); }
    .training-step { display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; border-radius: 999px; border: 1px solid var(--card-border); background: rgba(226,232,240,0.6); color: var(--text-secondary); font-weight: 600; font-size: 12px; letter-spacing: 0.05em; text-transform: uppercase; }
    .training-step-number { width: 24px; height: 24px; border-radius: 999px; display: flex; align-items: center; justify-content: center; background: var(--card-header-bg); color: var(--text-secondary); font-weight: 700; font-size: 12px; }
    .training-step.active { color: var(--primary); background: rgba(0,168,243,0.12); border-color: var(--primary); }
    .training-step.active .training-step-number { background: var(--primary); color: #fff; }
    .training-sections { display: flex; flex-direction: column; gap: 20px; }
    .training-section { border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.95); box-shadow: 0 8px 0 0 var(--shadow-color); overflow: hidden; }
    .training-section summary { list-style: none; cursor: pointer; display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 16px 20px; font-weight: 700; font-size: 15px; background: var(--card-header-bg); border-bottom: 2px solid var(--card-border); }
    .training-section summary .mini { font-size: 12px; color: var(--text-secondary); letter-spacing: 0.05em; }
    .training-section summary::-webkit-details-marker { display: none; }
    .training-section[open] summary { background: var(--card-header-bg); }
    .training-section .summary-icon { display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease; }
    .training-section[open] .summary-icon { transform: rotate(180deg); }
    .training-section-body { padding: 20px; display: flex; flex-direction: column; gap: 16px; }
    .training-role-group { border: 1px dashed var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); overflow: hidden; }
    .training-role-group summary { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 14px 18px; font-weight: 600; font-size: 14px; cursor: pointer; background: rgba(226,232,240,0.6); }
    .training-role-group summary .mini { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.05em; }
    .training-role-group summary::-webkit-details-marker { display: none; }
    .training-role-group[open] summary { background: rgba(226,232,240,0.9); }
    .training-role-group .summary-icon { display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease; }
    .training-role-group[open] .summary-icon { transform: rotate(180deg); }
    .player-card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; padding: 18px; }
    .player-card { border: 1px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.96); padding: 16px; display: flex; flex-direction: column; gap: 12px; box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.12); }
    .player-card.injured { opacity: 0.6; }
    .player-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .player-card-title { display: flex; flex-direction: column; gap: 6px; }
    .player-name-button { background: none; border: none; padding: 0; font: inherit; font-weight: 700; color: var(--primary); text-align: left; cursor: pointer; }
    .player-name-button:hover, .player-name-button:focus { text-decoration: underline; outline: none; }
    .player-card-role { font-size: 12px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(148,163,184,0.15); color: var(--text-secondary); font-weight: 600; letter-spacing: 0.04em; }
    .player-card-meta { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .sparkline-pair { display: flex; flex-direction: column; gap: 6px; }
    .sparkline-item { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-secondary); }
    .player-card-controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: flex-start; }
    .player-card-control { display: flex; flex-direction: column; gap: 6px; min-width: 140px; }
    .player-card-control label { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.06em; text-transform: uppercase; font-weight: 600; }
    .player-card-actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .training-filter-bar { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 16px; align-items: flex-end; }
    .training-filter { display: flex; flex-direction: column; gap: 6px; min-width: 140px; }
    .training-filter label { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.06em; text-transform: uppercase; font-weight: 600; }
    .training-progress-block { display: flex; flex-direction: column; gap: 8px; padding: 12px; border: 1px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.85); }
    .training-progress-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; font-size: 12px; color: var(--text-secondary); }
    .training-progress-meta { display: flex; flex-wrap: wrap; gap: 10px; font-size: 11px; color: var(--text-secondary); }
    .training-progress-bar { position: relative; height: 8px; border-radius: 999px; background: rgba(148,163,184,0.25); overflow: hidden; border: 1px solid rgba(148,163,184,0.4); }
    .training-progress-bar span { position: absolute; left: 0; top: 0; bottom: 0; border-radius: 999px; background: linear-gradient(90deg, var(--primary), var(--accent)); transition: width .3s ease; }
    .training-progress-spark { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .training-progress-spark span { font-size: 11px; color: var(--text-secondary); }
    .condition-badge { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 999px; display: inline-flex; align-items: center; gap: 4px; border: 1px solid transparent; }
    .condition-badge.warn { background: rgba(255,194,61,0.18); color: #b45309; border-color: rgba(255,194,61,0.5); }
    .condition-badge.danger { background: rgba(239,68,68,0.18); color: #b91c1c; border-color: rgba(239,68,68,0.5); }
    .condition-badge.good { background: rgba(34,197,94,0.18); color: #047857; border-color: rgba(34,197,94,0.4); }
    .boost-chip { font-size: 12px; font-weight: 600; padding: 4px 10px; border-radius: 999px; border: 1px solid rgba(255,71,126,0.4); background: rgba(255,71,126,0.12); color: var(--accent); }
    .training-empty { padding: 18px; font-size: 12px; color: var(--text-secondary); }
    @media (max-width: 1024px){
      .player-card-grid{grid-template-columns: repeat(auto-fit, minmax(240px,1fr));}
    }
    @media (max-width: 768px){
      .training-top{flex-direction:column; align-items:stretch;}
      .training-steps{width:100%; justify-content:flex-start;}
      .controls{width:100%; justify-content:flex-start;}
      .training-top .controls{justify-content:flex-start;}
    }
    @media (max-width: 640px){
      .player-card-grid{grid-template-columns:1fr;}
      .player-card-controls{flex-direction:column; align-items:stretch;}
      .player-card-control{width:100%;}
      .player-card-actions{width:100%; justify-content:flex-start;}
    }
    #dashboard-highlights{max-height:320px;overflow:auto}
    .summary-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.92);padding:16px 18px;display:flex;flex-direction:column;gap:10px;box-shadow:inset 0 2px 0 0 rgba(148,163,184,0.12)}
    .summary-card-header{display:flex;align-items:center;gap:8px;font-weight:700;font-size:13px;color:var(--text-secondary);letter-spacing:0.06em;text-transform:uppercase}
    .summary-card-value{font-size:26px;font-weight:700;color:var(--text-primary)}
    .summary-card-value.positive{color:var(--good)}
    .summary-card-value.negative{color:var(--bad)}
    .summary-card-meta{display:flex;flex-direction:column;gap:4px;font-size:12px;line-height:1.45;color:var(--text-secondary)}
    .summary-trend{font-weight:600}
    .summary-trend.positive{color:var(--good)}
    .summary-trend.negative{color:var(--bad)}
    .draft-view{display:flex;flex-direction:column;gap:18px}
    .draft-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .draft-card{border:2px solid var(--card-border);border-radius:14px;background:rgba(255,255,255,0.96);box-shadow:0 8px 0 0 var(--shadow-color);display:flex;flex-direction:column}
    .draft-card-header{display:flex;justify-content:space-between;align-items:center;padding:14px 18px;border-bottom:2px solid var(--card-border);background:var(--card-header-bg);gap:12px}
    .draft-card-header h3{margin:0;font-size:15px;font-weight:700;display:flex;align-items:center;gap:8px;color:var(--text-primary)}
    .draft-card-body{padding:16px 18px;display:flex;flex-direction:column;gap:12px}
    .draft-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px}
    .draft-summary-item{border:1px solid var(--card-border);border-radius:12px;background:rgba(248,250,252,0.9);padding:10px 14px;display:flex;flex-direction:column;gap:6px;min-height:72px}
    .draft-summary-label{font-size:11px;color:var(--text-secondary);letter-spacing:0.08em;font-weight:700;text-transform:uppercase}
    .draft-summary-value{font-size:22px;font-weight:700;color:var(--text-primary)}
    .draft-pending-list{display:flex;flex-wrap:wrap;gap:6px;align-items:center;min-height:24px}
    .draft-pending-pill{padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(148,163,184,0.18);font-size:12px;font-weight:600;color:var(--text-secondary)}
    .draft-pending-pill.user{border-color:var(--accent);background:rgba(255,71,126,0.12);color:var(--accent)}
    .draft-controls-body{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-start}
    .draft-controls-body>button{min-width:150px;justify-content:center}
    .draft-controls-body .draft-qa-note{flex:1 1 100%; margin-top:4px;}
    .draft-stage-badge{font-size:12px;font-weight:600;color:var(--text-secondary);padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(226,232,240,0.5)}
    .draft-log{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px}
    .draft-log-entry{border:1px solid var(--card-border);border-radius:12px;background:rgba(226,232,240,0.45);padding:10px 12px;display:flex;flex-direction:column;gap:4px;opacity:0;transform:translateY(8px);animation:draftLogEnter .25s ease forwards}
    .draft-log-entry.lottery{border-color:var(--accent);background:rgba(255,71,126,0.1)}
    .draft-log-entry.snake{border-color:var(--primary);background:rgba(0,168,243,0.08)}
    .draft-log-headline{display:flex;justify-content:space-between;align-items:center;font-weight:700;font-size:13px}
    .draft-log-title{color:var(--text-primary)}
    .draft-log-team{color:var(--text-secondary);font-size:12px}
    .draft-log-body{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--text-secondary)}
    .draft-log-meta{font-weight:600;color:var(--text-secondary)}
    .draft-log-footer{font-size:11px;color:var(--text-secondary);text-align:right}
    .draft-log-empty{font-size:12px;color:var(--text-secondary);line-height:1.6}
    .draft-log-filters{display:flex;gap:8px;flex-wrap:wrap}
    .draft-log-filters .active{background:rgba(0,168,243,0.12);border-color:var(--primary);color:var(--primary)}
    .draft-qa-note{font-size:12px;color:var(--text-secondary);line-height:1.6}
    .draft-empty-note{font-size:13px;color:var(--text-secondary);padding:12px 0}
    .draft-table-card{border:2px solid var(--card-border);border-radius:14px;background:rgba(255,255,255,0.96);box-shadow:0 8px 0 0 var(--shadow-color);padding:18px}
    .draft-table-card>.table-scroll{margin-top:12px;border-radius:12px}
    .draft-summary-body{gap:16px}
    @keyframes draftLogEnter{to{opacity:1;transform:translateY(0)}}
    .season-timeline-card{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.92);padding:18px 20px;display:flex;flex-direction:column;gap:16px}
    .timeline-header{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px}
    .timeline-title{display:flex;align-items:center;gap:8px;font-size:15px;font-weight:700;color:var(--text-primary)}
    .timeline-sparkline{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .timeline-sparkline span{font-size:12px;color:var(--text-secondary)}
    .timeline-events{display:flex;gap:12px;overflow-x:auto;padding-bottom:4px}
    .timeline-events::-webkit-scrollbar{height:6px}
    .timeline-events::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.5);border-radius:999px}
    .timeline-event{min-width:200px;border:1px dashed var(--card-border);border-radius:10px;background:rgba(226,232,240,0.45);padding:12px 14px;display:flex;flex-direction:column;gap:6px}
    .timeline-event-title{display:flex;align-items:center;gap:6px;font-weight:600;font-size:13px;color:var(--text-primary)}
    .timeline-event-detail{font-size:12px;color:var(--text-secondary);line-height:1.45;white-space:normal}
    .timeline-event-meta{font-size:11px;color:var(--text-secondary);text-align:right}
    .timeline-empty{font-size:12px;color:var(--text-secondary)}
    .card{background:var(--card-bg);border:2px solid var(--card-border);border-radius:12px;box-shadow: 0 8px 0 0 var(--shadow-color);overflow:hidden; transition: transform .2s ease, box-shadow .2s ease;}
    .card:hover { transform: translateY(-2px); box-shadow: 0 10px 0 0 var(--shadow-color); }
    .card-header{background:var(--card-header-bg);padding:12px 20px;border-bottom:2px solid var(--card-border);display:flex;justify-content:space-between;align-items:center}
    .card-header h2{margin:0;font-size:16px;font-weight:700;display:flex;align-items:center;gap:8px; color: var(--text-primary);}
    .card-content{padding:20px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    button,select,input{font-family:inherit;background:#fff;border:2px solid var(--border);color:var(--text-primary);padding:8px 14px;border-radius:10px;cursor:pointer;transition:all .15s ease-out;display:inline-flex;align-items:center;gap:6px;font-size:14px;font-weight:600; box-shadow: 0 4px 0 0 var(--shadow-color);}
    select{appearance:none;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem}
    button:hover,select:hover,input:hover{background:#f8fafc;border-color:var(--text-secondary); transform: translateY(-1px); box-shadow: 0 5px 0 0 var(--shadow-color);}
    button:active,select:active,input:active{transform: translateY(2px); box-shadow: 0 2px 0 0 var(--shadow-color);}
    button:focus,select:focus,input:focus{outline:3px solid var(--accent);outline-offset:2px}
    button.primary{background:var(--primary);color:#fff;border-color:var(--primary-hover)}
    button.primary:hover{background:var(--primary-hover)}
    button.ghost{background:transparent; box-shadow: none;}
    button:disabled{opacity:.6;cursor:not-allowed;background:#e2e8f0; transform: translateY(0); box-shadow: 0 4px 0 0 var(--shadow-color);}
    .toast-container{position:fixed;top:84px;right:24px;display:flex;flex-direction:column;gap:10px;z-index:2000;pointer-events:none;max-width:320px;}
    .toast{border:2px solid var(--card-border);border-radius:12px;background:rgba(255,255,255,0.96);box-shadow:0 12px 30px rgba(15,23,42,0.16);padding:14px 16px;display:flex;flex-direction:column;gap:6px;min-width:240px;opacity:0;transform:translateY(-6px);transition:opacity .2s ease, transform .2s ease;pointer-events:auto;}
    .toast.visible{opacity:1;transform:translateY(0);}
    .toast.error{border-color:var(--bad);background:rgba(255,92,92,0.12);}
    .toast.warn{border-color:var(--warn);background:rgba(255,194,61,0.16);}
    .toast-title{font-size:13px;font-weight:700;color:var(--text-primary);}
    .toast-desc{font-size:12px;color:var(--text-secondary);line-height:1.5;}
    .roster-compliance-banner{border:2px solid var(--border);border-radius:12px;padding:12px 16px;margin-bottom:12px;display:flex;flex-direction:column;gap:8px;background:rgba(255,255,255,0.92);}
    .roster-compliance-banner.error{border-color:var(--bad);background:rgba(255,92,92,0.12);}
    .roster-compliance-banner.warning{border-color:var(--warn);background:rgba(255,194,61,0.12);}
    .roster-compliance-banner .banner-header{display:flex;align-items:center;gap:8px;font-weight:700;font-size:14px;color:var(--text-primary);}
    .roster-compliance-banner.error .banner-header{color:var(--bad);}
    .roster-compliance-banner.warning .banner-header{color:#b45309;}
    .roster-compliance-banner .banner-body{font-size:13px;color:var(--text-secondary);line-height:1.6;}
    .roster-compliance-banner ul{margin:0;padding-left:18px;font-size:12px;color:var(--text-secondary);}
    .roster-compliance-banner li{line-height:1.5;}
    .foreign-badge{display:inline-flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;padding:2px 6px;border-radius:999px;border:1px solid var(--accent);color:var(--accent);background:rgba(255,71,126,0.12);}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{border-bottom:2px solid var(--border);padding:10px 4px;text-align:left;vertical-align:middle;white-space:nowrap}
    th{color:var(--text-secondary);font-weight:700;font-size:12px;text-transform:uppercase;text-align:center; background: #f1f5f9;}
    tbody tr:nth-child(odd){ background-color: rgba(255,255,255,0.5); }
    tbody tr:hover{background-color:rgba(255, 71, 126, .1)}
    td:first-child,th:first-child{text-align:left;padding-left:12px}
    td{text-align:center}
    .stat{font-weight:700;border-radius:6px;padding:3px 6px;color:white; font-size: 13px; border: 2px solid rgba(0,0,0,0.1); text-shadow: 1px 1px 0 rgba(0,0,0,0.1);}
    .stat .margin{font-size:11px;margin-left:4px;color:rgba(255,255,255,0.85);background:rgba(0,0,0,0.15);padding:1px 4px;border-radius:999px;display:inline-block;}
    .stat-s{background:#8b5cf6}.stat-a{background:#3b82f6}.stat-b{background:#16a34a}.stat-c{background:#ca8a04}.stat-d{background:#e11d48}.stat-f{background:#71717a}
    .pill{padding:4px 12px;background:#e2e8f0;border:2px solid var(--border);border-radius:999px;color:var(--text-secondary);font-size:14px;font-weight:600}
    .pill.farm{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .pill.farm-fatigue{background:#0f766e;color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .pill.farm-trait{background:#c026d3;color:#fff;border-color:transparent;font-size:10px;padding:2px 6px;letter-spacing:0.04em}
    .farm-log{list-style:none;padding:0;margin:8px 0 0;display:flex;flex-direction:column;gap:4px;font-size:11px;color:var(--text-secondary)}
    .farm-log li{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .farm-log-time{font-weight:600;color:var(--text-secondary);font-size:10px;letter-spacing:0.05em;text-transform:uppercase}
    .scout-unknown span{display:inline-flex;align-items:center;justify-content:center;font-weight:700;padding:3px 8px;border-radius:8px;border:2px dashed var(--border);color:var(--text-secondary);background:rgba(148,163,184,0.15);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;}
    .scout-progress{height:8px;background:rgba(148,163,184,0.25);border-radius:6px;border:1px solid rgba(148,163,184,0.4);overflow:hidden;position:relative;min-width:120px;}
    .scout-progress>span{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(90deg,var(--primary),var(--accent));border-radius:6px;transition:width .3s ease;}
    .scout-progress-label{font-size:11px;color:var(--text-secondary);margin-top:4px;text-align:right;letter-spacing:0.08em;}
    .scout-button-group{display:flex;flex-direction:column;gap:6px;}
    .scout-button-group button{width:100%;justify-content:center;}
    .scout-pill{font-size:12px;padding:4px 8px;border-radius:8px;background:rgba(0,168,243,0.12);border:1px solid var(--primary);color:var(--primary);font-weight:600;display:inline-flex;align-items:center;gap:4px;}
    .scout-summary{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:12px;}
    .mini{font-size:12px;color:var(--text-secondary)}
    .table-scroll{max-height:360px;overflow:auto;border:2px solid var(--border);border-radius:12px; background: #fff;}
    .table-scroll::-webkit-scrollbar{width:8px}
    .table-scroll::-webkit-scrollbar-thumb{background:#a0aec0;border-radius:4px; border: 2px solid #f0f4f8;}
    .tabs{display:flex;gap:4px;margin:0 20px;border-bottom:2px solid var(--card-border)}
    .tab{padding:10px 16px;border:none;cursor:pointer;background:transparent;color:var(--text-secondary);font-weight:600;transition:all .2s ease;border-bottom:4px solid transparent; transform: translateY(2px);}
    .tab:hover{color:var(--text-primary)}.tab.active{color:var(--accent);border-bottom-color:var(--accent)}
    .squad{padding:2px 8px;border-radius:6px;font-size:12px;font-weight:600}
    .squad.ichi{border:1px solid #38bdf8;background:#0c2a4d;color:#7dd3fc}
    .squad.ni{border:1px solid #6b7280;background:#374151;color:#d1d5db}
    .bar{height:8px;background:#e2e8f0;border-radius:6px;position:relative;overflow:hidden; border: 1px solid var(--border);}
    .bar>span{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(90deg,var(--accent),var(--warn));border-radius:6px}
    .tag{font-size:11px;border:1px solid #475569;padding:2px 6px;border-radius:6px;margin-right:4px}
    .good{color:var(--good)}.bad{color:var(--bad)}.warn{color:var(--warn)}
    tr.injured { opacity: 0.5; text-decoration: line-through; }
    tr.injured:hover { background: transparent; }
    .mini-icon { width: 14px; height: 14px; stroke-width: 2.5; }
    .stats-tab-bar { display:flex; gap:8px; margin:0 20px 16px; border-bottom:2px solid var(--card-border); flex-wrap:wrap; padding-bottom:4px; }
    .stats-tab { background:none; border:none; padding:10px 16px; cursor:pointer; font-weight:600; color:var(--text-secondary); border-bottom:3px solid transparent; display:inline-flex; align-items:center; gap:8px; border-radius:10px 10px 0 0; transition:color .2s ease, background .2s ease; }
    .stats-tab:hover { color:var(--text-primary); background:rgba(0,168,243,0.08); }
    .stats-tab.active { color:var(--primary); border-bottom-color:var(--primary); background:rgba(0,168,243,0.12); }
    .stats-panels { display:flex; flex-direction:column; gap:20px; padding:0 20px 20px; }
    .stats-panel { display:none; flex-direction:column; gap:16px; }
    .stats-panel.active { display:flex; }
    .stats-period-filter { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .stats-period-filter button { padding:6px 12px; font-size:12px; border-radius:999px; border:1px solid var(--border); background:rgba(226,232,240,0.6); color:var(--text-secondary); cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.05em; transition:all .2s ease; }
    .stats-period-filter button.active { background:var(--primary); color:#fff; border-color:var(--primary-hover); }
    .stats-period-filter button:hover { background:rgba(0,168,243,0.15); color:var(--text-primary); }
    .stats-section-title { font-size:13px; font-weight:700; color:var(--text-secondary); letter-spacing:0.06em; text-transform:uppercase; margin:8px 0 4px; display:flex; align-items:center; gap:8px; }
    .stats-table-wrapper { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.95); box-shadow:inset 0 2px 0 rgba(148,163,184,0.12); overflow:hidden; }
    .stats-table-wrapper table { margin:0; }
    .stats-table-wrapper .table-header { padding:12px 16px; font-weight:700; background:var(--card-header-bg); border-bottom:2px solid var(--card-border); display:flex; align-items:center; gap:8px; }
    .stats-table-wrapper .table-body { padding:12px 16px; overflow:auto; max-height:360px; }
    .heatmap-table { width:100%; border-collapse:collapse; font-size:13px; }
    .heatmap-table th, .heatmap-table td { border-bottom:1px solid rgba(148,163,184,0.35); padding:8px 10px; text-align:center; }
    .heatmap-table th { background:rgba(226,232,240,0.65); color:var(--text-secondary); font-size:11px; letter-spacing:0.05em; }
    .heatmap-table tbody tr:nth-child(odd) { background:rgba(248,250,252,0.6); }
    .heatmap-table td[data-heat] { position:relative; }
    .heatmap-table td[data-heat]::before { content:""; position:absolute; inset:2px; border-radius:6px; background:linear-gradient(90deg, rgba(0,168,243,0.18) var(--heat-level,0%), transparent var(--heat-level,0%)); z-index:-1; }
    .sparkline-hover { position:relative; display:inline-flex; align-items:center; justify-content:center; padding:4px 0; }
    .sparkline-tooltip { position:absolute; background:#0f172a; color:#fff; font-size:11px; padding:4px 8px; border-radius:6px; pointer-events:none; transform:translate(-50%, -100%); white-space:nowrap; opacity:0; transition:opacity .1s ease; z-index:10; }
    .sparkline-tooltip::after { content:""; position:absolute; bottom:-4px; left:50%; transform:translateX(-50%); border:4px solid transparent; border-top-color:#0f172a; }
    .stats-trend-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    .stats-trend-card { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.94); padding:14px 16px; display:flex; flex-direction:column; gap:10px; box-shadow:0 6px 0 0 var(--shadow-color); }
    .stats-trend-card h4 { margin:0; font-size:15px; display:flex; align-items:center; gap:8px; }
    .trend-meta { display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--text-secondary); }
    .stats-compare-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
    .stats-compare-controls select { min-width:220px; }
    .stats-compare-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    .stats-compare-card { border:2px solid var(--card-border); border-radius:12px; background:rgba(255,255,255,0.94); padding:16px; box-shadow:0 6px 0 0 var(--shadow-color); display:flex; flex-direction:column; gap:12px; }
    .stats-compare-card header { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
    .stats-compare-card header h4 { margin:0; font-size:15px; }
    .stats-compare-metrics { display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:8px 12px; font-size:13px; }
    .stats-compare-metrics span { display:flex; justify-content:space-between; }
    .stats-split-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(240px,1fr)); gap:16px; }
    .stats-empty { font-size:12px; color:var(--text-secondary); padding:8px 0; }

    .feed-item { display: flex; padding: 12px 16px; gap: 12px; border-bottom: 2px solid var(--border); align-items: flex-start; }
    .feed-item:last-child { border-bottom: none; }
    .feed-icon { flex-shrink: 0; width: 32px; height: 32px; border-radius: 999px; display: flex; align-items: center; justify-content: center; background: var(--card-header-bg); }
    .feed-icon .mini-icon { color: var(--text-secondary); }
    .feed-content p { margin: 0; font-size: 13px; line-height: 1.5; white-space: normal; text-align: left;}
    .feed-content .mini { margin-top: 4px; text-align: right; }

    .recent-game-row { cursor: pointer; transition: background 0.2s ease; }
    .recent-game-row:hover td { background: rgba(0, 168, 243, 0.12); }
    .recent-game-row:focus-visible { outline: 3px solid var(--accent); outline-offset: 2px; }
    .recent-game-row.disabled { cursor: not-allowed; opacity: 0.5; }
    .recent-game-row.disabled td { background: transparent !important; }

    .highlight-link { margin-top: 8px; display: inline-flex; align-items: center; gap: 6px; font-size: 12px; padding: 6px 10px; }

    .daily-digest { padding: 16px; display: flex; flex-direction: column; gap: 12px; background: rgba(248, 250, 252, 0.92); border-bottom: 2px solid var(--card-border); }
    .daily-digest-header { display: flex; align-items: center; gap: 8px; font-weight: 700; font-size: 13px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
    .daily-digest-list { display: flex; flex-direction: column; gap: 10px; }
    .digest-day { border: 1px solid var(--card-border); border-radius: 10px; background: rgba(255, 255, 255, 0.9); padding: 10px 12px; display: flex; flex-direction: column; gap: 8px; }
    .digest-day-header { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600; color: var(--text-secondary); }
    .digest-moment-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
    .digest-moment { display: flex; flex-direction: column; gap: 4px; padding: 6px 0; border-bottom: 1px dashed rgba(148, 163, 184, 0.4); }
    .digest-moment:last-child { border-bottom: none; }
    .digest-moment-score { font-weight: 700; font-size: 13px; color: var(--text-primary); }
    .digest-moment-desc { font-size: 12px; color: var(--text-secondary); line-height: 1.45; white-space: normal; }
    .digest-moment-hero { font-size: 11px; color: var(--accent); }
    .digest-empty { padding: 16px; text-align: center; color: var(--text-secondary); font-size: 12px; }

    .narrative-feed-summary { padding: 16px 20px; border-bottom: 2px solid var(--card-border); background: rgba(248,250,252,0.9); display: flex; flex-direction: column; gap: 12px; }
    .narrative-tag { font-size: 10px; padding: 2px 8px; border-radius: 999px; background: rgba(255, 71, 126, 0.15); border: 1px solid rgba(255, 71, 126, 0.4); color: var(--accent); font-weight: 700; letter-spacing: 0.05em; }
    .morale-timeline { display: flex; align-items: center; gap: 12px; }
    .morale-timeline span { font-size: 12px; color: var(--text-secondary); }
    .narrative-log-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
    .narrative-log-item { font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
    .narrative-log-item strong { color: var(--text-primary); }
    .narrative-log-empty { font-size: 12px; color: var(--text-secondary); }
    .narrative-detail-button { align-self: flex-end; }

    .management-narrative-panel { border: 2px dashed var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.92); padding: 16px 20px; display: flex; flex-direction: column; gap: 16px; margin-bottom: 16px; }
    .management-narrative-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .management-narrative-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; }
    .narrative-subcard { border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 14px; background: rgba(248,250,252,0.85); display: flex; flex-direction: column; gap: 10px; }
    .narrative-subcard h4 { margin: 0; font-size: 13px; display: flex; align-items: center; gap: 6px; }
    .narrative-subcard .narrative-log-list { max-height: 180px; overflow: auto; }
    .narrative-subcard .narrative-log-list::-webkit-scrollbar { width: 6px; }
    .narrative-subcard .narrative-log-list::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.6); border-radius: 999px; }

    .narrative-modal-entry { border-bottom: 1px solid var(--card-border); padding-bottom: 12px; margin-bottom: 12px; display: flex; flex-direction: column; gap: 6px; }
    .narrative-modal-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .narrative-modal-entry h4 { margin: 0; font-size: 14px; display: flex; align-items: center; gap: 8px; }
    .narrative-modal-entry p { margin: 0; font-size: 12px; color: var(--text-secondary); line-height: 1.6; }
    .narrative-modal-entry .narrative-tag { align-self: flex-start; }
    .narrative-modal-entry .meta-line { font-size: 11px; color: var(--text-secondary); display: flex; gap: 8px; flex-wrap: wrap; }

    .modal-content.game-recap { max-width: 960px; width: 95%; }
    .modal-body.game-recap { padding: 24px; display: flex; flex-direction: column; gap: 20px; }
    .modal-content.scout-report { max-width: 760px; width: 95%; }
    .modal-body.scout-report { padding: 24px; display: flex; flex-direction: column; gap: 18px; }
    .scout-report-section { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); box-shadow: inset 0 2px 0 0 rgba(148,163,184,0.15); }
    .scout-report-section h4 { margin: 0; padding: 12px 16px; background: var(--card-header-bg); border-bottom: 2px solid var(--card-border); font-size: 14px; }
    .scout-report-body { padding: 16px; display: flex; flex-direction: column; gap: 12px; }
    .scout-metric-list { display: grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap: 10px; }
    .scout-metric { border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; background: rgba(255,255,255,0.85); display: flex; flex-direction: column; gap: 4px; }
    .scout-metric strong { font-size: 13px; }
    .scout-metric span { font-size: 12px; color: var(--text-secondary); }
    .scout-tournament-item { border: 1px dashed rgba(148,163,184,0.7); border-radius: 10px; padding: 12px; background: rgba(241,245,249,0.9); display: flex; flex-direction: column; gap: 6px; }
    .scout-tournament-item strong { font-size: 13px; color: var(--text-primary); }
    .scout-note { font-size: 12px; color: var(--text-secondary); line-height: 1.6; }
    .game-recap-header { display: flex; justify-content: space-between; flex-wrap: wrap; gap: 16px; align-items: center; }
    .game-recap-header .scoreline { font-size: 20px; font-weight: 700; }
    .game-recap-meta { display: flex; gap: 12px; flex-wrap: wrap; color: var(--text-secondary); font-size: 13px; }
    .game-recap-highlights ul { margin: 0; padding-left: 20px; }
    .game-recap-highlights li { margin-bottom: 6px; font-size: 13px; }
    .game-recap-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .game-recap-section { border: 2px solid var(--card-border); border-radius: 10px; background: rgba(248,250,252,0.8); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.18); }
    .game-recap-section h4 { margin: 0; padding: 12px 16px; border-bottom: 2px solid var(--card-border); background: var(--card-header-bg); font-size: 14px; }
    .game-recap-section .section-body { padding: 12px 16px; overflow-x: auto; }
    .game-recap-keyplay { font-size: 14px; font-weight: 600; background: rgba(0, 200, 123, 0.1); border: 2px solid rgba(0, 200, 123, 0.3); border-radius: 10px; padding: 12px 16px; color: var(--good); }

    .key-moment-list { display: flex; flex-direction: column; gap: 6px; font-size: 12px; }
    .key-moment-item { padding: 6px 8px; border-left: 3px solid var(--accent); background: rgba(255, 71, 126, 0.08); border-radius: 6px; }
    .play-log-list { max-height: 220px; overflow: auto; display: flex; flex-direction: column; gap: 6px; font-size: 12px; }
    .play-log-item { padding: 6px 8px; border-left: 3px solid var(--primary); background: rgba(226, 232, 240, 0.75); border-radius: 6px; }
    .game-recap-timeline { display: flex; flex-direction: column; gap: 12px; }
    .timeline-entry { border: 1px solid var(--card-border); border-radius: 8px; padding: 8px 10px; background: rgba(148, 163, 184, 0.12); font-size: 12px; }
    .timeline-entry strong { display: block; font-size: 13px; margin-bottom: 4px; }
    .timeline-entry span { display: block; margin-bottom: 2px; }

    .game-recap-table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .game-recap-table th { background: rgba(226, 232, 240, 0.7); font-size: 11px; text-transform: uppercase; }
    .game-recap-table td, .game-recap-table th { border-bottom: 1px solid var(--border); padding: 8px 6px; text-align: center; white-space: nowrap; }
    .game-recap-table td:first-child, .game-recap-table th:first-child { text-align: left; }

    @media (max-width: 1200px){
        .dashboard-overview-grid{grid-template-columns:repeat(2,minmax(200px,1fr));}
    }
    @media (max-width: 900px) {
        .game-recap-grid { grid-template-columns: 1fr; }
        .dashboard-overview-grid{grid-template-columns:1fr;}
    }

    @media (max-width: 640px) {
        .modal-body { grid-template-columns: 1fr; }
        .modal-body.game-recap { padding: 20px; }
        .dashboard-overview-grid{display:flex;overflow-x:auto;gap:12px;padding-bottom:4px;}
        .dashboard-overview-grid .summary-card{flex:0 0 220px;}
        .timeline-events{gap:10px;}
        .stats-tab-bar{margin:0 12px 12px;}
        .stats-panels{padding:0 12px 16px;}
        .stats-period-filter{gap:6px;}
        .stats-table-wrapper .table-body{padding:8px 12px;}
        .stats-compare-controls select{min-width:160px; width:100%;}
        .stats-compare-metrics{grid-template-columns:1fr;}
    }

    @media (max-width: 720px){
        .stats-table-wrapper table .col-secondary{display:none;}
        .stats-table-wrapper table th.col-secondary{display:none;}
    }
    }

    .playoffs-wrapper { display: flex; flex-direction: column; gap: 16px; padding: 16px; }
    .playoff-stage { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.9); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.2); }
    .playoff-stage-header { padding: 12px 16px; border-bottom: 2px solid var(--card-border); background: var(--card-header-bg); font-weight: 700; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
    .playoff-stage.done .playoff-stage-header { color: var(--good); }
    .playoff-stage.upcoming .playoff-stage-header { color: var(--text-secondary); }
    .playoff-series { padding: 16px; display: flex; flex-direction: column; gap: 10px; border-bottom: 2px solid var(--card-border); }
    .playoff-series:last-child { border-bottom: none; }
    .playoff-series h4 { margin: 0; font-size: 15px; font-weight: 700; display: flex; align-items: center; gap: 6px; }
    .series-status { font-size: 12px; color: var(--text-secondary); }
    .series-teams { display: grid; gap: 8px; }
    .series-team { display: flex; justify-content: space-between; align-items: center; background: rgba(226, 232, 240, 0.7); border: 2px solid var(--card-border); border-radius: 10px; padding: 8px 12px; font-weight: 600; }
    .series-team .wins { font-size: 12px; color: var(--text-secondary); }
    .series-games { list-style: none; margin: 0; padding: 0; font-size: 12px; color: var(--text-secondary); display: flex; flex-direction: column; gap: 4px; }
    .series-games li { padding: 6px 8px; background: rgba(248, 250, 252, 0.9); border: 1px solid var(--card-border); border-radius: 8px; }
    .series-action { display: flex; gap: 8px; align-items: center; }
    .series-action button { flex-shrink: 0; }
    .playoffs-empty { padding: 24px; text-align: center; font-size: 13px; color: var(--text-secondary); }
    .champion-banner { padding: 20px; border: 2px dashed var(--accent); border-radius: 12px; background: rgba(255, 71, 126, 0.05); text-align: center; font-weight: 700; font-size: 16px; display: flex; flex-direction: column; gap: 8px; }

    .finance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; }
    .finance-card { border: 2px solid var(--card-border); border-radius: 12px; background: rgba(255,255,255,0.9); box-shadow: inset 0 2px 0 0 rgba(148, 163, 184, 0.18); padding: 16px; display: flex; flex-direction: column; gap: 10px; }
    .finance-card h3 { margin: 0; font-size: 14px; font-weight: 700; display: flex; align-items: center; gap: 8px; color: var(--text-primary); }
    .front-office-view { display: flex; flex-direction: column; gap: 20px; }
    .front-office-card { border: 2px solid var(--card-border); border-radius: 14px; background: rgba(255,255,255,0.95); box-shadow: 0 8px 0 0 var(--shadow-color); padding: 18px; display: flex; flex-direction: column; gap: 16px; }
    .front-office-card-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .front-office-card-header h3 { margin: 0; font-size: 15px; display: flex; align-items: center; gap: 8px; font-weight: 700; color: var(--text-primary); }
    .front-office-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; }
    .staff-slider-row, .facility-slider-row { display: flex; flex-direction: column; gap: 10px; padding: 12px; border: 1px solid var(--card-border); border-radius: 12px; background: rgba(248,250,252,0.9); }
    .staff-slider-header, .facility-slider-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .staff-slider-name, .facility-slider-name { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-primary); }
    .staff-slider-value, .facility-slider-value { font-weight: 700; font-size: 14px; color: var(--text-primary); }
    .staff-slider-meta, .facility-slider-meta { font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
    .staff-slider-input, .facility-slider-input { width: 100%; accent-color: var(--primary); }
    .staff-slider-footer, .facility-slider-footer { display: flex; justify-content: flex-end; color: var(--text-secondary); }
    .facility-slider-effects { list-style: none; margin: 0; padding-left: 16px; display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: var(--text-secondary); }
    .front-office-empty { padding: 12px; border: 1px dashed var(--border); border-radius: 12px; background: rgba(248,250,252,0.6); }
    @media (max-width: 640px){ .front-office-grid{ grid-template-columns:1fr; } }
    .finance-stat { display: flex; justify-content: space-between; font-size: 13px; color: var(--text-secondary); }
    .finance-stat strong { color: var(--text-primary); }
    .finance-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .finance-tag { font-size: 10px; padding: 2px 6px; border-radius: 999px; background: rgba(0,168,243,0.12); border: 1px solid var(--primary); color: var(--primary); text-transform: uppercase; letter-spacing: 0.04em; }
    .budget-slider { width: 100%; accent-color: var(--primary); }
    .finance-section { margin-top: 20px; display: flex; flex-direction: column; gap: 12px; }
    .finance-section h3 { margin: 0; font-size: 15px; font-weight: 700; display: flex; gap: 8px; align-items: center; }
    .contract-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .contract-table th, .contract-table td { border-bottom: 1px solid var(--border); padding: 6px 4px; text-align: left; white-space: nowrap; }
    .contract-table th { background: rgba(241,245,249,0.7); text-transform: uppercase; font-size: 11px; color: var(--text-secondary); }
    .contract-table tbody tr:hover { background: rgba(0,168,243,0.08); }
    .contract-negotiation { display: flex; flex-direction: column; gap: 12px; }
    .contract-negotiation .table-scroll { max-height: 360px; }
    .contract-negotiation .offer-cell { display: grid; grid-template-columns: auto 1fr; gap: 4px 8px; align-items: center; }
    .contract-negotiation .offer-cell input { width: 120px; }
    .contract-negotiation .negotiation-table td { vertical-align: top; white-space: nowrap; }
    .contract-negotiation .negotiation-table td.result-cell { white-space: normal; }
    .contract-negotiation .negotiation-text { margin-bottom: 4px; line-height: 1.5; }
    .contract-negotiation .negotiation-actions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .contract-negotiation .negotiation-actions button.danger { color: var(--warn); border-color: rgba(239, 68, 68, 0.4); }
    .contract-negotiation .negotiation-actions button.danger:hover { background: rgba(239, 68, 68, 0.08); }
    .finance-badge { font-size: 11px; padding: 2px 6px; border-radius: 6px; background: rgba(0,200,123,0.12); border: 1px solid rgba(0,200,123,0.4); color: var(--good); font-weight: 600; }
    .finance-forecast { display: flex; flex-direction: column; gap: 4px; font-size: 12px; }
    .finance-forecast span { display: flex; justify-content: space-between; }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(30, 41, 59, 0.8);
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }
    .modal-content {
        background: var(--card-bg);
        padding: 0;
        border-radius: 12px;
        border: 2px solid var(--card-border);
        box-shadow: 0 12px 0 0 var(--shadow-color);
        width: 90%;
        max-width: 600px;
        position: relative;
    }
    .modal-header {
      padding: 16px 24px;
      border-bottom: 2px solid var(--card-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-header-bg);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 18px;
    }
    .modal-body {
        padding: 24px;
        display: grid;
        grid-template-columns: 1fr 220px;
        gap: 24px;
        align-items: flex-start;
    }
    .modal-body.finance { display: flex; flex-direction: column; gap: 16px; }
    .close-button {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 24px;
        padding: 0;
        line-height: 1;
        box-shadow: none;
    }
    @media (max-width: 640px) {
        .modal-body {
            grid-template-columns: 1fr;
        }
    }
  </style>
</head>
<body>
  <header>
    <div style="display:flex;gap:16px;align-items:center;justify-content:space-between;">
      <h1><i data-lucide="baseball" class="logo-icon"></i>PennantSim Lite Web v12</h1>
      <div style="display:flex;gap:8px;align-items:center;">
        <span class="pill">育成強化 / 士気・疲労・施設・特訓</span>
        <span class="mini" style="color:#64748b;">保存は自動 / ローカル</span>
      </div>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <section class="card">
        <div class="card-header"><h2><i data-lucide="calendar-days"></i>進行</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:8px;">
            <button id="btnGen" class="primary"><i data-lucide="calendar-plus"></i>新シーズン開始</button>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
              <button id="btnToday"><i data-lucide="play"></i>今日を進める</button>
              <button id="btnEnd"><i data-lucide="fast-forward"></i>最後まで</button>
            </div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin:12px 0;">
            <span class="pill" id="seasonLabel"></span>
            <span class="pill" id="dayLabel">Day -</span>
            <span class="pill" id="gamesLabel">カード 0 件</span>
          </div>
          <div id="todayMatchups" class="table-scroll" style="max-height:140px;"></div>
        </div>
      </section>

      <section class="card">
        <div class="card-header"><h2><i data-lucide="sliders-horizontal"></i>設定</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:12px;">
            <label style="display:flex;justify-content:space-between;align-items:center;">ホーム有利（%）<input id="homeAdv" style="width:80px;" type="number" min="0" max="15" step="1" value="5"></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">対戦回数<select id="repeats" style="width:80px;">
              <option>2</option><option>4</option><option selected>6</option><option>8</option>
            </select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">乱数シード<input id="seed" style="width:80px;" type="number" value="2025"></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">イベント頻度<select id="eventFrequency" style="width:160px;">
              <option value="low">控えめ</option>
              <option value="standard">標準</option>
              <option value="high">多め</option>
            </select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">シナリオテーマ<select id="eventTheme" style="width:160px;">
              <option value="balanced">バランス</option>
              <option value="heroic">ヒロイック</option>
              <option value="drama">ドラマティック</option>
              <option value="rivalry">ライバル重視</option>
            </select></label>
            <button id="btnReset" style="margin-top:8px; background: var(--bad); color: #fff; border-color: #c53030;"><i data-lucide="rotate-cw"></i>全データ初期化</button>
          </div>
        </div>
      </section>

      <!-- 操作設定: 自分チーム＆モード -->
      <section class="card">
        <div class="card-header"><h2><i data-lucide="gamepad-2"></i>操作設定</h2></div>
        <div class="card-content">
          <div class="controls" style="flex-direction:column;align-items:stretch;gap:8px;">
            <label style="display:flex;justify-content:space-between;align-items:center;">自分のチーム<select id="selUserTeam" style="width:220px;"></select></label>
            <label style="display:flex;justify-content:space-between;align-items:center;">モード<select id="modeSelect" style="width:220px;"><option value="user">自分チームのみ</option><option value="comm">コミッショナー</option></select></label>
          </div>
          <div class="mini" style="margin-top:6px;">※ 通常は自分のチームだけ操作可。コミッショナーは全チーム操作可。</div>
        </div>
      </section>

    </aside>

    <main class="main">
      <section class="card" id="dashboard-overview-card">
        <div class="card-header">
          <h2><i data-lucide="gauge"></i>シーズンダッシュボード</h2>
        </div>
        <div class="card-content">
          <div id="dashboard-overview">
            <div class="mini">ダッシュボードを読み込み中...</div>
            <div id="season-timeline" class="timeline-empty" style="display:none;">タイムラインを準備中...</div>
          </div>
        </div>
      </section>
      <section class="card" id="dashboard-panels-card">
        <div class="card-header">
          <h2><i data-lucide="layout-dashboard"></i>クラブインサイト</h2>
        </div>
        <div class="card-content">
          <div id="dashboard-tabs" class="dashboard-tabs" role="tablist">
            <button class="dashboard-tab" data-tab="season" role="tab" aria-selected="false"><i data-lucide="calendar"></i>シーズン</button>
            <button class="dashboard-tab" data-tab="finance" role="tab" aria-selected="false"><i data-lucide="wallet"></i>財務</button>
            <button class="dashboard-tab" data-tab="development" role="tab" aria-selected="false"><i data-lucide="sprout"></i>育成</button>
          </div>
          <div id="dashboard-panels" class="dashboard-panels">
            <div class="dashboard-panel" data-panel="season" role="tabpanel" aria-hidden="true">
              <div class="dashboard-panel-grid">
                <section class="dashboard-panel-card" data-panel-card="standings">
                  <header class="dashboard-panel-card-header"><i data-lucide="bar-chart-3"></i><span>順位表</span></header>
                  <div class="dashboard-panel-card-body" id="dashboard-standings"></div>
                </section>
                <section class="dashboard-panel-card" data-panel-card="playoffs" data-playoff-card>
                  <header class="dashboard-panel-card-header"><i data-lucide="trophy"></i><span>ポストシーズン</span></header>
                  <div class="dashboard-panel-card-body" id="dashboard-playoffs"></div>
                </section>
              </div>
            </div>
            <div class="dashboard-panel" data-panel="finance" role="tabpanel" aria-hidden="true">
              <section class="dashboard-panel-card" data-panel-card="finance">
                <header class="dashboard-panel-card-header"><i data-lucide="factory"></i><span>フロントオフィス</span></header>
                <div class="dashboard-panel-card-body" id="dashboard-front-office"></div>
              </section>
            </div>
            <div class="dashboard-panel" data-panel="development" role="tabpanel" aria-hidden="true">
              <div class="dashboard-panel-grid">
                <section class="dashboard-panel-card" data-panel-card="recent">
                  <header class="dashboard-panel-card-header"><i data-lucide="history"></i><span>直近の結果</span></header>
                  <div class="dashboard-panel-card-body" id="dashboard-recent"></div>
                </section>
                <section class="dashboard-panel-card" data-panel-card="highlights">
                  <header class="dashboard-panel-card-header"><i data-lucide="sparkles"></i><span>ハイライトフィード</span></header>
                  <div class="dashboard-panel-card-body" id="dashboard-highlights"></div>
                </section>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card" id="management-card">
        <div class="card-header">
          <h2><i data-lucide="users"></i>チーム管理 & 育成</h2>
          <select id="selTeamManage"></select>
        </div>
        <div class="tabs">
          <button class="tab active" data-tab="roster">ロスター</button>
          <button class="tab" data-tab="training">育成</button>
          <button class="tab" data-tab="stats">個人成績</button>
          <button class="tab" data-tab="draft">ドラフト</button>
          <button class="tab" data-tab="front">フロント</button>
          <button class="tab" data-tab="report">育成レポート</button>
        </div>
        <div id="management-content" class="card-content"></div>
      </section>
    </main>
  </div>

  <!-- Player Detail Modal -->
  <div id="playerDetailModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalPlayerName">Player Name</h3>
        <button id="modalCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="modalBody" class="modal-body">
        <!-- Content will be generated by JS -->
      </div>
    </div>
  </div>

  <!-- Game Recap Modal -->
  <div id="gameRecapModal" class="modal-overlay">
    <div class="modal-content game-recap">
      <div class="modal-header">
        <h3 id="gameRecapTitle">試合詳細</h3>
        <button id="gameRecapCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="gameRecapBody" class="modal-body game-recap">
        <!-- Filled dynamically -->
      </div>
    </div>
  </div>

  <!-- Finance Modal -->
  <div id="financeModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="financeModalTitle">フロントオフィス操作</h3>
        <button id="financeModalCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="financeModalBody" class="modal-body finance"></div>
    </div>
  </div>

  <!-- Roster Violation Modal -->
  <div id="rosterViolationModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="rosterViolationModalTitle">登録制限アラート</h3>
        <button id="rosterViolationCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="rosterViolationBody" class="modal-body" style="gap:16px;"></div>
    </div>
  </div>

  <!-- Scout Report Modal -->
  <div id="scoutReportModal" class="modal-overlay">
    <div class="modal-content scout-report">
      <div class="modal-header">
        <h3 id="scoutReportTitle">スカウトレポート</h3>
        <button id="scoutReportCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="scoutReportBody" class="modal-body scout-report"></div>
    </div>
  </div>

  <!-- Narrative Log Modal -->
  <div id="narrativeLogModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="narrativeLogTitle">士気イベントログ</h3>
        <button id="narrativeLogCloseBtn" class="close-button"><i data-lucide="x"></i></button>
      </div>
      <div id="narrativeLogBody" class="modal-body" style="display:flex; flex-direction:column; gap:16px; padding:24px;"></div>
    </div>
  </div>


<script type="module">
import LeagueRules from './src/core/rules.js';
import ScheduleBuilder, { normalizeScheduleEntries } from './src/core/schedule.js';
import { valuePlayerContract, normalizeContractTerms, negotiateContractOffer as evaluateNegotiation } from './src/systems/contracts.js';
import { determineFreeAgencyEligibility, rankFreeAgent, ensureFreeAgencyState, processFreeAgentSigning } from './src/systems/free_agency.js';
import {
  ensureDraftState as ensureDraftStateRecord,
  initializeDraft as initializeDraftState,
  submitBid as submitDraftBid,
  resolveFirstRound as resolveDraftFirstRound,
  selectProspect as selectDraftProspect,
  getOnClockTeamId as getDraftOnClockTeamId,
  getPendingFirstRoundTeams as getDraftPendingTeams,
  shouldResolveFirstRound as shouldResolveDraftFirstRound,
  isDraftOver as isDraftComplete,
  calculateTeamNeeds as calculateDraftTeamNeeds,
  getProspectNeedCategory as getDraftProspectNeedCategory,
} from './src/systems/draft.js';
import { validateForeignPlayerLimits } from './src/systems/roster_rules.js';
import { applyFarmEffects } from './src/systems/farm.js';
import {
  computeStaffAdjustments,
  ensureTeamStaff
} from './src/systems/staff.js';
import {
  computeFacilityAdjustments,
  ensureTeamFacilities,
  updateTeamFacilities
} from './src/systems/facilities.js';
import { applyAging as applyAgingSystem, progressPlayerAging, ensurePlayerAgingProfile } from './src/systems/aging.js';

const SupportSystems = {
  staff: { computeStaffAdjustments, ensureTeamStaff },
  facilities: { computeFacilityAdjustments, ensureTeamFacilities }
};

const AgingSystem = {
  applyAging: applyAgingSystem,
  progressPlayerAging,
  ensurePlayerAgingProfile
};

if (typeof window !== 'undefined') {
  window.PennantSimSupportSystems = SupportSystems;
  window.PennantSimAging = AgingSystem;
}
import {
  getSpecialById,
  normalizePlayerSpecials,
  playerHasSpecial,
  collectPlayerEffects,
  getPlayerEffects,
  findSpecialId,
  createPlateAppearanceSpecialEngine,
} from './src/systems/specials.js';
import SeasonSimulator, {
  describeStage as describeSeasonStage,
  getSeasonCalendar as getSeasonCalendarFromState,
  getCalendarEntry as getCalendarEntryFromState,
  updateSeasonStage as updateSeasonStageInState,
  maxDay as computeMaxDayForState,
  applyRestDayRecovery as applyRestDayRecoveryEngine,
  tickDay as tickSeasonDay,
  applyAllStarBreakDay as applyAllStarBreakDayEngine
} from './src/engine/sim_season.js';
import createScheduleView from './src/ui/views/ScheduleView.js';
import createContractsView from './src/ui/views/ContractsView.js';
import createDraftView from './src/ui/views/DraftView.js';
import createFAView from './src/ui/views/FAView.js';
import createStaffView from './src/ui/views/StaffView.js';
import createFacilitiesView from './src/ui/views/FacilitiesView.js';
import createFinanceView from './src/ui/views/FinanceView.js';
import { ensureTeamFans as ensureTeamFansState } from './src/systems/fans.js';
import { ensureSponsorDeals as ensureSponsorDealsState } from './src/systems/sponsors.js';
// ====== Helpers & State ======
const $=(s)=>document.querySelector(s); const $$=(s)=>[...document.querySelectorAll(s)];
const refreshIcons=()=>{ window?.lucide?.createIcons?.(); };
function resolveTarget(target, fallback){
  if(target instanceof HTMLElement) return target;
  if(typeof target==='string') return document.querySelector(target);
  if(fallback) return document.querySelector(fallback);
  return null;
}
const el=(t,a={},...c)=>{const n=document.createElement(t); for(const[k,v] of Object.entries(a)){ if(k==="class")n.className=v; else if(k==="html")n.innerHTML=v; else n.setAttribute(k,v);} for(const x of c)n.append(x); return n;};
let toastContainer=null;
function ensureToastContainer(){
  if(toastContainer && document.body.contains(toastContainer)) return toastContainer;
  toastContainer=document.querySelector('.toast-container');
  if(!toastContainer){
    toastContainer=el('div',{class:'toast-container'});
    document.body.append(toastContainer);
  }
  return toastContainer;
}
function showToast(message, options={}){
  if(!message) return null;
  const opts=options||{};
  const container=ensureToastContainer();
  const type=opts.type||'info';
  const duration=Math.max(1500, opts.duration||3200);
  const toast=el('div',{class:`toast ${type}`});
  toast.append(el('div',{class:'toast-title'}, document.createTextNode(message)));
  if(opts.description){
    toast.append(el('div',{class:'toast-desc'}, document.createTextNode(opts.description)));
  }
  container.append(toast);
  requestAnimationFrame(()=>toast.classList.add('visible'));
  const remove=()=>{
    toast.classList.remove('visible');
    setTimeout(()=>{ if(toast.parentElement) toast.remove(); },180);
  };
  const timer=setTimeout(remove,duration);
  toast.addEventListener('click',()=>{ clearTimeout(timer); remove(); });
  return toast;
}
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
function hashString(str){ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h>>>0; }
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const SAVE_KEY="pennantsim-lite-web-v12-training-plus";
const gameRecapKey=(day,home,away)=>`${day}-${home}-${away}`;
function parseGameRecapKey(key){ if(!key) return null; const [day,home,away]=key.split('-').map(Number); return {day,home_id:home,away_id:away}; }
function formatInnings(ip){ if(ip==null || Number.isNaN(Number(ip))) return '-'; return (Math.round(Number(ip)*10)/10).toFixed(1); }
const yenFormatter = new Intl.NumberFormat('ja-JP');
const millionFormatter = value => `¥${(value/1000000).toFixed(1)}M`;

const describeStage = describeSeasonStage;

function maxDay(){
  return computeMaxDayForState(State);
}

function getSeasonCalendar(){
  return getSeasonCalendarFromState(State);
}

function getCalendarEntry(day){
  return getCalendarEntryFromState(State, day);
}

function updateSeasonStage(stage, day){
  updateSeasonStageInState(State, stage, day);
}

function applyRestDayRecovery(){
  applyRestDayRecoveryEngine(State, { ensureTeamMeta, hasTrait, clamp, getPlayerEffects });
}

function tickDay(){
  return tickSeasonDay(State, {
    logHighlight,
    getCalendarEntry: (s, day) => getCalendarEntryFromState(s, day),
    maxDay: (s) => computeMaxDayForState(s),
    updateSeasonStage: (s, stage, day) => updateSeasonStageInState(s, stage, day),
    applyRestDayRecovery: (s) => applyRestDayRecoveryEngine(s, { ensureTeamMeta, hasTrait, clamp, getPlayerEffects }),
    handleAllStarBreak: (s, context) => applyAllStarBreakDayEngine(s, context, {
      ensureNarrativeState,
      logHighlight,
      ensureTeamMeta,
      ensureTeamFinances
    }),
    applyAging: (s, opts) => applyAgingSystem(s, opts)
  });
}

// ====== Sound Engine ======
let soundReady = false;
let soundFailed = false;
let synth;

async function setupSound() {
    if (soundReady || soundFailed) {
        return;
    }
    if (!window.Tone) {
        console.warn('Tone.js not available; sound disabled.');
        soundFailed = true;
        return;
    }
    try {
        await Tone.start();
        synth = new Tone.Synth({
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).toDestination();
        soundReady = true;
    } catch (err) {
        soundFailed = true;
        console.warn('Failed to initialize sound; continuing without audio.', err);
    }
}

function playSound(note, len = '16n') {
    if (soundReady && synth) {
        synth.triggerAttackRelease(note, len);
    }
}


const POSITIONS=["C","1B","2B","3B","SS","LF","CF","RF","DH"];
const INJURY_TYPES = [
    { name: '軽度の打撲', min: 3, max: 7, chance: 0.6 },
    { name: '捻挫', min: 10, max: 21, chance: 0.3 },
    { name: '肉離れ', min: 20, max: 40, chance: 0.08 },
    { name: '骨折', min: 50, max: 90, chance: 0.02 }
];

const baseTeams=[["読売ジャイアンツ","Central"],["阪神タイガース","Central"],["広島東洋カープ","Central"],["中日ドラゴンズ","Central"],["横浜DeNAベイスターズ","Central"],["東京ヤクルトスワローズ","Central"],["オリックス・バファローズ","Pacific"],["福岡ソフトバンクホークス","Pacific"],["北海道日本ハムファイターズ","Pacific"],["東北楽天ゴールデンイーグルス","Pacific"],["千葉ロッテマリーンズ","Pacific"],["埼玉西武ライオンズ","Pacific"]].map((t,i)=>({team:t[0],league:t[1],team_id:i,popularity:SeasonSimulator?.DEFAULT_TEAM_POPULARITY||60}));
function randHand(rng){ return (rng()<0.3)?"L":"R"; }
function randPos(rng){ const list=[["C",.1],["1B",.12],["2B",.13],["3B",.13],["SS",.13],["LF",.12],["CF",.14],["RF",.13]]; let r=rng(); for(const[p,w] of list){ if((r-=w)<=0) return p;} return "LF"; }

// ====== Name Generator (fictional) ======
const JP_SURNAMES = ["佐藤","鈴木","高橋","田中","伊藤","渡辺","山本","中村","小林","加藤","吉田","山田","佐々木","山口","斎藤","松本","井上","木村","林","清水","山崎","池田","橋本","阿部","森","山下","石井","石川","前田","藤田","青木","後藤","長谷川","近藤","村上","石田","小野","原","中川","岡田","長野","柴田","内田","中島","酒井","宮崎","竹内","藤井","松田","小島","堀"];
const JP_GIVEN = ["大輔","翔太","健太","拓也","直樹","亮","徹","陽介","悠斗","颯太","蓮","海斗","一輝","拓海","大地","悠真","悠生","俊介","剛","智也","祐介","圭太","航","航太","恭平","誠","和也","優","優斗","悠人","匠","隼人","駿","魁","渓","直人","将太","啓太","弘樹","大智"];
const KATA_FIRST = ["カルロス","ホセ","ルイス","ミゲル","ラウル","フリオ","エドガー","オスカル","ハビエル","フェルナンド","アレックス","ブライアン","デービッド","ジョン","ヘンリー","ダニエル","ニコラス","アンドリュー","マイケル","フランク","マルコ","レオナルド","クリスチャン","ジョルダン","イバン","アルベルト","ロベルト","ロドリゴ","セサル","ディエゴ","カミロ"];
const KATA_LAST = ["ガルシア","ロドリゲス","サンチェス","ゴメス","マルティネス","モラレス","カスティーヨ","エルナンデス","ペレス","ゴンザレス","ブラウン","スミス","ジョンソン","リー","キム","パク","チェン","ワン","リウ","チャン","リベラ","カブレラ","ソト","ラミレス","アルバレス"];
function makeFictionalIdentity(rng, used){
  function pick(arr){ return arr[Math.floor(rng()*arr.length)]; }
  const isForeign = rng() < 0.18; // 18% 外国人風
  const origin = isForeign ? 'international' : 'domestic';
  let name;
  if(isForeign){ name = `${pick(KATA_FIRST)}・${pick(KATA_LAST)}`; }
  else { name = `${pick(JP_SURNAMES)}${pick(JP_GIVEN)}`; }
  let tries=0; while(used.has(name) && tries<6){ if(isForeign){ name = `${pick(KATA_FIRST)}・${pick(KATA_LAST)}`; } else { name = `${pick(JP_SURNAMES)}${pick(JP_GIVEN)}`; } tries++; }
  used.add(name);
  return { name, isForeign, origin };
}
function makeFictionalName(rng, used){
  return makeFictionalIdentity(rng, used).name;
}

function getOverall(p) {
    const isPitcher = !!p.velo;
    return isPitcher ?
        (p.velo * 0.3 + p.ctrl * 0.3 + p.mov * 0.3 + p.stam * 0.1) :
        (p.con * 0.3 + p.disc * 0.1 + p.pwr * 0.3 + p.spd * 0.15 + p.fld * 0.15);
}

function randomPersona(rng=Math.random){
  const roll=(base,spread,bias=0)=>{
    const swing=(rng()-0.5)*spread;
    const variance=(rng()-0.5)*(spread*0.6);
    return clamp(Math.round(base + swing + variance + bias),0,100);
  };
  return {
    greed: roll(52, 36),
    loyalty: roll(50, 34),
    winDesire: roll(56, 38),
  };
}

function ensurePlayerPersona(player, rng){
  if(!player || typeof player !== 'object') return null;
  if(player.persona && typeof player.persona === 'object'){
    const src=player.persona;
    const resolve=(value, fallback)=>{
      const num=Number(value);
      return clamp(Math.round(Number.isFinite(num)?num:fallback),0,100);
    };
    player.persona={
      greed: resolve(src.greed, 52),
      loyalty: resolve(src.loyalty, 50),
      winDesire: resolve(src.winDesire, 56),
    };
    return player.persona;
  }
  let generator=null;
  if(typeof rng==='function'){
    generator=rng;
  } else if(Number.isFinite(rng)){
    generator=mulberry32((rng>>>0));
  }
  if(!generator){
    const key=player.id || player.name || `${Date.now()}`;
    generator=mulberry32(hashString(String(key))>>>0);
  }
  player.persona=randomPersona(generator);
  return player.persona;
}

function mkInitialRoster(team_id, seed=2025){
  const rng = mulberry32(team_id*101 + seed);
  const bats = [], pits = [];
  const used = new Set(); // チーム内の重複名を避ける
  for(let i=0;i<18;i++){
    const identity = makeFictionalIdentity(rng, used);
    const player = {
      id:`B${team_id}-${i}`, name: identity.name, age: 20 + Math.floor(rng()*14), hand: randHand(rng),
      pos: randPos(rng),
      con: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), disc: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pwr: clamp(55 + Math.floor(rng()*20 - 10), 30, 99),
      spd: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), fld: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pot: clamp(60 + Math.floor(rng()*25 - 12), 45, 99),
      traits:[], morale:60+Math.floor(rng()*20), fatigue:20+Math.floor(rng()*10), injury: null, recentGains: [],
      farmReveal: 0, farmLog: [], farmLast: null,
      popularity: SeasonSimulator?.DEFAULT_PLAYER_POPULARITY || 55,
      isForeign: identity.isForeign,
      origin: identity.origin
    };
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale], farmReveal: [0] };
    ensurePlayerPersona(player, rng);
    bats.push(player);
  }
  for(let i=0;i<14;i++){
    const identity = makeFictionalIdentity(rng, used);
    const player = {
      id:`P${team_id}-${i}`, name: identity.name, age: 20 + Math.floor(rng()*14),
      role: (rng()<0.6?"SP":"RP"), hand: randHand(rng),
      velo: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), ctrl: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), mov: clamp(55 + Math.floor(rng()*20 - 10), 30, 99),
      stam: clamp(55 + Math.floor(rng()*20 - 10), 30, 99), pot: clamp(60 + Math.floor(rng()*25 - 12), 45, 99),
      traits:[], morale:60+Math.floor(rng()*20), fatigue:20+Math.floor(rng()*10), sub_role: null, injury: null, recentGains: [],
      farmReveal: 0, farmLog: [], farmLast: null,
      popularity: SeasonSimulator?.DEFAULT_PLAYER_POPULARITY || 55,
      isForeign: identity.isForeign,
      origin: identity.origin
    };
    if (player.role === 'RP') player.sub_role = '中継ぎ';
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale], farmReveal: [0] };
    ensurePlayerPersona(player, rng);
    pits.push(player);
  }
  return {bats,pits};
}

// ====== Financial Defaults & Contracts ======
const BUDGET_CATEGORIES = ["payroll", "staff", "facilities", "marketing"];
const STAFF_COSTS = { coaches: 28000000, scouts: 18000000, analysts: 16000000, marketing: 14000000 };
const DEFAULT_TICKET_PRICE = 3200;
const DEFAULT_STADIUM_CAPACITY = 42000;
const TEAM_NEGOTIATION_POSTURES = ['strong','standard','lenient'];

function defaultBudgetAllocations(){
  return { payroll: 0.55, staff: 0.18, facilities: 0.17, marketing: 0.10 };
}

function defaultTeamFinance(tid){
  return {
    team_id: tid,
    budget: { total: 12000000000, allocations: defaultBudgetAllocations(), reserves: 4200000000 },
    revenue: { ticket: 0, merch: 0, media: 0, other: 0, total: 0 },
    expenses: { payroll: 0, staff: 0, facilities: 0, marketing: 0, total: 0 },
    attendance: { capacity: DEFAULT_STADIUM_CAPACITY, seasonTotal: 0, average: 0, lastGame: 0, forecast: 0, homeGames: 0 },
    ticketPrice: DEFAULT_TICKET_PRICE,
    contracts: [],
    staff: { coaches: 3, scouts: 2, analysts: 1, marketing: 2 },
    ledger: [],
    popularity: SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60,
    negotiationPosture: 'standard'
  };
}

function estimatePlayerSalary(player){
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  return market.AAV;
}

function deriveContractLength(player, rand=Math.random){
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  let years = market.years;
  if(rand() > 0.7 && years < 6) years++;
  if(rand() < 0.12 && years > 1) years--;
  return clamp(Math.round(years), 1, 6);
}

function normalizeContract(contract, player, tid, season){
  const existing = { ...(contract || {}) };
  const market = valuePlayerContract(player, { overall: getOverall(player) });
  const normalizedTerms = normalizeContractTerms(existing, { defaults: market });
  const startSeason = existing.startSeason ?? season;
  const normalizedYears = clamp(normalizedTerms.years ?? 1, 1, 6);
  const totalYears = clamp(existing.totalYears ?? existing.years ?? normalizedYears, 1, 6);
  const expirySeason = existing.expirySeason ?? (startSeason != null ? startSeason + totalYears - 1 : undefined);
  let yearsRemaining = existing.yearsRemaining;
  if(!Number.isFinite(yearsRemaining)){
    if(expirySeason != null && season != null){
      yearsRemaining = expirySeason - season + 1;
    } else {
      yearsRemaining = totalYears;
    }
  }
  yearsRemaining = Math.max(0, Math.min(totalYears, Math.round(yearsRemaining)));
  const status = existing.status || 'active';
  const normalized = {
    ...existing,
    playerId: player.id,
    playerName: player.name,
    team_id: tid,
    startSeason,
    totalYears,
    years: normalizedYears,
    yearsRemaining,
    expirySeason,
    status,
    type: existing.type || 'standard',
    AAV: normalizedTerms.AAV,
    salary: normalizedTerms.AAV,
    incentives: normalizedTerms.incentives,
    noTradeClause: normalizedTerms.noTradeClause,
    expectedAnnual: normalizedTerms.expectedAnnual,
    totalValue: normalizedTerms.AAV * totalYears,
  };
  if(normalized.status === 'active' && normalized.yearsRemaining <= 1 && normalized.daysRemaining == null){
    normalized.daysRemaining = 90;
  }
  return normalized;
}

function ensurePlayerContract(player, tid, season, rand=Math.random){
  let contract = player.contract;
  if(!contract || typeof contract !== 'object'){
    const market = valuePlayerContract(player, { overall: getOverall(player) });
    contract = {
      AAV: market.AAV,
      years: market.years,
      incentives: market.incentives,
      noTradeClause: market.noTradeClause,
      totalYears: market.years,
      yearsRemaining: market.years,
      startSeason: season,
      status: 'active',
      type: 'standard'
    };
  }
  if(contract.totalYears && !contract.yearsRemaining){
    contract.yearsRemaining = contract.totalYears;
  }
  if(!contract.totalYears && contract.yearsRemaining){
    contract.totalYears = contract.yearsRemaining;
  }
  if(!contract.startSeason){
    contract.startSeason = season;
  }
  contract = normalizeContract(contract, player, tid, season);
  player.contract = { ...contract };
  return contract;
}

function contractSummary(contract, player){
  const incentives = contract.incentives && typeof contract.incentives === 'object'
    ? JSON.parse(JSON.stringify(contract.incentives))
    : { playingTime: 0, performance: 0, awards: 0, total: 0, expectedPayout: 0 };
  const summary = {
    playerId: player.id,
    name: player.name,
    AAV: contract.AAV ?? 0,
    salary: contract.AAV ?? 0,
    incentives,
    expectedAnnual: contract.expectedAnnual ?? ((contract.AAV ?? 0) + (incentives.expectedPayout || 0)),
    yearsRemaining: contract.yearsRemaining ?? contract.totalYears ?? contract.years ?? 0,
    totalYears: contract.totalYears ?? contract.years ?? 0,
    status: contract.status ?? 'active',
    type: contract.type ?? 'standard',
    expirySeason: contract.expirySeason,
    daysRemaining: contract.daysRemaining ?? null,
    role: player.velo ? '投手' : '野手',
    noTradeClause: !!contract.noTradeClause,
    totalValue: contract.totalValue ?? ((contract.AAV ?? 0) * (contract.totalYears ?? contract.years ?? 1)),
  };
  return summary;
}

function normalizeFinanceObject(finance){
  if(!finance) return defaultTeamFinance(0);
  finance.budget = finance.budget || {};
  finance.budget.total = finance.budget.total || 12000000000;
  finance.budget.allocations = { ...defaultBudgetAllocations(), ...(finance.budget.allocations||{}) };
  finance.budget.reserves = finance.budget.reserves ?? Math.round(finance.budget.total * 0.35);
  const rev = finance.revenue || {};
  finance.revenue = { ticket: rev.ticket||0, merch: rev.merch||0, media: rev.media||0, other: rev.other||0, total: rev.total||0 };
  const exp = finance.expenses || {};
  finance.expenses = { payroll: exp.payroll||0, staff: exp.staff||0, facilities: exp.facilities||0, marketing: exp.marketing||0, total: exp.total||0 };
  finance.attendance = { capacity:DEFAULT_STADIUM_CAPACITY, seasonTotal:0, average:0, lastGame:0, forecast:0, homeGames:0, ...(finance.attendance||{}) };
  finance.ticketPrice = finance.ticketPrice || DEFAULT_TICKET_PRICE;
  finance.contracts = Array.isArray(finance.contracts) ? finance.contracts : [];
  finance.staff = { coaches:3, scouts:2, analysts:1, marketing:2, ...(finance.staff||{}) };
  finance.ledger = Array.isArray(finance.ledger) ? finance.ledger : [];
  finance.popularity = typeof finance.popularity === 'number'
    ? clamp(finance.popularity, 0, 100)
    : (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60);
  const postureKey = typeof finance.negotiationPosture === 'string' ? finance.negotiationPosture.toLowerCase() : 'standard';
  finance.negotiationPosture = TEAM_NEGOTIATION_POSTURES.includes(postureKey) ? postureKey : 'standard';
  if(finance.attendance.capacity < 10000) finance.attendance.capacity = DEFAULT_STADIUM_CAPACITY;
  return finance;
}

function syncFinanceContracts(finance, roster, season){
  if(!roster) return;
  const next=[];
  roster.bats.forEach(player=>{
    const c=ensurePlayerContract(player, finance.team_id, season);
    next.push(contractSummary(c, player));
  });
  roster.pits.forEach(player=>{
    const c=ensurePlayerContract(player, finance.team_id, season);
    next.push(contractSummary(c, player));
  });
  next.sort((a,b)=> (b.expectedAnnual||b.AAV||0) - (a.expectedAnnual||a.AAV||0));
  finance.contracts = next;
}

function normalizeTeamFinances(state){
  if(!state.teamFinances) state.teamFinances={};
  const season = state.season || 1;
  (state.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const finance = normalizeFinanceObject(state.teamFinances[tid] || defaultTeamFinance(tid));
    finance.team_id = tid;
    syncFinanceContracts(finance, state.rosters?.[tid], season);
    if(!finance.budget.allocations || Object.keys(finance.budget.allocations).length===0){
      finance.budget.allocations = defaultBudgetAllocations();
    }
    state.teamFinances[tid]=finance;
  });
  if(!Array.isArray(state.freeAgents)) state.freeAgents=[];
  return state.teamFinances;
}

function normalizeRosterPlayers(state){
  if(!state || typeof state !== 'object') return;
  const applyPersona=(player)=>{
    if(!player || typeof player !== 'object') return;
    if(!player.history){
      player.history={ overall:[getOverall(player)], fatigue:[player.fatigue||20], morale:[player.morale||60], farmReveal:[clamp(Math.round(player.farmReveal||0),0,100)] };
    } else {
      if(!Array.isArray(player.history.overall)) player.history.overall=[getOverall(player)];
      if(!Array.isArray(player.history.fatigue)) player.history.fatigue=[player.fatigue||20];
      if(!Array.isArray(player.history.morale)) player.history.morale=[player.morale||60];
      if(!Array.isArray(player.history.farmReveal)) player.history.farmReveal=[clamp(Math.round(player.farmReveal||0),0,100)];
    }
    if(!Number.isFinite(player.farmReveal)) player.farmReveal = 0;
    player.farmReveal = clamp(Math.round(player.farmReveal), 0, 100);
    if(!Array.isArray(player.farmLog)) player.farmLog = [];
    else if(player.farmLog.length > 8) player.farmLog.splice(0, player.farmLog.length - 8);
    if(player.farmLast && typeof player.farmLast !== 'object') player.farmLast = null;
    if(player.farmLast){
      player.farmLast.traitUnlocks = Array.isArray(player.farmLast.traitUnlocks) ? player.farmLast.traitUnlocks : [];
    }
    if(!Array.isArray(player.recentGains)) player.recentGains=[];
    if(typeof player.isForeign !== 'boolean') player.isForeign = Boolean(player.isForeign);
    if(!player.origin) player.origin = player.isForeign ? 'international' : 'domestic';
    if(player.lastSquadMoveDay !== null && player.lastSquadMoveDay !== undefined){
      const parsed=Number(player.lastSquadMoveDay);
      player.lastSquadMoveDay=Number.isFinite(parsed)?parsed:null;
    } else {
      player.lastSquadMoveDay=null;
    }
    ensurePlayerPersona(player);
  };
  Object.values(state.rosters||{}).forEach(roster=>{
    if(!roster) return;
    (roster.bats||[]).forEach(applyPersona);
    (roster.pits||[]).forEach(applyPersona);
  });
  if(Array.isArray(state.freeAgents)) state.freeAgents.forEach(applyPersona);
}

function normalizeNarrativeState(state){
  if(!state) return;
  if(!state.narrativeSettings || typeof state.narrativeSettings !== 'object'){
    state.narrativeSettings = { frequency: 'standard', theme: 'balanced' };
  } else {
    state.narrativeSettings.frequency = state.narrativeSettings.frequency || 'standard';
    state.narrativeSettings.theme = state.narrativeSettings.theme || 'balanced';
  }
  if(!state.teamNarratives || typeof state.teamNarratives !== 'object') state.teamNarratives = {};
  if(!Array.isArray(state.narrativeLog)) state.narrativeLog = [];
  (state.teams||[]).forEach(team=>{
    const tid = team.team_id;
    const bucket = state.teamNarratives[tid] || {};
    bucket.morale = Array.isArray(bucket.morale) ? bucket.morale : [];
    bucket.events = Array.isArray(bucket.events) ? bucket.events : [];
    state.teamNarratives[tid] = bucket;
  });
}

function defaultSeasonInfo(){
  return {
    calendar: [],
    stage: 'PRE',
    dayLookup: {},
    stageBounds: {},
    regularSeasonEnd: 0,
    gamesPerTeam: 0
  };
}

function computeRegularSeasonEnd(info){
  if(!info || !Array.isArray(info.calendar)) return 0;
  let maxDay = 0;
  info.calendar.forEach(entry => {
    if(!entry || typeof entry !== 'object') return;
    const day = entry.date ?? entry.day ?? 0;
    if(entry.stage === 'CS' || entry.stage === 'JS') return;
    if(entry.stage === 'AS'){
      maxDay = Math.max(maxDay, day);
      return;
    }
    const hasMatchups = Array.isArray(entry.matchups) && entry.matchups.length > 0;
    if(hasMatchups || entry.stage === 'REG' || entry.stage === 'IL'){
      maxDay = Math.max(maxDay, day);
    }
  });
  return maxDay;
}

function rebuildSeasonCalendarInfo(info){
  const data = info && typeof info === 'object' ? info : defaultSeasonInfo();
  const calendar = Array.isArray(data.calendar) ? data.calendar : [];
  const lookup = {};
  const normalized = calendar.map((entry, idx)=>{
    if(!entry || typeof entry !== 'object') return { date: idx+1, stage: 'REG', matchups: [] };
    const date = typeof entry.date === 'number' ? entry.date : (typeof entry.day === 'number' ? entry.day : idx + 1);
    const stage = entry.stage || 'REG';
    const matchups = Array.isArray(entry.matchups) ? entry.matchups : [];
    const normalizedEntry = { ...entry, date, stage, matchups };
    lookup[date] = idx;
    return normalizedEntry;
  });
  data.calendar = normalized;
  data.dayLookup = lookup;
  data.stageBounds = (data.stageBounds && typeof data.stageBounds === 'object') ? data.stageBounds : {};
  data.regularSeasonEnd = computeRegularSeasonEnd(data);
  data.stage = data.stage || (data.calendar[0]?.stage || 'PRE');
  data.gamesPerTeam = typeof data.gamesPerTeam === 'number' ? data.gamesPerTeam : 0;
  data.totalsByTeam = (data.totalsByTeam && typeof data.totalsByTeam === 'object') ? data.totalsByTeam : {};
  return data;
}

function normalizeSeasonInfo(state){
  if(!state || typeof state !== 'object') return;
  if(!state.seasonInfo || typeof state.seasonInfo !== 'object'){
    state.seasonInfo = defaultSeasonInfo();
  }
  state.seasonInfo = rebuildSeasonCalendarInfo(state.seasonInfo);
  return state.seasonInfo;
}

function defaultLeagueState(){
  return {
    name: 'NPB',
    rules: LeagueRules.createDefaultRules()
  };
}

function normalizeLeagueState(state){
  if(!state || typeof state !== 'object') return;
  if(!state.league || typeof state.league !== 'object'){
    state.league = defaultLeagueState();
  }
  state.league.rules = LeagueRules.normalizeRules(state.league.rules);
  return state.league;
}

function ensureTeamFinances(){
  if(typeof State === 'undefined') return;
  return normalizeTeamFinances(State);
}

function ensureFreeAgents(){
  ensureFreeAgencyState(State);
  if(!Array.isArray(State.freeAgents)) State.freeAgents=[];
  return State.freeAgents;
}

function teamRecord(tid){
  const results = State.results || [];
  let wins=0, losses=0;
  results.forEach(res=>{
    if(res.home_id===tid || res.away_id===tid){
      if(res.winner_id===tid) wins++; else losses++;
    }
  });
  return { wins, losses, total: wins+losses };
}

function computeTeamPayroll(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return 0;
  return finance.contracts
    .filter(c=>c.status!=='expired')
    .reduce((sum,c)=>{
      const annual = c.expectedAnnual ?? ((c.AAV||0) + (c.incentives?.expectedPayout||0));
      return sum + annual;
    },0);
}

function computeAttendanceForecast(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return 0;
  const record = teamRecord(tid);
  const winPct = record.total ? record.wins / record.total : 0.5;
  const marketing = finance.budget?.allocations?.marketing ?? 0.1;
  const roster = State.rosters[tid];
  let morale = 65;
  if(roster){
    const players = [...roster.bats, ...roster.pits];
    if(players.length){
      morale = players.reduce((s,p)=>s+(p.morale||60),0)/players.length;
    }
  }
  const moraleFactor = clamp(morale/80, 0.7, 1.35);
  const base = finance.attendance?.capacity || DEFAULT_STADIUM_CAPACITY;
  const forecast = Math.round(clamp(base * (0.45 + winPct * 0.4 + marketing * 0.3) * moraleFactor, 8000, base));
  finance.attendance.forecast = forecast;
  return forecast;
}

function updateFinancialSnapshots(tid){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  finance.expenses.payroll = computeTeamPayroll(tid);
  const staff = finance.staff || {};
  finance.expenses.staff = (staff.coaches||0)*STAFF_COSTS.coaches + (staff.scouts||0)*STAFF_COSTS.scouts + (staff.analysts||0)*STAFF_COSTS.analysts + (staff.marketing||0)*STAFF_COSTS.marketing;
  const facilityBase = finance.budget.total * (finance.budget.allocations.facilities||0) * 0.05;
  finance.expenses.facilities = Math.round(facilityBase);
  const marketingSpend = finance.budget.total * (finance.budget.allocations.marketing||0) * 0.04;
  finance.expenses.marketing = Math.round(marketingSpend);
  finance.expenses.total = finance.expenses.payroll + finance.expenses.staff + finance.expenses.facilities + finance.expenses.marketing;
  finance.revenue.total = (finance.revenue.ticket||0) + (finance.revenue.merch||0) + (finance.revenue.media||0) + (finance.revenue.other||0);
  computeAttendanceForecast(tid);
}

function estimateGameAttendance(homeTid, awayTid){
  const finance = State.teamFinances[homeTid];
  if(!finance) return 12000;
  const baseForecast = computeAttendanceForecast(homeTid) || finance.attendance.capacity;
  const awayTeam = State.teams.find(t=>t.team_id===awayTid);
  const opponentDraw = awayTeam ? clamp(((awayTeam.power||60) - 50)/200, -0.05, 0.12) : 0;
  const rivalryBoost = awayTeam && awayTeam.league === State.teams.find(t=>t.team_id===homeTid)?.league ? 0.05 : 0;
  const forecast = Math.round(clamp(baseForecast * (1 + opponentDraw + rivalryBoost), 6000, finance.attendance.capacity));
  return forecast;
}

function applyGameFinancials(res){
  ensureTeamFinances();
  const homeFin = State.teamFinances[res.home_id];
  const awayFin = State.teamFinances[res.away_id];
  if(!homeFin || !awayFin) return;
  const attendance = estimateGameAttendance(res.home_id, res.away_id);
  homeFin.attendance.lastGame = attendance;
  homeFin.attendance.seasonTotal += attendance;
  homeFin.attendance.homeGames = (homeFin.attendance.homeGames||0) + 1;
  homeFin.attendance.average = Math.round(homeFin.attendance.seasonTotal / homeFin.attendance.homeGames);
  const ticketRevenue = Math.round(attendance * (homeFin.ticketPrice || DEFAULT_TICKET_PRICE));
  const homeShare = Math.round(ticketRevenue * 0.82);
  const awayShare = ticketRevenue - homeShare;
  homeFin.revenue.ticket += homeShare;
  awayFin.revenue.ticket += awayShare;
  homeFin.budget.reserves = (homeFin.budget.reserves||0) + homeShare;
  awayFin.budget.reserves = (awayFin.budget.reserves||0) + awayShare;
  homeFin.ledger.push({ day: res.day, type:'income', amount: homeShare, label:'入場料収入' });
  awayFin.ledger.push({ day: res.day, type:'income', amount: awayShare, label:'ビジター配分' });
  if(homeFin.ledger.length>200) homeFin.ledger.shift();
  if(awayFin.ledger.length>200) awayFin.ledger.shift();
  const merchBoost = Math.round(attendance * (res.winner_id===res.home_id ? 480 : 320));
  if(res.winner_id===res.home_id) homeFin.revenue.merch += merchBoost; else awayFin.revenue.merch += merchBoost;
  updateFinancialSnapshots(res.home_id);
  updateFinancialSnapshots(res.away_id);
  if(attendance >= Math.round((homeFin.attendance.capacity||DEFAULT_STADIUM_CAPACITY) * 0.95)){
    logHighlight('ticket', `【満員御礼】${id2name(res.home_id)}の主催試合に${attendance.toLocaleString()}人が集まりました！`, { category:'finance', financeType:'attendance', day: res.day });
  }
}

function updateDailyFinancials(day, gamesToday, restDay){
  ensureTeamFinances();
  const teams = State.teams.map(t=>t.team_id);
  teams.forEach(tid=>{
    const finance = State.teamFinances[tid];
    if(!finance) return;
    const dailyPayroll = Math.round((finance.expenses.payroll||0) / Math.max(180, State.schedule.length||180));
    const dailyStaff = Math.round((finance.expenses.staff||0)/210);
    const dailyFacilities = Math.round((finance.expenses.facilities||0)/240);
    const dailyMarketing = Math.round((finance.expenses.marketing||0)/180);
    const dailyExpenses = dailyPayroll + dailyStaff + dailyFacilities + dailyMarketing;
    finance.budget.reserves = (finance.budget.reserves||0) - dailyExpenses;
    finance.expenses.total += dailyExpenses;
    finance.ledger.push({ day, type:'expense', amount: dailyExpenses, label:'日次運営費' });
    if(finance.ledger.length>200) finance.ledger.shift();
    if(!restDay && gamesToday.some(evt=>evt.home_id===tid)){
      // ticket revenue handled in applyGameFinancials
    } else {
      // even on休養日 marketing活動
      const passiveRev = Math.round((finance.ticketPrice||DEFAULT_TICKET_PRICE) * (finance.attendance.forecast||12000) * 0.05);
      finance.revenue.media += passiveRev;
      finance.budget.reserves = (finance.budget.reserves||0) + passiveRev;
      finance.ledger.push({ day, type:'income', amount: passiveRev, label:'メディア収入' });
      if(finance.ledger.length>200) finance.ledger.shift();
    }
    if(finance.budget.reserves < -500000000){
      logHighlight('alert-circle', `【財務危機】${id2name(tid)}の運転資金が大幅なマイナスに転落しました。`, { category:'finance', financeType:'budget', day });
    }
    updateFinancialSnapshots(tid);
  });
}

function purgeFinanceContract(tid, playerId){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  finance.contracts = finance.contracts.filter(c=>c.playerId!==playerId);
}

function upsertFinanceContract(tid, player, contract){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return;
  const summary = contractSummary(contract, player);
  const idx = finance.contracts.findIndex(c=>c.playerId===player.id);
  if(idx>=0) finance.contracts[idx]=summary; else finance.contracts.push(summary);
  finance.contracts.sort((a,b)=> (b.expectedAnnual||b.AAV||0) - (a.expectedAnnual||a.AAV||0));
  updateFinancialSnapshots(tid);
}

function removePlayerFromRoster(tid, playerId){
  const roster = State.rosters[tid];
  if(!roster) return null;
  let removed=null;
  let idx=roster.bats.findIndex(p=>p.id===playerId);
  if(idx>=0){ removed=roster.bats.splice(idx,1)[0]; }
  else {
    idx=roster.pits.findIndex(p=>p.id===playerId);
    if(idx>=0) removed=roster.pits.splice(idx,1)[0];
  }
  if(removed){
    if(State.squads?.[tid]){
      State.squads[tid].ichi = State.squads[tid].ichi.filter(id=>id!==playerId);
      State.squads[tid].ni = State.squads[tid].ni.filter(id=>id!==playerId);
    }
    if(State.rotation?.[tid]){
      State.rotation[tid].order = (State.rotation[tid].order||[]).filter(id=>id!==playerId);
    }
  }
  evaluateRosterComplianceForTeam(tid);
  return removed;
}

function addPlayerToRoster(tid, player){
  if(!State.rosters[tid]) State.rosters[tid]={bats:[],pits:[]};
  const roster = State.rosters[tid];
  const target = player.velo!=null ? roster.pits : roster.bats;
  if(!player.history) player.history = { overall:[getOverall(player)], fatigue:[player.fatigue||20], morale:[player.morale||60] };
  if(!player.recentGains) player.recentGains = [];
  ensurePlayerPersona(player);
  target.push(player);
  if(State.squadsInit && State.squads){
    if(!State.squads[tid]) State.squads[tid]={ichi:[],ni:[]};
    if(!State.squads[tid].ni.includes(player.id) && !State.squads[tid].ichi.includes(player.id)){
      State.squads[tid].ni.push(player.id);
    }
  }
  if(typeof ensureTrainingDefaults === 'function') ensureTrainingDefaults(tid);
  evaluateRosterComplianceForTeam(tid);
  return player;
}

function ensureRosterComplianceStore(){
  if(!State.rosterCompliance || typeof State.rosterCompliance !== 'object'){
    State.rosterCompliance = {};
  }
  return State.rosterCompliance;
}

function evaluateRosterComplianceForTeam(tid, { persist = true } = {}){
  ensureRosterComplianceStore();
  if(tid == null) return null;
  ensureSquads();
  const roster = State.rosters?.[tid];
  const squads = State.squads?.[tid];
  if(!roster || !squads){
    if(persist) delete State.rosterCompliance[tid];
    return null;
  }
  const validation = validateForeignPlayerLimits({
    bats: roster.bats,
    pits: roster.pits,
    activeIds: squads.ichi,
  }, State.league?.rules ?? {});
  const enriched = {
    ...validation,
    teamId: tid,
    timestamp: Date.now(),
  };
  if(persist){
    State.rosterCompliance[tid] = enriched;
  }
  if(!enriched.errors.length){
    hideRosterViolationModal();
  }
  if(persist) updateAdvanceButtonsState();
  return enriched;
}

function refreshRosterComplianceAll({ persist = true } = {}){
  ensureRosterComplianceStore();
  const results = {};
  (State.teams||[]).forEach(team => {
    const tid = team.team_id;
    const result = evaluateRosterComplianceForTeam(tid, { persist });
    if(result) results[tid] = result;
  });
  if(persist) updateAdvanceButtonsState();
  return persist ? State.rosterCompliance : results;
}

function getRosterCompliance(tid, { refresh = false } = {}){
  ensureRosterComplianceStore();
  if(refresh || !State.rosterCompliance[tid]){
    return evaluateRosterComplianceForTeam(tid, { persist: true });
  }
  return State.rosterCompliance[tid] || null;
}

function hasBlockingRosterViolations(tid = State.userTeamId ?? 0){
  ensureRosterComplianceStore();
  const record = State.rosterCompliance?.[tid];
  return Boolean(record && Array.isArray(record.errors) && record.errors.length>0);
}

function updateAdvanceButtonsState(){
  const disabled = hasBlockingRosterViolations();
  const btnToday = document.querySelector('#btnToday');
  if(btnToday) btnToday.disabled = disabled;
  const btnEnd = document.querySelector('#btnEnd');
  if(btnEnd) btnEnd.disabled = disabled;
}

function releasePlayerToFreeAgency(tid, playerId, reason='契約満了'){
  ensureFreeAgents();
  const player = removePlayerFromRoster(tid, playerId);
  if(!player) return null;
  purgeFinanceContract(tid, playerId);
  if(player.contract){
    player.contract.team_id = null;
    player.contract.status = 'free-agent';
    player.contract.yearsRemaining = 0;
    player.contract.daysRemaining = null;
  }
  const faState = ensureFreeAgencyState(State);
  const eligibility = determineFreeAgencyEligibility(player);
  const rankInfo = rankFreeAgent(player);
  const salaryHistory = Array.isArray(player.freeAgency?.salaryHistory)
    ? player.freeAgency.salaryHistory.slice(-4)
    : [];
  const currentSalary = player.contract?.AAV ?? player.contract?.salary ?? null;
  if(Number.isFinite(currentSalary)){
    salaryHistory.push(Number(currentSalary));
  }
  const metadata = {
    ...(player.freeAgency || {}),
    ...eligibility,
    ...rankInfo,
    salaryHistory,
    lastTeamId: tid,
    originTid: tid,
    declaredSeason: State.season ?? null,
    declaredDay: State.curr_day ?? null,
    compensation: null,
    status: 'free-agent',
  };
  player.freeAgency = metadata;
  faState.players[player.id] = {
    playerId: player.id,
    playerName: player.name,
    ...metadata,
  };
  State.freeAgents.push(player);
  logHighlight('badge-alert', `【${reason}】${player.name}がFA市場に出ました。`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
  recomputeAllRatingsAll();
  return player;
}

function negotiateContract(tid, playerId, offer={}){
  ensureTeamFinances();
  const finance = State.teamFinances[tid];
  if(!finance) return { success:false, reason:'no finance' };
  const teamPosture = finance.negotiationPosture || 'standard';
  let player = findPlayerById(tid, playerId);
  let isFreeAgent=false;
  let faIndex=-1;
  if(!player){
    ensureFreeAgents();
    faIndex = State.freeAgents.findIndex(p=>p.id===playerId);
    if(faIndex>=0){ player = State.freeAgents[faIndex]; isFreeAgent=true; }
  }
  if(!player) return { success:false, reason:'player not found' };
  ensurePlayerPersona(player);
  const overall = getOverall(player);
  const market = valuePlayerContract(player, { overall });
  const proposedTerms = {
    years: offer.years ?? offer.expectedYears ?? market.years,
    AAV: offer.AAV ?? offer.salary ?? offer.expectedSalary ?? market.AAV,
    incentives: offer.incentives,
    noTradeClause: offer.noTradeClause ?? market.noTradeClause,
  };
  const tolerance = player.contract?.status==='holdout' ? 0.88 : 0.92;
  const negotiation = evaluateNegotiation(player, proposedTerms, {
    market,
    tolerance,
    yearTolerance: 0.8,
    overall,
    persona: player.persona,
    teamPosture,
    isExtension: !isFreeAgent,
    random: Math.random,
  });
  if(negotiation.breakOff){
    if(player.contract){
      player.contract.status = 'holdout';
      player.contract.daysRemaining = Math.max(7, (player.contract.daysRemaining||18) + 4);
    }
    logHighlight('user-x', `【交渉決裂】${player.name}との交渉が決裂しました。`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
    return { success:false, reason:'talks broke off', decision:'break-off', expectation: negotiation.counter, probabilities: negotiation.probabilities };
  }
  if(!negotiation.accepted){
    if(player.contract){
      player.contract.status = 'negotiating';
      player.contract.daysRemaining = Math.max(5, (player.contract.daysRemaining||20) - 2);
    }
    return { success:false, reason:'offer rejected', decision:'retry', expectation: negotiation.counter, probabilities: negotiation.probabilities };
  }
  let contract = ensurePlayerContract(player, tid, State.season);
  contract = normalizeContract({
    ...contract,
    AAV: negotiation.terms.AAV,
    salary: negotiation.terms.AAV,
    incentives: negotiation.terms.incentives,
    noTradeClause: negotiation.terms.noTradeClause,
    totalYears: negotiation.terms.years,
    years: negotiation.terms.years,
    yearsRemaining: negotiation.terms.years,
    startSeason: State.season,
    expirySeason: State.season + negotiation.terms.years - 1,
    status: 'active',
    type: isFreeAgent ? 'free-agent' : 'extension',
    daysRemaining: negotiation.terms.years === 1 ? 90 : null,
    expectedAnnual: negotiation.terms.expectedAnnual,
  }, player, tid, State.season);
  player.contract = { ...contract };
  if(isFreeAgent){
    State.freeAgents.splice(faIndex,1);
    addPlayerToRoster(tid, player);
  }
  upsertFinanceContract(tid, player, contract);
  const incentiveText = contract.incentives?.total ? ` (インセンティブ計${millionFormatter(contract.incentives.total)})` : '';
  logHighlight('wallet', `【契約合意】${player.name}と${contract.totalYears}年 AAV ${millionFormatter(contract.AAV)}${incentiveText}で合意しました。`, { category:'finance', financeType:'contract', tid, day: State.curr_day });
  if(typeof recomputeAllRatingsAll === 'function') recomputeAllRatingsAll();
  if(isFreeAgent){
    const compensation = processFreeAgentSigning(State, tid, player.id, {
      player,
      protectedList: (State.freeAgency?.protectedLists?.[tid]) || [],
      getOverall,
      removePlayerFromRoster,
      addPlayerToRoster,
      ensurePlayerContract,
      purgeFinanceContract,
      upsertFinanceContract,
      updateFinancialSnapshots,
      logHighlight,
      recomputeAllRatings: recomputeAllRatingsAll,
    });
    if(player.freeAgency){
      player.freeAgency.signedTid = tid;
      player.freeAgency.signedSeason = State.season ?? null;
      player.freeAgency.signedDay = State.curr_day ?? null;
      player.freeAgency.compensation = compensation;
    }
  }
  return { success:true, contract, terms: negotiation.terms, probabilities: negotiation.probabilities };
}

function proposeTrade(fromTid, toTid, outgoingIds=[], incomingIds=[], options={}){
  ensureTeamFinances();
  const outgoingPlayers = outgoingIds.map(pid=>findPlayerById(fromTid, pid));
  const incomingPlayers = incomingIds.map(pid=>findPlayerById(toTid, pid));
  if(outgoingPlayers.some(p=>!p) || incomingPlayers.some(p=>!p)){
    return { success:false, reason:'player not found' };
  }
  const outgoingValue = outgoingPlayers.reduce((sum,p)=>sum+getOverall(p),0);
  const incomingValue = incomingPlayers.reduce((sum,p)=>sum+getOverall(p),0);
  const cash = options.cash||0;
  const valueBuffer = (cash/50000000) + 3 + (outgoingPlayers.length + incomingPlayers.length)*0.5;
  if(!options.force && incomingValue > outgoingValue + valueBuffer){
    return { success:false, reason:'valuation mismatch' };
  }
  outgoingPlayers.forEach(player=>{
    removePlayerFromRoster(fromTid, player.id);
    purgeFinanceContract(fromTid, player.id);
  });
  incomingPlayers.forEach(player=>{
    removePlayerFromRoster(toTid, player.id);
    purgeFinanceContract(toTid, player.id);
  });
  outgoingPlayers.forEach(player=>{
    ensurePlayerContract(player, toTid, State.season);
    addPlayerToRoster(toTid, player);
    upsertFinanceContract(toTid, player, player.contract);
  });
  incomingPlayers.forEach(player=>{
    ensurePlayerContract(player, fromTid, State.season);
    addPlayerToRoster(fromTid, player);
    upsertFinanceContract(fromTid, player, player.contract);
  });
  if(cash){
    State.teamFinances[fromTid].budget.reserves = (State.teamFinances[fromTid].budget.reserves||0) - cash;
    State.teamFinances[toTid].budget.reserves = (State.teamFinances[toTid].budget.reserves||0) + cash;
  }
  updateFinancialSnapshots(fromTid);
  updateFinancialSnapshots(toTid);
  const summaryText = `【トレード成立】${id2name(fromTid)} ⇄ ${id2name(toTid)} (${outgoingPlayers.length}⇔${incomingPlayers.length})`;
  logHighlight('handshake', summaryText, { category:'finance', financeType:'trade', tid: fromTid, day: State.curr_day });
  if(typeof recomputeAllRatingsAll === 'function') recomputeAllRatingsAll();
  return { success:true, outgoing:outgoingPlayers, incoming:incomingPlayers };
}

function processContractCountdown(day){
  ensureTeamFinances();
  State.teams.forEach(team=>{
    const tid=team.team_id;
    const finance=State.teamFinances[tid];
    if(!finance) return;
    finance.contracts.slice().forEach(contract=>{
      if(contract.status==='active'){
        if(contract.yearsRemaining<=1){
          contract.daysRemaining = (contract.daysRemaining ?? 90) - 1;
          if(contract.daysRemaining===15){
            logHighlight('alarm-clock', `【契約期限迫る】${contract.name}との交渉期限が迫っています。`, { category:'finance', financeType:'contract', tid, day });
          }
          if(contract.daysRemaining<=0){
            releasePlayerToFreeAgency(tid, contract.playerId, '契約満了');
            contract.status='expired';
          }
        }
      } else if(contract.status==='negotiating'){
        contract.daysRemaining = (contract.daysRemaining ?? 10) - 1;
        if(contract.daysRemaining<=0){
          releasePlayerToFreeAgency(tid, contract.playerId, '交渉決裂');
          contract.status='expired';
        }
      }
    });
    finance.contracts = finance.contracts.filter(c=>c.status!=='expired');
    updateFinancialSnapshots(tid);
  });
}

// ====== Ratings, Schedule & Simulation ======
function battingScore(player, oppHand="R"){ const platoon=(oppHand==="R"&&player.hand==="L")?1.08:(oppHand==="L"&&player.hand==="R")?1.05:1.0; return (0.5*player.con+0.2*player.disc+0.25*player.pwr+0.05*player.spd)*platoon }
function recomputeTeamRatings(team, roster, ichiSet){
  const batsAll=roster.bats.slice(); const pitsAll=roster.pits.slice();
  const bats=(ichiSet?batsAll.filter(batter=>ichiSet.has(batter.id)):batsAll).sort((a,b)=>battingScore(b,"R")-battingScore(a,"R")).slice(0,9);
  const sp5=(ichiSet?pitsAll.filter(p=>p.role==="SP"&&ichiSet.has(p.id)):pitsAll.filter(p=>p.role==="SP")).sort((a,b)=>(b.stam*.2+b.velo*.4+b.mov*.3+b.ctrl*.1)-(a.stam*.2+a.velo*.4+a.mov*.3+a.ctrl*.1)).slice(0,5);
  const rp5=(ichiSet?pitsAll.filter(p=>p.role!=="SP"&&ichiSet.has(p.id)):pitsAll.filter(p=>p.role!=="SP")).sort((a,b)=>(b.velo*.45+b.mov*.35+b.ctrl*.2)-(a.velo*.45+a.mov*.35+a.ctrl*.2)).slice(0,5);
  const avg=(arr,f)=>arr.length?Math.round(arr.reduce((s,x)=>s+f(x),0)/arr.length):50;
  team.onbase=avg(bats,x=>(x.con*.7+x.disc*.3));
  team.power =avg(bats,x=>x.pwr);
  team.sp=avg(sp5,x=>(x.velo*.4+x.mov*.4+x.ctrl*.2));
  team.rp=avg(rp5,x=>(x.velo*.45+x.mov*.35+x.ctrl*.2));
  team.defense=avg(bats,x=>x.fld);
}
function roundRobin(teamIds,repeats=6,seed=42){
  const rng=mulberry32(seed>>>0); const teams=teamIds.slice(); if(teams.length%2===1)teams.push(null);
  const n=teams.length,half=n>>1,rounds=n-1; const base=[]; let arr=teams.slice();
  for(let r=0;r<rounds;r++){
    const pairs=[];
    for(let i=0;i<half;i++){
      const t1=arr[i],t2=arr[n-1-i];
      if(t1!==null&&t2!==null){ if(r%2===0)pairs.push([t1,t2]); else pairs.push([t2,t1]); }
    }
    base.push(pairs);
    arr=[arr[0],arr[n-1],...arr.slice(1,n-1)];
  }
  const sched=[]; let day=1; let seriesSeq=0;
  const pickSeriesLength=()=> (rng()<0.55?3:2);
  for(let k=0;k<repeats;k++){
    const order=[...base.keys()];
    for(let i=order.length-1;i>0;i--){const j=Math.floor(rng()*(i+1)); [order[i],order[j]]=[order[j],order[i]];}
    for(const idx of order){
      const pairs=base[idx]; if(!pairs.length) continue;
      const seriesLength=pickSeriesLength();
      seriesSeq++;
      for(let g=1; g<=seriesLength; g++){
        for(const [h,a] of pairs){ sched.push({day,type:'game',home_id:h,away_id:a,seriesGame:g,seriesLength,seriesKey:seriesSeq}); }
        day++;
      }
      const isLastSeries=(k===repeats-1) && (idx===order[order.length-1]);
      if(!isLastSeries){ sched.push({day,type:'rest'}); day++; }
    }
  }
  return sched;
}

function samplePoisson(lambda,rng){const L=Math.exp(-lambda); let k=0,p=1; do{k++;p*=rng()}while(p>L&&k<200); return k-1}
const offenseIndex=(onb,pow)=>clamp(0.6*(onb/50)+0.4*(pow/50),.4,2.0);
const pitMul=v=>clamp(50.0/v,.4,2.0); const defMul=v=>clamp(60.0/v,.7,2.0);
function expectedRunsSplit(att, opp, homeAdv=0.05, base=4.1){
  const attMods = (State.teamMods?.[att.team_id]) || {};
  const oppMods = (State.teamMods?.[opp.team_id]) || {};
  const wSP=0.65, wRP=0.35;
  const onb = clamp(att.onbase + (attMods.onb||0), 30, 99);
  const pow = clamp(att.power + (attMods.pow||0), 30, 99);
  const spO = clamp(opp.sp + (oppMods.sp||0), 30, 99);
  const rpO = clamp(opp.rp + (oppMods.rp||0), 30, 99);
  const defO= clamp(opp.defense + (oppMods.def||0), 30, 99);
  const off = offenseIndex(onb, pow);
  const muSP=base*off*pitMul(spO)*defMul(defO);
  const muRP=base*off*pitMul(rpO)*defMul(defO);
  let mu=wSP*muSP + wRP*muRP;
  mu*=(1+homeAdv);
  return clamp(mu, 0.5, 12.0);
}
function simulateGamePoissonLegacy(pair,rngSeed){
  const rng=mulberry32(rngSeed>>>0);
  const tH=State.teams.find(t=>t.team_id===pair.home_id), tA=State.teams.find(t=>t.team_id===pair.away_id);
  let rh=samplePoisson(expectedRunsSplit(tH,tA,State.home_adv,4.1),rng);
  let ra=samplePoisson(expectedRunsSplit(tA,tH,0.0,4.1),rng);
  let inn=9, extra=0;
  const mH = (State.teamMods?.[pair.home_id]) || {};
  const mA = (State.teamMods?.[pair.away_id]) || {};
  const exH = clamp(0.6 + (mH.extraAtk||0) - (mA.extraDef||0), 0.2, 1.2);
  const exA = clamp(0.6 + (mA.extraAtk||0) - (mH.extraDef||0), 0.2, 1.2);
  while(rh===ra && extra<12){ rh+=samplePoisson(exH, rng); ra+=samplePoisson(exA, rng); extra++; inn++; }
  if(rh===ra){ const bias = clamp(0.5 + ((mH.extraAtk||0) - (mA.extraAtk||0))*0.5, 0.2, 0.8); (rng()<bias) ? rh++ : ra++; inn++; }
  return {home_id:pair.home_id,away_id:pair.away_id,home_runs:rh,away_runs:ra,innings:inn,winner_id:(rh>ra)?pair.home_id:pair.away_id,day:State.curr_day};
}

function simulateGameSimple(pair,rngSeed){
  return simulateGamePoissonLegacy(pair,rngSeed);
}

function simulateGameDetailed(pair, rngSeed, options={}){
  const day = options.day ?? State.curr_day ?? 1;
  const rng = mulberry32(rngSeed>>>0);
  const clampProb = (value, min, max)=>Math.max(min, Math.min(max, value));
  const cloneScore = (score)=>({ home:score.home, away:score.away });

  const prepareTeam = (tid, side)=>{
    const override = options?.lineups?.[side];
    const lineup = override || pickDayLineup(tid, day);
    const roster = State.rosters[tid] || { bats:[], pits:[] };
    const bats = [...(lineup?.bats||[])].filter(p=>p && !p.injury);
    for(const player of roster.bats){
      if(bats.length>=9) break;
      if(player && !player.injury && !bats.some(b=>b.id===player.id)) bats.push(player);
    }
    if(bats.length===0){
      bats.push(...roster.bats.slice(0,9));
    }
    const battingOrder = bats.slice(0,9).map((p,idx)=>({
      id:p?.id??`bat_${idx}`,
      name:p?.name||`Batter ${idx+1}`,
      pos:p?.pos || p?.position || '-',
      con:p?.con||60,
      disc:p?.disc||60,
      pwr:p?.pwr||60,
      spd:p?.spd||60,
      order:idx+1,
      raw:p
    }));
    const pitcherPool=[];
    if(lineup?.sp && !lineup.sp.injury) pitcherPool.push(lineup.sp);
    (lineup?.rps||[]).forEach(rp=>{ if(rp && !rp.injury && !pitcherPool.some(p=>p.id===rp.id)) pitcherPool.push(rp); });
    if(!pitcherPool.length){
      const pool = roster.pits.filter(p=>p && !p.injury);
      if(pool.length) pitcherPool.push(pool[0]);
    }
    const pitchers = pitcherPool.map((p,idx)=>({
      id:p?.id??`pit_${idx}`,
      name:p?.name||`Pitcher ${idx+1}`,
      role: idx===0 ? 'SP' : (p?.role||'RP'),
      velo:p?.velo||60,
      ctrl:p?.ctrl||60,
      mov:p?.mov||60,
      stam:p?.stam||60,
      outsLimit: idx===0 ? Math.round(15 + (p?.stam||60)/2) : Math.round(3 + Math.max(0,(p?.stam||55)-45)/6),
      raw:p,
      outsRecorded:0,
      runsAllowed:0,
      hitsAllowed:0,
      walksAllowed:0,
      strikeouts:0,
      homeRunsAllowed:0,
      entered:false
    }));
    if(!pitchers.length){
      pitchers.push({ id:`pit_auto_${tid}`, name:'緊急投手', role:'RP', velo:60, ctrl:60, mov:60, stam:60, outsLimit:9, raw:null, outsRecorded:0, runsAllowed:0, hitsAllowed:0, walksAllowed:0, strikeouts:0, homeRunsAllowed:0, entered:false });
    }
    return {
      side,
      team_id:tid,
      battingOrder,
      pitchers,
      battingStats:new Map(),
      pitchingStats:new Map(),
      orderIndex:0,
      currentPitcherIndex:0
    };
  };

  const home = prepareTeam(pair.home_id, 'home');
  const away = prepareTeam(pair.away_id, 'away');
  const scoreboard = { home:0, away:0 };
  const events=[];
  const innings=[];
  const keyMoments=[];
  const pitcherTimeline={ home:[], away:[] };
  const PROBABILITY_LIMITS={
    walkProb:[0.01,0.28],
    strikeProb:[0.04,0.45],
    hrProb:[0.005,0.24],
    hitProb:[0.10,0.65]
  };
  const adjustProbabilityWithSpecials=(base,key,adjustments)=>{
    const mod=adjustments?.[key];
    let value=base;
    if(mod){
      if(typeof mod.mult==='number') value*=mod.mult;
      if(typeof mod.add==='number') value+=mod.add;
    }
    const [min,max]=PROBABILITY_LIMITS[key]||[0,1];
    return clampProb(value,min,max);
  };
  const specialEngine=createPlateAppearanceSpecialEngine();

  const ensureBatterStats=(team,batter)=>{
    if(!batter) return null;
    if(!team.battingStats.has(batter.id)){
      team.battingStats.set(batter.id,{
        id:batter.id,
        name:batter.name,
        order:batter.order,
        pos:batter.pos,
        AB:0,H:0,HR:0,RBI:0,BB:0,SO:0,R:0,PA:0
      });
    }
    return team.battingStats.get(batter.id);
  };

  const ensurePitchingStats=(team,pitcher)=>{
    if(!pitcher) return null;
    if(!team.pitchingStats.has(pitcher.id)){
      team.pitchingStats.set(pitcher.id,{
        id:pitcher.id,
        name:pitcher.name,
        role:pitcher.role,
        outs:0,
        ER:0,
        R:0,
        H:0,
        BB:0,
        SO:0,
        HR:0
      });
    }
    return team.pitchingStats.get(pitcher.id);
  };

  const createRunner=(team,batter)=>({
    id:batter.id,
    name:batter.name,
    pos:batter.pos,
    order:batter.order,
    spd:batter.spd||60,
    side:team.side,
    stats:ensureBatterStats(team,batter)
  });

  const markPitcherEntry=(team,pitcher,inning,half)=>{
    if(!pitcher.entered){
      pitcher.entered=true;
      pitcherTimeline[team.side].push({
        id:pitcher.id,
        name:pitcher.name,
        role:pitcher.role,
        entered:{inning,half},
        exit:null,
        outs:0,
        runs:0
      });
    }
  };

  const markPitcherExit=(team,pitcher,inning,half)=>{
    const entry=pitcherTimeline[team.side].find(e=>e.id===pitcher.id && !e.exit);
    if(entry){
      entry.exit={inning,half};
      entry.outs=pitcher.outsRecorded;
      entry.runs=pitcher.runsAllowed;
    }
  };

  const updateTimeline=(team,pitcher)=>{
    const entry=pitcherTimeline[team.side].find(e=>e.id===pitcher.id && !e.exit);
    if(entry){
      entry.outs=pitcher.outsRecorded;
      entry.runs=pitcher.runsAllowed;
    }
  };

  const maybeSwitchPitcher=(defTeam, inning, half)=>{
    const pitcher=defTeam.pitchers[defTeam.currentPitcherIndex];
    if(!pitcher) return;
    const outsLimit=pitcher.outsLimit || 18;
    const runLimit=pitcher.role==='SP'?5:3;
    if((pitcher.outsRecorded>=outsLimit || pitcher.runsAllowed>=runLimit) && defTeam.currentPitcherIndex < defTeam.pitchers.length-1){
      markPitcherExit(defTeam,pitcher,inning,half);
      defTeam.currentPitcherIndex++;
      const next=defTeam.pitchers[defTeam.currentPitcherIndex];
      if(next) next.entered=false;
    }
  };

  const advanceWalk=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1) next[2]=b1;
    if(b0) next[1]=b0;
    next[0]=runner;
    return { bases:next, scored };
  };

  const advanceSingle=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1){
      if(rng()<0.65 + clampProb((b1.spd||60)-50, -40, 60)/220){ scored.push(b1); }
      else next[2]=b1;
    }
    if(b0){
      const goThird=rng()<0.5 + clampProb((b0.spd||60)-55, -40, 60)/230;
      if(goThird && !next[2]) next[2]=b0; else next[1]=b0;
    }
    next[0]=runner;
    return { bases:next, scored };
  };

  const advanceDouble=(bases,runner)=>{
    const [b0,b1,b2]=bases;
    const next=[null,null,null];
    const scored=[];
    if(b2) scored.push(b2);
    if(b1) scored.push(b1);
    if(b0){
      if(rng()<0.55 + clampProb((b0.spd||60)-55, -40, 60)/220){ scored.push(b0); }
      else next[2]=b0;
    }
    next[1]=runner;
    return { bases:next, scored };
  };

  const advanceTriple=(bases,runner)=>{
    const scored=[];
    bases.forEach(r=>{ if(r) scored.push(r); });
    return { bases:[null,null,runner], scored };
  };

  const advanceHomer=(bases,runner)=>{
    const scored=[...bases.filter(Boolean), runner];
    return { bases:[null,null,null], scored };
  };

  const applyScores=(scored,pitcher,pitchStats)=>{
    let runs=0;
    for(const runner of scored){
      if(runner.side==='home') scoreboard.home++; else scoreboard.away++;
      if(runner.stats) runner.stats.R = (runner.stats.R||0)+1;
      runs++;
    }
    if(runs>0){
      pitchStats.ER += runs;
      pitchStats.R += runs;
      pitcher.runsAllowed += runs;
    }
    return runs;
  };

  const registerKeyMoment=(desc, inning, half, side, scoreBefore, scoreAfter, playerId=null)=>{
    keyMoments.push({ description:desc, inning, half, side, before:scoreBefore, score:scoreAfter, playerId });
  };

  const plateAppearance=(battingTeam, defTeam, inning, half, halfState)=>{
    const batter=battingTeam.battingOrder[battingTeam.orderIndex % battingTeam.battingOrder.length];
    battingTeam.orderIndex++;
    const batterStats=ensureBatterStats(battingTeam,batter);
    const pitcher=defTeam.pitchers[defTeam.currentPitcherIndex];
    if(!pitcher) return;
    markPitcherEntry(defTeam,pitcher,inning,half);
    const pitchStats=ensurePitchingStats(defTeam,pitcher);
    const basesBefore=halfState.bases.map(r=>r?{id:r.id,name:r.name}:null);
    const outsBefore=halfState.outs;
    const scoreBefore=cloneScore(scoreboard);

    batterStats.PA++;

    let walkProb=clampProb(0.07 + (batter.disc - pitcher.ctrl)/280, 0.02, 0.22);
    let strikeProb=clampProb(0.18 + (pitcher.velo - batter.con)/320, 0.06, 0.35);
    let hrProb=clampProb(0.04 + (batter.pwr - pitcher.mov)/260, 0.01, 0.18);
    let hitProb=clampProb(0.27 + (batter.con - pitcher.mov)/260, 0.12, 0.55);

    const batterPlayer=batter?.raw||batter;
    const pitcherPlayer=pitcher?.raw||pitcher;
    let specialTriggers=[];
    let specialSummary=null;
    let specialCommentary=null;
    const specialResult=specialEngine.evaluate({
      batter:batterPlayer,
      pitcher:pitcherPlayer,
      context:{
        inning,
        half,
        outs:halfState.outs,
        bases:halfState.bases,
        scoreBefore,
        battingTeam,
        defTeam
      },
      batterStats,
      pitcherStats:pitchStats
    });
    if(specialResult){
      walkProb=adjustProbabilityWithSpecials(walkProb,'walkProb',specialResult.adjustments);
      strikeProb=adjustProbabilityWithSpecials(strikeProb,'strikeProb',specialResult.adjustments);
      hrProb=adjustProbabilityWithSpecials(hrProb,'hrProb',specialResult.adjustments);
      hitProb=adjustProbabilityWithSpecials(hitProb,'hitProb',specialResult.adjustments);
      specialTriggers=Array.isArray(specialResult.triggered)?specialResult.triggered.slice():[];
      const summaryParts=specialTriggers.map(entry=>entry.summary||entry.name).filter(Boolean);
      if(summaryParts.length) specialSummary=summaryParts.join(' / ');
      const commentaryParts=Array.isArray(specialResult.commentary)?specialResult.commentary.filter(Boolean):[];
      if(commentaryParts.length){
        specialCommentary=commentaryParts.join(' / ');
      } else if(specialTriggers.length){
        specialCommentary=`特能発動: ${specialTriggers.map(entry=>entry.name).join('・')}`;
      }
    }

    let total=walkProb+strikeProb+hrProb+hitProb;
    if(total>0.96){
      const scale=0.96/total;
      walkProb*=scale; strikeProb*=scale; hrProb*=scale; hitProb*=scale;
    }

    const r=rng();
    let result='out';
    let description='';
    let newBases=halfState.bases.slice();
    let scored=[];
    let outsAdded=0;
    let rbi=0;
    let countAB=true;
    let eventRBI=0;

    if(r < walkProb){
      result='walk';
      description=`${batter.name} 四球で出塁`;
      const move=advanceWalk(halfState.bases, createRunner(battingTeam,batter));
      newBases=move.bases;
      scored=move.scored;
      rbi=scored.length;
      eventRBI=rbi;
      countAB=false;
      batterStats.BB++;
      pitchStats.BB++;
      pitcher.walksAllowed++;
    } else if(r < walkProb + strikeProb){
      result='strikeout';
      description=`${batter.name} 空振り三振`;
      outsAdded=1;
      batterStats.SO++;
      pitchStats.SO++;
      pitcher.strikeouts++;
    } else if(r < walkProb + strikeProb + hrProb){
      result='home_run';
      const move=advanceHomer(halfState.bases, createRunner(battingTeam,batter));
      newBases=move.bases;
      scored=move.scored;
      const runLabel=scored.length===4?'満塁':scored.length===3?'3ラン':scored.length===2?'2ラン':'ソロ';
      description=`${batter.name} の${runLabel}ホームラン！`;
      batterStats.H++;
      batterStats.HR++;
      pitchStats.H++;
      pitchStats.HR++;
      pitcher.hitsAllowed++;
      pitcher.homeRunsAllowed++;
    } else if(r < walkProb + strikeProb + hrProb + hitProb){
      const hitRoll=rng();
      const tripleCut=clampProb(0.08 + (batter.spd-60)/320, 0.01, 0.12);
      const doubleCut=tripleCut + clampProb(0.24 + (batter.pwr-60)/260, 0.12, 0.35);
      if(hitRoll < tripleCut){
        result='triple';
        const move=advanceTriple(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} 三塁打！`;
      } else if(hitRoll < doubleCut){
        result='double';
        const move=advanceDouble(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} ツーベース！`;
      } else {
        result='single';
        const move=advanceSingle(halfState.bases, createRunner(battingTeam,batter));
        newBases=move.bases;
        scored=move.scored;
        description=`${batter.name} タイムリー！`;
      }
      batterStats.H++;
      pitchStats.H++;
      pitcher.hitsAllowed++;
    } else {
      const ground=rng()<0.55;
      if(ground){
        const hasRunnerFirst=halfState.bases[0]!=null;
        const canDoublePlay=hasRunnerFirst && halfState.outs<=1;
        const doublePlay=canDoublePlay && rng()<0.22 + (pitcher.mov-60)/250;
        if(doublePlay){
          result='double_play';
          description=`${batter.name} 併殺打`;
          newBases=[null, halfState.bases[1], halfState.bases[2]];
          outsAdded=2;
        } else {
          result='groundout';
          description=`${batter.name} ゴロアウト`;
          newBases=halfState.bases.slice();
          outsAdded=1;
          if(newBases[2] && halfState.outs<2 && rng()<0.55){
            scored=[newBases[2]];
            newBases[2]=null;
            result='groundout_rbi';
            description=`${batter.name} 内野ゴロの間に1点`;
            rbi=scored.length;
          }
        }
      } else {
        result='flyout';
        description=`${batter.name} フライアウト`;
        newBases=halfState.bases.slice();
        outsAdded=1;
        if(newBases[2] && halfState.outs<2 && rng()<0.58 + (batter.con-60)/320){
          scored=[newBases[2]];
          newBases[2]=null;
          result='sac_fly';
          description=`${batter.name} 犠牲フライ！`;
          rbi=scored.length;
          countAB=false;
        }
      }
    }

    if(countAB) batterStats.AB++;
    const runs=applyScores(scored, pitcher, pitchStats);
    if(['home_run','double','triple','single','walk'].includes(result)){
      batterStats.RBI += runs;
      eventRBI = runs;
    }
    if(result==='groundout_rbi' || result==='sac_fly'){
      const credited = rbi || runs;
      batterStats.RBI += credited;
      eventRBI = credited;
    }

    pitchStats.outs += outsAdded;
    pitcher.outsRecorded += outsAdded;
    halfState.bases=newBases;
    halfState.outs+=outsAdded;
    updateTimeline(defTeam,pitcher);

    const scoreAfter=cloneScore(scoreboard);
    events.push({
      inning,
      half,
      batter:{ id:batter.id, name:batter.name },
      pitcher:{ id:pitcher.id, name:pitcher.name },
      result,
      description,
      specials:specialTriggers,
      specialSummary,
      commentary:specialCommentary,
      basesBefore,
      basesAfter:newBases.map(r=>r?{id:r.id,name:r.name}:null),
      outsBefore,
      outsAfter:halfState.outs,
      runsScored:runs,
      rbi:eventRBI,
      scoreBefore,
      scoreAfter
    });

    if(runs>0){
      const battingSide=battingTeam.side;
      const otherSide=battingSide==='home'?'away':'home';
      const goAhead = scoreBefore[battingSide] <= scoreBefore[otherSide] && scoreAfter[battingSide] > scoreAfter[otherSide];
      const isWalkoff = half==='bottom' && inning>=9 && scoreAfter.home>scoreAfter.away;
      const bigMoment = runs>=3 || result==='home_run';
      if(goAhead || bigMoment || isWalkoff){
        registerKeyMoment(isWalkoff?`${description}（サヨナラ）`:description, inning, half, battingSide, scoreBefore, scoreAfter, batter.id);
      }
      if(isWalkoff) halfState.walkoff=true;
    }

    if(halfState.outs<3 && !halfState.walkoff){
      maybeSwitchPitcher(defTeam, inning, half);
    }
  };

  const playHalf=(battingTeam, defTeam, inning, half)=>{
    const halfState={ outs:0, bases:[null,null,null], walkoff:false };
    const before=cloneScore(scoreboard);
    const indices=[];
    while(halfState.outs<3 && !halfState.walkoff){
      maybeSwitchPitcher(defTeam, inning, half);
      const idx=events.length;
      plateAppearance(battingTeam, defTeam, inning, half, halfState);
      if(events.length>idx) indices.push(idx); else break;
    }
    const after=cloneScore(scoreboard);
    const runs=battingTeam.side==='home'? (after.home-before.home):(after.away-before.away);
    return { runs, events:indices, scoreAfter:after, walkoff:halfState.walkoff };
  };

  let inning=1;
  const maxInnings=12;
  let finished=false;
  while(!finished && inning<=maxInnings){
    const top=playHalf(away, home, inning, 'top');
    const log={ inning, top:{ runs:top.runs, events:top.events, scoreAfter:top.scoreAfter } };
    if(top.walkoff){ innings.push(log); finished=true; break; }
    const bottom=playHalf(home, away, inning, 'bottom');
    log.bottom={ runs:bottom.runs, events:bottom.events, scoreAfter:bottom.scoreAfter, walkoff:bottom.walkoff };
    innings.push(log);
    if(bottom.walkoff){ finished=true; break; }
    if(inning>=9 && scoreboard.home!==scoreboard.away){ finished=true; break; }
    inning++;
  }

  if(scoreboard.home===scoreboard.away){
    const beforeTie=cloneScore(scoreboard);
    scoreboard.home+=1;
    const afterTie=cloneScore(scoreboard);
    registerKeyMoment('延長タイブレークでホームがサヨナラ勝ち', inning, 'bottom', 'home', beforeTie, afterTie, null);
    if(innings.length){
      const last=innings[innings.length-1];
      if(last.bottom){
        const prevScore=last.bottom.scoreAfter || beforeTie;
        const delta=afterTie.home - (prevScore.home??beforeTie.home);
        last.bottom.runs = (last.bottom.runs||0) + delta;
        last.bottom.scoreAfter = afterTie;
        last.bottom.walkoff = true;
      } else {
        last.bottom={ runs:afterTie.home-beforeTie.home, events:[], scoreAfter:afterTie, walkoff:true };
      }
    } else {
      innings.push({ inning, top:{ runs:0, events:[], scoreAfter:beforeTie }, bottom:{ runs:afterTie.home-beforeTie.home, events:[], scoreAfter:afterTie, walkoff:true } });
    }
  }

  const finalInningNumber = innings.length ? innings[innings.length-1].inning : inning;

  const finalizePitchers=(team)=>{
    team.pitchers.forEach(p=>{
      if(p.entered){
        markPitcherExit(team,p,finalInningNumber,'end');
      }
      ensurePitchingStats(team,p);
    });
  };
  finalizePitchers(home);
  finalizePitchers(away);

  const mapTeamStats=(team)=>({
    batting:[...team.battingStats.values()].sort((a,b)=>a.order-b.order),
    pitching:team.pitchers.map(p=>{
      const stat=team.pitchingStats.get(p.id) || { outs:0, ER:0, R:0, H:0, BB:0, SO:0, HR:0 };
      return {
        id:p.id,
        name:p.name,
        role:p.role,
        outs:stat.outs || p.outsRecorded,
        IP:(stat.outs||p.outsRecorded)/3,
        ER:stat.ER,
        R:stat.R,
        H:stat.H,
        BB:stat.BB,
        SO:stat.SO,
        HR:stat.HR
      };
    })
  });

  const detail={
    events,
    innings,
    keyMoments,
    pitcherTimeline,
    stats:{
      home:mapTeamStats(home),
      away:mapTeamStats(away)
    },
    lineups:{
      home:{
        batting:home.battingOrder.map(b=>({ id:b.id, name:b.name, pos:b.pos, order:b.order })),
        pitchers:home.pitchers.map(p=>({ id:p.id, name:p.name, role:p.role }))
      },
      away:{
        batting:away.battingOrder.map(b=>({ id:b.id, name:b.name, pos:b.pos, order:b.order })),
        pitchers:away.pitchers.map(p=>({ id:p.id, name:p.name, role:p.role }))
      }
    }
  };

  const totalInnings = innings.length? innings[innings.length-1].inning : 9;
  return {
    home_id:pair.home_id,
    away_id:pair.away_id,
    home_runs:scoreboard.home,
    away_runs:scoreboard.away,
    innings:Math.max(totalInnings,9),
    winner_id:scoreboard.home>=scoreboard.away?pair.home_id:pair.away_id,
    day:day,
    detailed:detail
  };
}

function computeStandings(teams,results){
  const rec=new Map(); for(const t of teams) rec.set(t.team_id,{team:t.team,league:t.league,W:0,L:0});
  for(const r of results){ if(r.home_runs>r.away_runs){rec.get(r.home_id).W++;rec.get(r.away_id).L++;} else {rec.get(r.away_id).W++;rec.get(r.home_id).L++;} }
  const rows=[...rec.entries()].map(([tid,v])=>{const g=v.W+v.L; const pct=g>0?v.W/g:0; return {team_id:tid,team:v.team,league:v.league,W:v.W,L:v.L,Pct:Math.round(pct*1000)/1000}}).sort((a,b)=>b.Pct-a.Pct||b.W-a.W);
  if(rows.length>0){const leadW=rows[0].W,leadL=rows[0].L; for(const r of rows) r.GB=((leadW-r.W)+(r.L-leadL))/2; }
  return rows;
}

// ====== Playoffs Helpers ======
function defaultPlayoffState(){
  return { active:false, started:false, completed:false, stageIndex:0, stages:[], champion:null, runnerUp:null, seeds:{} };
}
function normalizePlayoffState(playoffs){
  if(!playoffs) return defaultPlayoffState();
  const base=defaultPlayoffState();
  base.active=!!playoffs.active;
  base.started=!!playoffs.started;
  base.completed=!!playoffs.completed;
  base.stageIndex=playoffs.stageIndex||0;
  base.champion=playoffs.champion??null;
  base.runnerUp=playoffs.runnerUp??null;
  base.seeds=playoffs.seeds||{};
  base.startedDay=playoffs.startedDay||null;
  base.stages=(playoffs.stages||[]).map(stage=>({
    name:stage.name,
    league:stage.league||null,
    series:(stage.series||[]).map(series=>({
      id:series.id,
      name:series.name,
      league:series.league||null,
      bestOf:series.bestOf||7,
      winsNeeded:series.winsNeeded||Math.floor(((series.bestOf||7))/2)+1,
      teams:(series.teams||[]).map(team=>({
        type:team.type|| (team.from? 'winner':'team'),
        from:team.from||null,
        seed:team.seed??null,
        team_id:team.team_id??null,
        name:team.name||null
      })),
      wins:{...(series.wins||{})},
      games:(series.games||[]).map(g=>({
        game:g.game,
        home_id:g.home_id,
        away_id:g.away_id,
        home_runs:g.home_runs,
        away_runs:g.away_runs,
        winner_id:g.winner_id,
        day:g.day
      })),
      completed:!!series.completed,
      winner:series.winner??null
    }))
  }));
  return base;
}
function ensurePlayoffState(){ if(!State.playoffs) State.playoffs=defaultPlayoffState(); return State.playoffs; }
function startPlayoffs(){
  ensurePlayoffState();
  const standings=computeStandings(State.teams, State.results||[]);
  if(!standings.length) return State.playoffs;
  const byLeague=new Map();
  standings.forEach(row=>{
    if(!byLeague.has(row.league)) byLeague.set(row.league, []);
    byLeague.get(row.league).push(row);
  });
  const playoffs=defaultPlayoffState();
  playoffs.active=true; playoffs.started=true; playoffs.stageIndex=0;
  updateSeasonStage('CS', State.curr_day||maxDay()+1);
  const stageFirst={ name:'クライマックスシリーズ・ファースト', series:[] };
  const stageFinal={ name:'クライマックスシリーズ・ファイナル', series:[] };
  const stageJapan={ name:'日本シリーズ', series:[] };
  let centralFinalId=null, pacificFinalId=null;
  playoffs.seeds={};
  for(const [league, rows] of byLeague.entries()){
    const seeds=rows.slice(0,3);
    playoffs.seeds[league]=seeds.map((row,idx)=>({team_id:row.team_id, team:row.team, seed:idx+1}));
    if(seeds.length<2) continue;
    if(seeds.length>=3){
      const firstId=`${league.toLowerCase()}-first`;
      stageFirst.series.push({
        id:firstId,
        name:`${league==='Central'?'セ・リーグ':'パ・リーグ'} ファーストステージ`,
        league,
        bestOf:5,
        winsNeeded:3,
        teams:[
          {type:'team', team_id:seeds[1].team_id, seed:2, name:seeds[1].team},
          {type:'team', team_id:seeds[2].team_id, seed:3, name:seeds[2].team}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      const finalId=`${league.toLowerCase()}-final`;
      stageFinal.series.push({
        id:finalId,
        name:`${league==='Central'?'セ・リーグ':'パ・リーグ'} ファイナルステージ`,
        league,
        bestOf:7,
        winsNeeded:4,
        teams:[
          {type:'team', team_id:seeds[0].team_id, seed:1, name:seeds[0].team},
          {type:'winner', from:firstId, seed:2, name:'ファースト勝者'}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      if(league==='Central') centralFinalId=finalId; else if(league==='Pacific') pacificFinalId=finalId;
    } else {
      const finalId=`${league.toLowerCase()}-final`;
      stageFinal.series.push({
        id:finalId,
        name:`${league==='Central'?'セ・リーグ':'パ・リーグ'} 決定シリーズ`,
        league,
        bestOf:7,
        winsNeeded:4,
        teams:[
          {type:'team', team_id:seeds[0].team_id, seed:1, name:seeds[0].team},
          {type:'team', team_id:seeds[1].team_id, seed:2, name:seeds[1].team}
        ],
        wins:{},
        games:[],
        completed:false,
        winner:null
      });
      if(league==='Central') centralFinalId=finalId; else if(league==='Pacific') pacificFinalId=finalId;
    }
  }
  if(stageFirst.series.length>0) playoffs.stages.push(stageFirst);
  if(stageFinal.series.length>0) playoffs.stages.push(stageFinal);
  if(centralFinalId && pacificFinalId){
    stageJapan.series.push({
      id:'japan-series',
      name:'日本シリーズ',
      league:'Championship',
      bestOf:7,
      winsNeeded:4,
      teams:[
        {type:'winner', from:centralFinalId, seed:1, name:'セ代表'},
        {type:'winner', from:pacificFinalId, seed:1, name:'パ代表'}
      ],
      wins:{},
      games:[],
      completed:false,
      winner:null
    });
  }
  if(stageJapan.series.length>0) playoffs.stages.push(stageJapan);
  playoffs.startedDay=State.curr_day;
  if(!playoffs.stages.length){
    playoffs.active=false;
    playoffs.started=false;
    State.playoffs=playoffs;
    return playoffs;
  }
  State.playoffs=playoffs;
  logHighlight('trophy', `【ポストシーズン開幕】${State.season}年目のクライマックスシリーズが開幕しました！`);
  return playoffs;
}
function findPlayoffSeries(seriesId){
  if(!State.playoffs) return null;
  for(const stage of State.playoffs.stages){
    for(const series of stage.series){
      if(series.id===seriesId) return {stage, series};
    }
  }
  return null;
}
function resolvePlayoffTeam(entry){
  if(!entry) return null;
  if(entry.team_id!=null) return {team_id:entry.team_id, name:entry.name||id2name(entry.team_id), seed:entry.seed??null, from:entry.from||null};
  if(entry.type==='winner' && entry.from){
    const found=findPlayoffSeries(entry.from);
    if(found && found.series.completed && found.series.winner!=null){
      entry.team_id=found.series.winner;
      entry.name=id2name(entry.team_id);
      return {team_id:entry.team_id, name:entry.name, seed:entry.seed??null, from:entry.from};
    }
  }
  return null;
}
function playoffSeriesReady(series){
  if(!series) return false;
  const teams=series.teams.map(resolvePlayoffTeam);
  return teams.every(t=>t && t.team_id!=null);
}
function applyMoraleBonus(tid, bonus){
  const roster=State.rosters[tid];
  if(!roster) return;
  [...roster.bats, ...roster.pits].forEach(p=>{ p.morale=clamp((p.morale||60)+bonus,0,100); });
}
function finishPlayoffs(championId, runnerUpId){
  ensurePlayoffState();
  State.playoffs.active=false;
  State.playoffs.completed=true;
  State.playoffs.stageIndex = Math.max(0, (State.playoffs.stages.length||1) - 1);
  State.playoffs.champion=championId;
  State.playoffs.runnerUp=runnerUpId??null;
  State.playoffs.finishedDay=State.curr_day;
  logHighlight('crown', `【日本一】${id2name(championId)}が頂点に立ちました！`);
  dpGain(championId, 5);
  applyMoraleBonus(championId, 8);
  if(runnerUpId!=null){
    dpGain(runnerUpId, 2);
    applyMoraleBonus(runnerUpId, 4);
  }
  updateSeasonStage('POST', State.curr_day||maxDay());
}
function propagatePlayoffWinners(stage){
  if(!stage) return;
  for(const series of stage.series){
    if(!series.completed || series.winner==null) continue;
    for(const nextStage of State.playoffs.stages){
      for(const nextSeries of nextStage.series){
        nextSeries.teams.forEach(entry=>{
          if(entry.type==='winner' && entry.from===series.id && entry.team_id==null){
            entry.team_id=series.winner;
            entry.name=id2name(series.winner);
          }
        });
      }
    }
  }
}
function checkPlayoffStageCompletion(){
  if(!State.playoffs || !State.playoffs.active) return;
  let progressed=false;
  while(State.playoffs.stageIndex < State.playoffs.stages.length){
    const stage=State.playoffs.stages[State.playoffs.stageIndex];
    if(stage.series.some(s=>!s.completed)) break;
    propagatePlayoffWinners(stage);
    if(State.playoffs.stageIndex < State.playoffs.stages.length-1){
      State.playoffs.stageIndex++;
      progressed=true;
      logHighlight('flag', `【ステージ突破】${stage.name}が全日程終了しました。`);
      continue;
    }
    break;
  }
  const activeStage=State.playoffs.stages[State.playoffs.stageIndex];
  if(activeStage){
    const label = activeStage.name.includes('日本シリーズ') ? 'JS' : 'CS';
    updateSeasonStage(label, State.curr_day||maxDay());
  }
  return progressed;
}
function recordPlayoffGame(series, res){
  const gameNo=series.games.length+1;
  series.games.push({
    game:gameNo,
    home_id:res.home_id,
    away_id:res.away_id,
    home_runs:res.home_runs,
    away_runs:res.away_runs,
    winner_id:res.winner_id,
    day:res.day
  });
  series.wins[res.winner_id]=(series.wins[res.winner_id]||0)+1;
}
function playPlayoffGame(seriesId){
  const found=findPlayoffSeries(seriesId);
  if(!found) return false;
  const {stage, series}=found;
  if(series.completed) return false;
  const teams=series.teams.map(resolvePlayoffTeam);
  if(teams.some(t=>!t)) return false;
  const day=State.curr_day|| (maxDay()+1);
  tickDay();
  ensureSquads();
  recomputeAllRatingsAll();
  const homeFirst=teams[0];
  const awaySecond=teams[1];
  const gameIndex=series.games.length;
  const homeTeam = (gameIndex % 2 === 0) ? homeFirst : awaySecond;
  const awayTeam = (gameIndex % 2 === 0) ? awaySecond : homeFirst;
  const seedBase=State.seed||2025;
  const seed=seedBase + day*131 + gameIndex*17 + series.id.length*11;
  const res=simulateGameDetailed({home_id:homeTeam.team_id, away_id:awayTeam.team_id}, seed);
  res.day=day;
  recordPlayoffGame(series, res);
  allocateGameStats(res);
  dpGain(res.winner_id, 0.5);
  const loserId = (res.winner_id===homeTeam.team_id)?awayTeam.team_id:homeTeam.team_id;
  dpGain(loserId, 0.2);
  const scoreText=`${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
  logHighlight('medal', `【PO G${series.games.length}】${series.name}: ${scoreText}`);
  State.curr_day=day+1;
  if(series.wins[res.winner_id]>=series.winsNeeded){
    series.completed=true;
    series.winner=res.winner_id;
    const loserWins=series.wins[loserId]||0;
    logHighlight('flag', `【シリーズ決着】${id2name(res.winner_id)}が${series.name}を${series.wins[res.winner_id]}-${loserWins}で制しました。`);
    if(series.id==='japan-series'){
      finishPlayoffs(series.winner, loserId);
    } else {
      const stageIdx = State.playoffs.stages.indexOf(stage);
      const isLastStage = stageIdx === State.playoffs.stages.length - 1;
      if(isLastStage && stage.series.every(s=>s.completed) && !State.playoffs.completed){
        finishPlayoffs(series.winner, loserId);
      }
    }
  }
  checkPlayoffStageCompletion();
  return true;
}
function playNextPlayoffGame(){
  if(!State.playoffs || !State.playoffs.active) return false;
  checkPlayoffStageCompletion();
  const stage=State.playoffs.stages[State.playoffs.stageIndex];
  if(!stage) return false;
  const target=stage.series.find(s=>!s.completed && playoffSeriesReady(s));
  if(!target) return false;
  return playPlayoffGame(target.id);
}


// ====== NEW: Team Meta (Dev Points, Facilities, Coaches) ======
function defaultScoutingSetup(tid){
  const seed=((State.seed||2025) + tid*131)>>>0;
  const rng=mulberry32(seed);
  const staffLevel=()=>Math.floor(rng()*3);
  return {
    points: 8 + Math.round(rng()*4),
    maxPoints: 24,
    staff:{ lead: 1 + staffLevel(), bat: staffLevel(), pit: staffLevel() },
    assignments:{}
  };
}
function ensureTeamMeta(){
  ensureTeamFinances();
  if(!State.teamMeta) State.teamMeta={};
  for(const team of State.teams){
    const tid = team.team_id;
    let meta = State.teamMeta[tid];
    if(!meta){
      meta = {
        dp: 0,
        scouting: defaultScoutingSetup(tid),
        popularity: team.popularity ?? (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60)
      };
      State.teamMeta[tid] = meta;
    }
    if(meta.dp == null) meta.dp = 0;
    const facilities = ensureTeamFacilities(meta, tid);
    ensureTeamStaff(meta);
    if(!meta.scouting){
      meta.scouting = defaultScoutingSetup(tid);
    } else {
      meta.scouting.points = typeof meta.scouting.points==='number' ? meta.scouting.points : defaultScoutingSetup(tid).points;
      meta.scouting.maxPoints = meta.scouting.maxPoints || 24;
      meta.scouting.staff = meta.scouting.staff || defaultScoutingSetup(tid).staff;
      meta.scouting.assignments = meta.scouting.assignments || {};
    }
    if(facilities && facilities.recovery == null){
      facilities.recovery = facilities.medical ?? 0;
    }
    if(meta.popularity == null){
      meta.popularity = team.popularity ?? (SeasonSimulator?.DEFAULT_TEAM_POPULARITY || 60);
    }
  }
  ensureTeamNeedsAll();
}
function updateTeamNeeds(tid){ if(!State?.teams) return null; const team=State.teams.find(t=>t.team_id===tid); if(!team) return null; return calculateDraftTeamNeeds(State, tid); }
function ensureTeamNeedsAll(){ if(!State?.teams) return; State.teams.forEach(team=>{ const needs=calculateDraftTeamNeeds(State, team.team_id); team.needs={ ...needs }; }); }
function dpGain(tid, amount){ ensureTeamMeta(); const m=State.teamMeta[tid]; m.dp=(m.dp||0)+amount; }
function dpSpend(tid, cost){ ensureTeamMeta(); const m=State.teamMeta[tid]; if((m.dp||0)>=cost){ m.dp-=cost; return true;} return false; }

function getTeamSupportAdjustments(tid){
  ensureTeamMeta();
  const meta = State.teamMeta[tid] || { facilities: {}, coaches: {} };
  return {
    staff: computeStaffAdjustments(meta.coaches || {}),
    facilities: computeFacilityAdjustments(meta.facilities || {})
  };
}

const SCOUT_ASSIGN_COST = 4;
function findDraftProspect(pid){
  const draft = State.draft && Array.isArray(State.draft.pool) ? State.draft : ensureDraftStateRecord(State);
  if(!Array.isArray(draft.pool)) return null;
  return draft.pool.find(p=>p.pid===pid);
}
function scoutingAssignmentLimit(meta){ return 2 + (meta?.scouting?.staff?.lead||0); }
function toggleScoutAssignment(tid, prospect){ ensureTeamMeta(); const meta=State.teamMeta[tid]; if(!meta?.scouting) return; const scouting=meta.scouting; scouting.assignments=scouting.assignments||{}; const assigned=scouting.assignments[prospect.pid]; if(assigned){ delete scouting.assignments[prospect.pid]; State.devLogs.push(`[スカウト] ${id2name(tid)}は${prospect.name}の調査を中止しました。`); return; }
  const activeCount=Object.values(scouting.assignments).filter(a=>a&&a.active!==false).length; const limit=scoutingAssignmentLimit(meta);
  if(activeCount>=limit){ State.devLogs.push(`[スカウト] ${id2name(tid)}は既に最大人数を調査中です。`); return; }
  if((scouting.points||0)<SCOUT_ASSIGN_COST){ State.devLogs.push(`[スカウト] ${id2name(tid)}は調査Ptが不足しています。`); return; }
  scouting.points=clamp((scouting.points||0)-SCOUT_ASSIGN_COST,0,scouting.maxPoints||24);
  scouting.assignments[prospect.pid]={ active:true, focus:prospect.type, started:State.curr_day||1 };
  const report=ensureProspectTeamReport(prospect, tid); if(report.progress<0.02){ report.progress+=0.02*(scouting.staff?.lead||0); }
  State.devLogs.push(`[スカウト] ${id2name(tid)}が${prospect.name}の詳細調査を開始しました。`);
}

function runScoutingTask(mode='daily'){
  const draft = ensureDraftStateRecord(State);
  if(!Array.isArray(draft.pool) || draft.pool.length===0) return;
  ensureTeamMeta();
  const isWeekly=mode==='weekly';
  for(const team of State.teams){
    const tid=team.team_id;
    const meta=State.teamMeta[tid];
    if(!meta?.scouting) continue;
    const scouting=meta.scouting;
    const staff=scouting.staff||{lead:1,bat:0,pit:0};
    const pointGainBase=isWeekly?3.5:0.6;
    const staffPointBonus=(staff.lead||0)*0.35;
    scouting.points=clamp((scouting.points||0)+pointGainBase+staffPointBonus,0,scouting.maxPoints||24);
    for(const [pid, assignment] of Object.entries(scouting.assignments||{})){
      if(!assignment || assignment.active===false) continue;
      const prospect=findDraftProspect(pid);
      if(!prospect){ delete scouting.assignments[pid]; continue; }
      ensureProspectStructure(prospect);
      const report=ensureProspectTeamReport(prospect, tid);
      const baseGain=isWeekly?0.18:0.05;
      const focusBonus=(prospect.type==='BAT'?(staff.bat||0):(staff.pit||0))*0.04;
      const leadBonus=(staff.lead||0)*0.08;
      const gain=baseGain*(1+focusBonus+leadBonus);
      const prev=report.progress||0;
      report.progress=clamp(prev+gain,0,1);
      report.lastUpdate=mode;
      if(report.progress>=1 && assignment.active){ assignment.active=false; assignment.completed=true; State.devLogs.push(`[スカウト] ${id2name(tid)}は${prospect.name}の詳細情報を把握しました。`); }
    }
  }
}

// ====== Squads & Rotation ======
const SQUAD_MOVE_COOLDOWN_DAYS = 3;
function ensureSquads(){ if(State.squadsInit) return; initializePlayerSpecials(); State.squads={}; State.rotation={}; ensureTeamMeta();
  if(!State.squadMoveLog || typeof State.squadMoveLog !== 'object') State.squadMoveLog={};
  for(const t of State.teams){
    const R=State.rosters[t.team_id];
    // backfill data for older save files
    [...R.bats, ...R.pits].forEach(p => {
        if (p.morale === undefined) p.morale = 60;
        if (p.fatigue === undefined) p.fatigue = 20;
        if (!p.traits) p.traits = [];
        if (!p.status) p.status = { hot: 0, slump: 0 };
        if (p.injury === undefined) p.injury = null;
        if (p.role === 'RP' && !p.sub_role) p.sub_role = '中継ぎ';
        if (!p.history) p.history = { overall: [getOverall(p)], fatigue: [p.fatigue], morale: [p.morale] };
        if (!p.recentGains) p.recentGains = [];
        if (typeof p.isForeign !== 'boolean') p.isForeign = Boolean(p.isForeign);
        if (!p.origin) p.origin = p.isForeign ? 'international' : 'domestic';
        if(!Number.isFinite(p.lastSquadMoveDay)){
          const logDay=Number(State.squadMoveLog?.[p.id]);
          p.lastSquadMoveDay=Number.isFinite(logDay)?logDay:null;
        }
    });
    autoAssignSquads(t.team_id);
  }
  recomputeTeamModsAll(); State.squadsInit=true;
  refreshRosterComplianceAll();
}
function moveSquad(tid,pid,to,options={}){
  ensureSquads();
  const s=State.squads[tid];
  const opts=options||{};
  if(!s) return { ok:false, reason:'所属チームが見つかりません。' };
  const day=State.curr_day||1;
  const player=findPlayerById(tid,pid);
  const current=s.ichi.includes(pid)?'一軍':(s.ni.includes(pid)?'二軍':null);
  if(current===to){
    return { ok:true, changed:false, from:current, to, playerName:player?.name||null };
  }
  const storedMove=Number(State.squadMoveLog?.[pid]);
  const lastMove=Number.isFinite(player?.lastSquadMoveDay)?player.lastSquadMoveDay: (Number.isFinite(storedMove)?storedMove:null);
  const cooldown=Math.max(0, opts.force?0:SQUAD_MOVE_COOLDOWN_DAYS);
  if(cooldown>0 && Number.isFinite(lastMove)){
    const availableDay=lastMove+cooldown;
    if(day<availableDay){
      const remaining=Math.max(1, availableDay-day);
      const teamName=id2name(tid);
      const playerName=player?.name||`ID:${pid}`;
      const direction=to==='一軍'?'昇格':'降格';
      const reason=`${playerName}はクールダウン期間中のため${direction}できません。`;
      const log=`[編成制限] ${teamName} ${playerName}はクールダウン中のため${direction}不可（残り${remaining}日）`;
      if(!Array.isArray(State.devLogs)) State.devLogs=[];
      State.devLogs.push(log);
      const error={ type:'squad-move-cooldown', teamId:tid, playerId:pid, playerName, currentSquad:current, requestedSquad:to, remainingDays:remaining, cooldownDays:cooldown, availableDay, day };
      return { ok:false, reason, remainingDays:remaining, error };
    }
  }
  s.ichi=s.ichi.filter(x=>x!==pid);
  s.ni=s.ni.filter(x=>x!==pid);
  if(to==="一軍") s.ichi.push(pid); else s.ni.push(pid);
  if(!Array.isArray(State.devLogs)) State.devLogs=[];
  const teamName=id2name(tid);
  const playerName=player?.name||`ID:${pid}`;
  State.devLogs.push(`[編成] ${teamName} ${playerName}を${to}へ移動 (${day}日目)`);
  if(player) player.lastSquadMoveDay=day;
  if(!State.squadMoveLog || typeof State.squadMoveLog !== 'object') State.squadMoveLog={};
  State.squadMoveLog[pid]=day;
  evaluateRosterComplianceForTeam(tid);
  return { ok:true, changed:true, from:current, to, day, playerName };
}

// ====== Roster AI & Strategy (v12) ======
function ensureTeamStrategy(tid){
  if(!State.teamStrategy) State.teamStrategy = {};
  if(!State.teamStrategy[tid]){
    State.teamStrategy[tid] = { roster: 'default', lineup: 'condition' };
  }
}

function getPlayerRosterValue(player, strategy = { roster: 'default' }) {
    if(player.injury) return 0.1; // Injured players have minimal value for roster assignment
    const isPitcher = !!player.velo;
    let rating, potential_w = 0.25, age_mod = 1.0;

    if (isPitcher) {
        rating = (player.velo * 0.35 + player.mov * 0.35 + player.ctrl * 0.2 + player.stam * 0.1);
    } else {
        rating = (0.35 * player.con + 0.1 * player.disc + 0.2 * player.pwr + 0.05 * player.spd + 0.3 * player.fld);
    }
    if (player.age < 24) age_mod = 1.03; 
    else if (player.age >= 25 && player.age <= 31) age_mod = 1.05;
    else if (player.age > 34) age_mod = 0.92;

    if (strategy.roster === 'youth') {
        potential_w = 0.5;
        if (player.age < 25) age_mod = 1.15;
        else if (player.age > 30) age_mod = 0.8;
    } else if (strategy.roster === 'veteran') {
        potential_w = 0.1;
        if (player.age > 32) age_mod = 1.1;
        else if (player.age < 26) age_mod = 0.9;
    } else { // default
        if (player.age < 27) potential_w = 0.4;
    }

    return (rating * (1 - potential_w) + player.pot * potential_w) * age_mod;
}

function autoAssignSquads(tid) {
    ensureTeamStrategy(tid);
    const strategy = State.teamStrategy[tid];
    const R = State.rosters[tid];
    
    const allPlayers = [...R.bats, ...R.pits].map(p => ({ player: p, value: getPlayerRosterValue(p, strategy) }));
    
    const bats = allPlayers.filter(item => !item.player.velo).sort((a, b) => b.value - a.value);
    const pitsSP = allPlayers.filter(item => item.player.velo && item.player.role === "SP").sort((a, b) => b.value - a.value);
    const pitsRP = allPlayers.filter(item => item.player.velo && item.player.role !== "SP").sort((a, b) => b.value - a.value);

    const ichi = new Set();
    bats.slice(0, 13).forEach(item => ichi.add(item.player.id));
    pitsSP.slice(0, 5).forEach(item => ichi.add(item.player.id));
    pitsRP.slice(0, 8).forEach(item => ichi.add(item.player.id));

    const ni = [...R.bats, ...R.pits].filter(p => !ichi.has(p.id)).map(p => p.id);

  State.squads[tid] = { ichi: [...ichi], ni: [...ni] };
  State.rotation[tid] = { order: pitsSP.slice(0, 5).map(p => p.player.id), idx: 0 };

  logHighlight('shuffle', `[${id2name(tid)}] ロースター自動編成を実行しました。(方針: ${strategy.roster})`);
  evaluateRosterComplianceForTeam(tid);
}

// ====== Lineup Selection (v12 Natural) ======
function gameDayBattingScore(player, oppHand = "R", strategy = { lineup: 'condition' }) {
    let score = battingScore(player, oppHand);
    const fatigue = player.fatigue || 0;
    const morale = player.morale || 60;
    
    let fatigue_penalty = fatigue / 180;
    if (strategy.lineup === 'best_member') {
        fatigue_penalty = fatigue / 300; // Reduce fatigue penalty
    }

    score *= (1 - fatigue_penalty); 
    score *= (1 + (morale - 60) / 200);
    if (player.status?.hot > 0) score *= 1.15;
    if (player.status?.slump > 0) score *= 0.85;
    return Math.max(score, 0);
}

function relieverReadinessScore(p) {
    const rating = p.velo * 0.45 + p.mov * 0.35 + p.ctrl * 0.2;
    const fatigue = p.fatigue || 0;
    return rating * (1 - (fatigue / 110));
}

function pickDayLineup(tid, dayOverride=null){
  ensureSquads();
  ensureTeamStrategy(tid);
  const strategy = State.teamStrategy[tid];
  const R=State.rosters[tid];
  const ichi=new Set(State.squads[tid].ichi);

  const gameDay = dayOverride ?? (State.curr_day||1);
  const hasGameToday = State.schedule.some(evt=>evt.day===gameDay && (evt?.type||'game')==='game' && (evt.home_id===tid || evt.away_id===tid));
  if(!hasGameToday){
    return {bats:[],sp:null,rps:[]};
  }

  const bats=R.bats.filter(batter=>ichi.has(batter.id) && !batter.injury).sort((a,b)=>gameDayBattingScore(b,"R", strategy)-gameDayBattingScore(a,"R", strategy)).slice(0,9);

  const SPorder=State.rotation[tid]?.order||[];
  let idx=State.rotation[tid]?.idx||0;
  let sp = null;
  let spFound = false;
  for(let i=0; i<SPorder.length; i++){
    const currentIdx = (idx + i) % SPorder.length;
    const potentialSpId = SPorder[currentIdx];
    const potentialSp = R.pits.find(p => p.id === potentialSpId);
    if(potentialSp && !potentialSp.injury && (potentialSp.fatigue || 0) < 80) {
        sp = potentialSp;
        idx = (currentIdx + 1) % SPorder.length;
        spFound = true;
        break;
    }
  }
  
  if (!spFound) {
    sp = R.pits.filter(p => p.role === "SP" && ichi.has(p.id) && !p.injury)
               .sort((a,b) => (a.fatigue || 0) - (b.fatigue || 0))[0];
  }
  State.rotation[tid]={order:SPorder,idx};
  
  const rps=R.pits.filter(p=>p.role!=="SP" && ichi.has(p.id) && !p.injury)
    .sort((a,b)=> relieverReadinessScore(b) - relieverReadinessScore(a))
    .slice(0,5);
  
  return {bats,sp,rps};
}


// ====== Training System (v12) ======
const FOCUS_BAT=["Con","Disc","Pwr","Spd","Fld"], FOCUS_PIT=["Velo","Ctrl","Mov","Stam"]; const INTENS={"軽":0.7,"標準":1.0,"強":1.3};
function ageCurve(age){ if(age<=22) return 1.20; if(age<=27) return 1.00; if(age<=31) return 0.85; return 0.60; }
function ensureTrainingDefaults(tid){ const tp=State.trainingPlans[tid]||{}; const R=State.rosters[tid]; for(const batter of R.bats){ if(!tp[batter.id]) tp[batter.id]={focus:(batter.pwr<batter.con?"Pwr":"Con"),intens:"標準"}; if(!batter.status) batter.status={hot:0,slump:0}; }
  for(const p of R.pits){ if(!tp[p.id]) tp[p.id]={focus:(p.ctrl<p.velo?"Ctrl":"Mov"),intens:"標準"}; if(!p.status) p.status={hot:0,slump:0}; } State.trainingPlans[tid]=tp; }
function autoPlan(tid){ const tp=State.trainingPlans[tid]||{}; const R=State.rosters[tid]; for(const batter of R.bats){ const gapCon=batter.pot-batter.con, gapPwr=batter.pot-batter.pwr; tp[batter.id]={focus:(gapCon>gapPwr)?"Con":"Pwr",intens:"標準"}; } for(const p of R.pits){ const gaps=[["Ctrl",p.pot-p.ctrl],["Mov",p.pot-p.mov],["Velo",p.pot-p.velo]]; gaps.sort((a,b)=>b[1]-a[1]); tp[p.id]={focus:gaps[0][0],intens:"標準"}; } State.trainingPlans[tid]=tp; }
// ====== Traits & Special Effects ======
const TRAIT_RULES = [
  {id:'power_hitter',   name:getSpecialById('power_hitter')?.name || 'パワーヒッター', cond:(p)=>p.pwr>=85},
  {id:'plate_discipline', name:getSpecialById('plate_discipline')?.name || '選球眼〇', cond:(p)=>p.con>=75 && p.disc>=75},
  {id:'speedster',       name:getSpecialById('speedster')?.name || '快足', cond:(p)=>p.spd>=85},
  {id:'precision_pitcher', name:getSpecialById('precision_pitcher')?.name || '精密機械', cond:(p)=>p.ctrl>=84},
  {id:'power_pitcher',   name:getSpecialById('power_pitcher')?.name || '剛腕', cond:(p)=>p.velo>=90},
  {id:'iron_arm',        name:getSpecialById('iron_arm')?.name || '鉄腕', cond:(p)=>p.stam>=88},
  {id:'lefty_killer',    name:getSpecialById('lefty_killer')?.name || '対左投手○', cond:(p)=>['R','右','S','両'].includes(p.hand||'') && p.con>=78 && p.pwr>=75},
  // New unlockables by thresholds
  {id:'slugger_elite',   name:getSpecialById('slugger_elite')?.name || '長距離砲', cond:(p)=>p.pwr>=90},
  {id:'contact_master',  name:getSpecialById('contact_master')?.name || '巧打職人', cond:(p)=>p.con>=85 && p.disc>=78},
  {id:'defense_specialist', name:getSpecialById('defense_specialist')?.name || '守備職人', cond:(p)=>p.fld!==undefined && p.fld>=88},
  {id:'strikeout_machine', name:getSpecialById('strikeout_machine')?.name || '奪三振マシン', cond:(p)=>p.velo!==undefined && p.velo>=88 && p.mov>=84},
  {id:'pitch_to_contact', name:getSpecialById('pitch_to_contact')?.name || '打たせて取る', cond:(p)=>p.ctrl!==undefined && p.ctrl>=86 && p.mov>=82},
  {id:'clutch_hitter',   name:getSpecialById('clutch_hitter')?.name || 'クラッチヒッター', cond:(p)=>p.con!==undefined && p.pwr!==undefined && p.con>=80 && p.pwr>=80},
  {id:'elite_closer',    name:getSpecialById('elite_closer')?.name || 'クローザー◎', cond:(p)=>p.role==='RP' && p.ctrl>=82 && p.mov>=82},
  {id:'iron_man',        name:getSpecialById('iron_man')?.name || '鉄人', cond:(p)=> (p.stam||p.spd||0) >= 90}
];

const SPECIAL_TRAIT_POOL_BAT = ['captain','mood_maker','clutch_hitter','defense_specialist','slugger_elite','contact_master','lefty_killer','iron_man'];
const SPECIAL_TRAIT_POOL_PIT = ['captain','mood_maker','elite_closer','strikeout_machine','pitch_to_contact','iron_man'];

function hasTrait(player, identifier){
  return playerHasSpecial(player, identifier);
}

function initializePlayerSpecials(){
  const shouldAssign = !State.specialsInit;
  const rng = shouldAssign ? mulberry32((State.seed||2025)+5555) : null;
  for(const tid of Object.keys(State.rosters||{})){
    const R = State.rosters[tid];
    if(!R) continue;
    for(const batter of (R.bats||[])){
      if(!batter) continue;
      const traits = normalizePlayerSpecials(batter);
      if(shouldAssign && rng()<0.10){
        const t = SPECIAL_TRAIT_POOL_BAT[Math.floor(rng()*SPECIAL_TRAIT_POOL_BAT.length)];
        if(t && !traits.includes(t)) traits.push(t);
      }
    }
    for(const pitcher of (R.pits||[])){
      if(!pitcher) continue;
      const traits = normalizePlayerSpecials(pitcher);
      if(shouldAssign && rng()<0.10){
        const t = SPECIAL_TRAIT_POOL_PIT[Math.floor(rng()*SPECIAL_TRAIT_POOL_PIT.length)];
        if(t && !traits.includes(t)) traits.push(t);
      }
    }
  }
  if(shouldAssign) State.specialsInit=true;
}

function computeTeamMods(tid){
  const R=State.rosters[tid]; const ichi=new Set(State.squads[tid]?.ichi||[]);
  const bats=R.bats.filter(batter=>ichi.has(batter.id)).slice().sort((a,b)=> battingScore(b,"R") - battingScore(a,"R")).slice(0,9);
  const sp5=R.pits.filter(p=>p.role==="SP" && ichi.has(p.id)).slice().sort((a,b)=>(b.stam*.2+b.velo*.4+b.mov*.3+b.ctrl*.1)-(a.stam*.2+a.velo*.4+a.mov*.3+a.ctrl*.1)).slice(0,5);
  const rp5=R.pits.filter(p=>p.role!=="SP" && ichi.has(p.id)).slice().sort((a,b)=>(b.velo*.45+b.mov*.35+b.ctrl*.2)-(a.velo*.45+a.mov*.35+a.ctrl*.2)).slice(0,5);
  const mods={onb:0,pow:0,def:0,sp:0,rp:0,extraAtk:0,extraDef:0,teamTrain:0,hotDelta:0,slumpDelta:0,fatigueTeam:1.0,moraleAura:0};
  collectPlayerEffects(bats, 'teamMods:lineup', mods);
  collectPlayerEffects(sp5, 'teamMods:rotation', mods);
  collectPlayerEffects(rp5, 'teamMods:bullpen', mods);

  const closer = R.pits.find(p => ichi.has(p.id) && p.sub_role === 'クローザー');
  if (closer) {
      mods.extraDef = (mods.extraDef || 0) + 0.04;
  }
  const setup_men = R.pits.filter(p => ichi.has(p.id) && p.sub_role === 'セットアッパー');
  if (setup_men.length > 0) {
      mods.rp = (mods.rp || 0) + setup_men.length * 1.5; 
  }

  return mods;
}

function recomputeTeamModsAll(){ State.teamMods={}; for(const t of State.teams){ State.teamMods[t.team_id]=computeTeamMods(t.team_id); } }
function appearanceBoost(pid){ const pts=(State.weekXP[pid]||0); return 1+Math.min(.2, pts*.01); }
const WEEK_XP_LOG_WINDOW = 12;
function ensureWeekXPLog(){
  if(!State.weekXPLog) State.weekXPLog={};
}
function addWeekXP(pid, amount){
  if(!amount) return;
  State.weekXP[pid]=(State.weekXP[pid]||0)+amount;
  ensureWeekXPLog();
  const arr=State.weekXPLog[pid]||(State.weekXPLog[pid]=[]);
  arr.push({day:State.curr_day||0,xp:amount});
  if(arr.length>WEEK_XP_LOG_WINDOW) arr.splice(0, arr.length-WEEK_XP_LOG_WINDOW);
}
function getWeekXPSeries(pid){
  return (State.weekXPLog?.[pid]||[]).map(entry=>entry.xp);
}
function trainingSupportMultiplier(player, focus, tid, support){
  const adjustments = support || getTeamSupportAdjustments(tid);
  const staff = adjustments.staff || {};
  const facilities = adjustments.facilities || {};
  const isPitch = player.velo !== undefined;
  let multiplier = (staff.growth?.global ?? 1) * (facilities.growth?.global ?? 1);

  if (!isPitch) {
    multiplier *= staff.growth?.hitting ?? 1;
    if (["Con", "Disc", "Fld"].includes(focus)) {
      multiplier *= facilities.growth?.battingPrecision ?? 1;
    }
    if (["Pwr"].includes(focus)) {
      multiplier *= facilities.growth?.battingPower ?? 1;
    }
    if (["Spd"].includes(focus)) {
      multiplier *= facilities.growth?.speed ?? 1;
    }
    if (["Stam"].includes(focus)) {
      multiplier *= facilities.growth?.stamina ?? 1;
    }
  } else {
    multiplier *= staff.growth?.pitching ?? 1;
    if (["Ctrl", "Mov"].includes(focus)) {
      multiplier *= facilities.growth?.pitchingCommand ?? 1;
    }
    if (["Velo"].includes(focus)) {
      multiplier *= facilities.growth?.pitchingPower ?? 1;
    }
    if (["Stam"].includes(focus)) {
      multiplier *= facilities.growth?.stamina ?? 1;
    }
  }

  return multiplier;
}
function moraleFatigueMult(player){ const morale=player.morale??60, fatigue=player.fatigue??20; const moraleF=1+(morale-50)/250; const fatigueF=1-(fatigue)/200; const hot=(player.status?.hot||0)>0?1.15:1.0; const slump=(player.status?.slump||0)>0?0.8:1.0; return clamp(moraleF*fatigueF*hot*slump,0.5,1.4); }
function weeklyRecovery(player, tid, intens, support){
  const adjustments = support || getTeamSupportAdjustments(tid);
  const staff = adjustments.staff || {};
  const facilities = adjustments.facilities || {};
  const baseRec = (intens==="軽"?12:(intens==="標準"?8:4));
  const recoveryMult = (staff.recovery?.mult ?? 1) * (facilities.recovery?.mult ?? 1);
  const recoveryFlat = (staff.recovery?.flat ?? 0) + (facilities.recovery?.flat ?? 0);
  const injuryDurationMult = Math.max(0.3, (staff.injuryDuration ?? 1) * (facilities.injuryDuration ?? 1));
  let totalRecovery = Math.max(0, baseRec * recoveryMult + recoveryFlat);
  if (player?.injury) {
    const injuryPenalty = clamp(0.6 / injuryDurationMult, 0.35, 1.05);
    totalRecovery *= injuryPenalty;
  }
  player.fatigue = clamp((player.fatigue||0) - totalRecovery, 0, 100);
}
function dangerCheck(player, plan){ // risk of slump when overworked
  if(player.fatigue>85 && plan.intens==="強"){ if(Math.random()<0.15){ player.status.slump=Math.max(player.status.slump||0,2); return "フォーム崩れ(2週)"; } }
  return null;
}
function rollHotStreak(player){ if(player.morale>85 && Math.random()<0.08){ player.status.hot=Math.max(player.status.hot||0,2); return "開眼(2週)"; } return null; }

function applyTrainingWeekToPlayer(player, plan, tid, support){
  const isPitch=(player.velo!==undefined); const focus=plan.focus; const intens=INTENS[plan.intens||"標準"]||1.0;
  const supportAdjustments = support || getTeamSupportAdjustments(tid);
  const staffAdjust = supportAdjustments.staff || {};
  const facilityAdjust = supportAdjustments.facilities || {};

  if (player.injury) {
    weeklyRecovery(player, tid, '軽', supportAdjustments);
    return [`リハビリ中 (${player.injury.type})`];
  }

  const ov=isPitch?(player.velo*.4+player.mov*.4+player.ctrl*.2):(player.con*.5+player.disc*.2+player.pwr*.3);
  const baseGrowth=Math.max(0,(player.pot||60)-ov)/100; // 0..~0.4
  let mult = ageCurve(player.age||25) * intens * appearanceBoost(player.id) * trainingSupportMultiplier(player, focus, tid, supportAdjustments) * moraleFatigueMult(player) * (1 + ((State.teamMods?.[tid]?.teamTrain)||0));
  mult = clamp(mult, 0.35, 1.8);
  // Crit / Weak outcomes influenced by morale & fatigue
  const morale=player.morale||60, fatigue=player.fatigue||20; const critP=clamp(0.05 + (morale-50)/300 - (fatigue-30)/400, 0.02, 0.25); const weakP=clamp(0.08 + (fatigue-40)/300, 0.05, 0.35);
  const r=Math.random(); if(r<critP) mult*=1.5; else if(r>1-weakP) mult*=0.75;
  const noise=(Math.random()*0.4+0.8);
  const delta=baseGrowth*mult*noise; // 0..something
  let gains=[];
  function inc(key, amt){ const before=player[key]; player[key]=clamp(Math.round(before+amt),30,99); if(player[key]!==before) gains.push(`${key[0].toUpperCase()}${key.slice(1)}+${player[key]-before}`); }
  if(!isPitch){ if(focus==="Con") inc("con", +2.2*delta); if(focus==="Disc") inc("disc", +1.7*delta); if(focus==="Pwr") inc("pwr", +2.3*delta); if(focus==="Spd") inc("spd", +1.6*delta); if(focus==="Fld") inc("fld", +1.8*delta); }
  else{ if(focus==="Velo") inc("velo", +2.0*delta); if(focus==="Ctrl") inc("ctrl", +2.0*delta); if(focus==="Mov") inc("mov", +2.0*delta); if(focus==="Stam") inc("stam", +1.6*delta); }
  // Small chance to raise potential when doing well
  if(delta>0.4 && player.pot<99 && Math.random()<0.10){ player.pot=clamp(player.pot+1,30,99); gains.push("ポテンシャル+1"); }
  // Traits
  const playerTraits = normalizePlayerSpecials(player);
  const intensityKey = plan.intens || '標準';
  const baseTraitChance = intensityKey === '強' ? 0.22 : (intensityKey === '軽' ? 0.12 : 0.16);
  const performanceFactor = clamp(delta, 0, 1.2);
  const baseChance = clamp(baseTraitChance * (1 + performanceFactor * 0.6), 0.02, 0.85);
  const traitMultiplier = (staffAdjust.specialAwaken ?? 1) * (facilityAdjust.specialAwaken ?? 1);
  for(const tr of TRAIT_RULES){
    if(!playerTraits.includes(tr.id) && tr.cond(player)){
      const ruleBase = tr.chance != null ? tr.chance : baseChance;
      const awakenChance = clamp(ruleBase * traitMultiplier, 0, 0.95);
      if(Math.random() < awakenChance){
        playerTraits.push(tr.id);
        const special = getSpecialById(tr.id);
        const traitName = special?.name || tr.name || tr.id;
        gains.push(`特能:${traitName}`);
        logHighlight('award', `【覚醒】${player.name}が特能『${traitName}』を習得しました！`);
      }
    }
  }

  // Morale & status updates
  if(gains.length>0) player.morale=clamp((player.morale||60)+3,0,100); else player.morale=clamp((player.morale||60)-1,0,100);
  const slump=dangerCheck(player, plan); const hot=rollHotStreak(player); if(slump) gains.push(slump); if(hot) gains.push(hot);
  weeklyRecovery(player, tid, plan.intens, supportAdjustments);
  return gains;
}
function tickStatuses(player){ if(player.status){ if(player.status.hot>0) player.status.hot--; if(player.status.slump>0) player.status.slump--; } }

function applyTrainingWeek(tid,weeks=1,label="週次育成"){
  ensureSquads(); ensureTrainingDefaults(tid); ensureTeamMeta(); const team=State.teams.find(t=>t.team_id===tid); const logs=[];
  const maxHistory = 10;
  for(let w=0; w<weeks; w++){
    const tmods = (State.teamMods?.[tid]) || {};
    if(tmods.moraleAura){ [...State.rosters[tid].bats, ...State.rosters[tid].pits].forEach(p=>{ p.morale = clamp((p.morale||60) + tmods.moraleAura, 0, 100); }); }

    const supportAdjustments = getTeamSupportAdjustments(tid);

    const weekLabel = weeks > 1 ? `${label} ${w+1}週目` : label;
    const niList = Array.isArray(State.squads?.[tid]?.ni) ? State.squads[tid].ni.slice() : [];
    niList.forEach(pid=>{ addWeekXP(pid, 12); const P=findPlayerById(tid,pid); if(P) P.morale=clamp((P.morale||60)-1,0,100); });
    
    // Apply training and update history in one loop
    [...State.rosters[tid].bats, ...State.rosters[tid].pits].forEach(player => {
        const gains = applyTrainingWeekToPlayer(player, State.trainingPlans[tid][player.id], tid, supportAdjustments);
        player.recentGains = gains.filter(g => !g.includes('リハビリ中'));
        if (gains.length && !gains[0].includes('リハビリ中')) {
            logs.push(`[${team.team}] ${player.name}: ${gains.join(', ')}`);
        }
        tickStatuses(player);

        // Update history
        player.history.overall.push(getOverall(player));
        player.history.fatigue.push(player.fatigue);
        player.history.morale.push(player.morale);
        if (player.history.overall.length > maxHistory) player.history.overall.shift();
        if (player.history.fatigue.length > maxHistory) player.history.fatigue.shift();
        if (player.history.morale.length > maxHistory) player.history.morale.shift();
    });

    const recoveryMult = (supportAdjustments.staff.recovery?.mult ?? 1) * (supportAdjustments.facilities.recovery?.mult ?? 1);
    const recoveryFlat = (supportAdjustments.staff.recovery?.flat ?? 0) + (supportAdjustments.facilities.recovery?.flat ?? 0);
    const traitRate = (supportAdjustments.staff.specialAwaken ?? 1) * (supportAdjustments.facilities.specialAwaken ?? 1);
    const farmOutcome = applyFarmEffects(State, {
        teamId: tid,
        days: 7,
        label: weekLabel,
        traitRules: TRAIT_RULES,
        modifiers: {
            recoveryMult,
            recoveryFlat,
            traitUnlockRate: traitRate
        }
    });
    farmOutcome.players.forEach(result => {
        const player = findPlayerById(tid, result.playerId);
        if (!player) return;

        if (!player.history) player.history = { overall: [getOverall(player)], fatigue: [player.fatigue||20], morale: [player.morale||60], farmReveal: [Math.round(result.revealAfter)] };
        if (!Array.isArray(player.history.farmReveal)) player.history.farmReveal = [];
        player.history.farmReveal.push(Math.round(result.revealAfter));
        if (player.history.farmReveal.length > maxHistory) player.history.farmReveal.shift();

        const entry = {
            day: State.curr_day ?? 0,
            label: weekLabel,
            revealGain: result.revealGain,
            revealAfter: result.revealAfter,
            fatigueRecovered: result.fatigueRecovered,
            traitUnlocks: result.traitUnlocks.slice(),
            milestones: result.milestones.slice(),
            summary: result.messages.slice(),
        };
        const farmLog = player.farmLog || (player.farmLog = []);
        farmLog.push(entry);
        if (farmLog.length > 8) farmLog.splice(0, farmLog.length - 8);
        player.farmLast = entry;
        player.farmReveal = result.revealAfter;

        const updates = [];
        if (result.revealGain > 0) updates.push(`潜在+${result.revealGain}% (累計${result.revealAfter}%)`);
        if (result.fatigueRecovered > 0) updates.push(`疲労-${result.fatigueRecovered}`);
        result.milestones.forEach(mark => {
            updates.push(`節目${mark}%`);
            if (mark === 100) {
                logHighlight('sparkle', `【開示完了】${player.name}の潜在が全て見えるようになった！`, { tid });
            }
        });
        const playerTraits = normalizePlayerSpecials(player);
        result.traitUnlocks.forEach(trait => {
            const traitId = findSpecialId(trait) || trait;
            if (!playerTraits.includes(traitId)) {
                playerTraits.push(traitId);
                const special = getSpecialById(traitId);
                const traitName = special?.name || trait;
                updates.push(`覚醒:${traitName}`);
                logHighlight('award', `【覚醒】${player.name}が特能『${traitName}』を二軍練習で習得しました！`, { tid });
            }
        });
        if (updates.length) {
            logs.push(`[${team.team}] ${player.name}: 二軍 ${updates.join(', ')}`);
        }
    });

    State.weekXP={};
  }
  recomputeTeamRatings(team, State.rosters[tid], new Set(State.squads[tid].ichi));
  State.devLogs.push(`${label}（${team.team}）：${weeks}週 / 更新:${logs.length}件`); State.devLogs.push(...logs.slice(-100));
}

// ====== Special Training (Manual) ======
function findPlayerById(tid,pid){ const R=State.rosters[tid]; return R.bats.find(b=>b.id===pid) || R.pits.find(p=>p.id===pid); }
function doSpecialTraining(tid,pid){ ensureTeamMeta(); const cost=5; 
  const P=findPlayerById(tid,pid); if(!P) return; 
  if (P.injury) { console.error('怪我中の選手は特訓できません'); return; }
  if(!dpSpend(tid,cost)){ console.error(`Devポイントが不足しています（必要:${cost}）`); return; }
  
  const isPitch=(P.velo!==undefined); const plan=State.trainingPlans[tid][pid]||{focus:isPitch?"Velo":"Con",intens:"標準"}; const focus=plan.focus;
  const morale=P.morale||60, fatigue=P.fatigue||20; const base=1 + (morale-50)/80 - (fatigue)/120; const r=Math.random(); let result,amt;
  if(r<0.20+Math.max(0,(morale-60))/200){ result="大成功"; amt= (isPitch?3.5:3.5) * base; }
  else if(r<0.75){ result="成功"; amt=(isPitch?2.2:2.2)*base; }
  else if(r<0.95){ result="微増"; amt=(isPitch?1.2:1.2)*base; }
  else { result="不調（スランプ1週）"; amt=0; P.status= P.status||{}; P.status.slump=Math.max(P.status.slump||0,1); }
  function inc(key,a){ const before=P[key]; P[key]=clamp(Math.round(before+a),30,99); return P[key]-before; }
  let changed=0; if(!isPitch){ if(focus==="Con") changed=inc("con",amt); if(focus==="Disc") changed=inc("disc",amt*0.8); if(focus==="Pwr") changed=inc("pwr",amt*1.1); if(focus==="Spd") changed=inc("spd",amt*0.7); if(focus==="Fld") changed=inc("fld",amt*0.9); }
  else{ if(focus==="Velo") changed=inc("velo",amt); if(focus==="Ctrl") changed=inc("ctrl",amt); if(focus==="Mov") changed=inc("mov",amt); if(focus==="Stam") changed=inc("stam",amt*0.8); }
  P.morale=clamp((P.morale||60)+(result==="不調（スランプ1週）"?-4:3),0,100); P.fatigue=clamp((P.fatigue||20)+6,0,100);
  State.devLogs.push(`特訓 ${result}：${State.teams.find(t=>t.team_id===tid).team} ${P.name} → ${focus}${changed>=0?`+${changed}`:changed}`);
  saveAndRerender();
}

// ====== State ======
const State=(function(){ const saved=localStorage.getItem(SAVE_KEY); if(saved){ try{ const obj=JSON.parse(saved); obj.version=15; obj.highlights = obj.highlights || []; obj.playoffs = normalizePlayoffState(obj.playoffs); obj.schedule = normalizeScheduleEntries(obj.schedule||[]); obj.gameRecaps = obj.gameRecaps || {}; obj.ui = obj.ui || {}; obj.ui.dashboardTab = obj.ui.dashboardTab || 'season'; obj.cachedMetrics = obj.cachedMetrics || {}; obj.historicalStats = obj.historicalStats || {}; obj.rosterCompliance = obj.rosterCompliance || {}; obj.squadMoveLog = (obj.squadMoveLog && typeof obj.squadMoveLog === 'object') ? obj.squadMoveLog : {}; normalizeTeamFinances(obj); normalizeRosterPlayers(obj); normalizeNarrativeState(obj); normalizeLeagueState(obj); normalizeSeasonInfo(obj); if(Array.isArray(obj.teams)){ obj.teams.forEach(team=>{ calculateDraftTeamNeeds(obj, team.team_id); }); } return obj; }catch(e){} }
  const teams=baseTeams.map(t=>({...t})); const rosters={}; teams.forEach(t=>{ rosters[t.team_id]=mkInitialRoster(t.team_id); });
  const baseState = { version:15, teams, rosters, schedule:[], results:[], curr_day:1, seed:2025, home_adv:0.05, trainingPlans:{}, devLogs:[], weekXP:{}, weekXPLog:{}, squads:{}, squadsInit:false, rotation:{}, teamMeta:{}, teamStrategy:{}, userTeamId:0, commissioner:false, playerStats:{}, playerGameLogs:{}, historicalStats:{}, season:1, highlights: [], playoffs: defaultPlayoffState(), gameRecaps:{}, teamFinances:{}, freeAgents:[], narrativeSettings:{ frequency:'standard', theme:'balanced' }, teamNarratives:{}, narrativeLog:[], ui:{ dashboardTab:'season' }, cachedMetrics:{}, league: defaultLeagueState(), seasonInfo: defaultSeasonInfo(), rosterCompliance:{}, squadMoveLog:{} };
  normalizeTeamFinances(baseState);
  normalizeRosterPlayers(baseState);
  normalizeNarrativeState(baseState);
  normalizeLeagueState(baseState);
  normalizeSeasonInfo(baseState);
  if(Array.isArray(baseState.teams)){ baseState.teams.forEach(team=>{ calculateDraftTeamNeeds(baseState, team.team_id); }); }
  return baseState;
})();

ensureTeamNeedsAll();

// ====== Narrative Events ======
const RIVALRY_MAP=new Map([
  [0,new Set([1,5])],
  [1,new Set([0])],
  [2,new Set([4])],
  [3,new Set([5])],
  [4,new Set([2])],
  [5,new Set([0,3])],
  [6,new Set([7])],
  [7,new Set([6])],
  [8,new Set([11])],
  [9,new Set([10])],
  [10,new Set([9])],
  [11,new Set([8])]
]);
const NARRATIVE_FREQ_MULTIPLIER={ low:0.6, standard:1, high:1.4 };

function ensureNarrativeState(){
  normalizeNarrativeState(State);
  const day=State.curr_day||1;
  (State.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const avg=Math.round(computeTeamAverageMorale(tid));
    recordTeamMoralePoint(tid, day, avg);
  });
}

function computeTeamAverageMorale(tid){
  const roster=State.rosters?.[tid];
  if(!roster) return 60;
  const players=[...(roster.bats||[]), ...(roster.pits||[])];
  if(players.length===0) return 60;
  const total=players.reduce((sum,p)=>sum+(p?.morale??60),0);
  return total/players.length;
}

function computeTeamAverageFatigue(tid){
  const roster=State.rosters?.[tid];
  if(!roster) return 20;
  const players=[...(roster.bats||[]), ...(roster.pits||[])];
  if(players.length===0) return 20;
  const total=players.reduce((sum,p)=>sum+(p?.fatigue??20),0);
  return total/players.length;
}

function recordTeamMoralePoint(tid, day, value){
  const narrative=State.teamNarratives?.[tid];
  if(!narrative) return;
  if(!Array.isArray(narrative.morale)) narrative.morale=[];
  const last=narrative.morale[narrative.morale.length-1];
  if(last && last.season===State.season && last.day===day){
    last.value=value;
  } else {
    narrative.morale.push({ season:State.season, day, value });
    if(narrative.morale.length>200) narrative.morale.splice(0, narrative.morale.length-200);
  }
}

function captureDailyMoraleSnapshot(day){
  ensureNarrativeState();
  (State.teams||[]).forEach(team=>{
    const tid=team.team_id;
    const avg=Math.round(computeTeamAverageMorale(tid));
    recordTeamMoralePoint(tid, day, avg);
  });
}

function pushRecentGain(player, gain){
  if(!player) return;
  if(!Array.isArray(player.recentGains)) player.recentGains=[];
  player.recentGains.push(gain);
  if(player.recentGains.length>8) player.recentGains.splice(0, player.recentGains.length-8);
}

function determineAbilityAttrFromPlayer(player){
  if(!player) return null;
  if(player.velo!=null) return 'velo';
  return 'con';
}

function getTopPlayersByOverall(tid, limit=5){
  const roster=State.rosters?.[tid];
  if(!roster) return [];
  return [...(roster.bats||[]), ...(roster.pits||[])]
    .filter(p=>p && !p.injury)
    .sort((a,b)=>getOverall(b)-getOverall(a))
    .slice(0, limit);
}

function getLowestMoralePlayers(tid, limit=4){
  const roster=State.rosters?.[tid];
  if(!roster) return [];
  return [...(roster.bats||[]), ...(roster.pits||[])]
    .filter(p=>p)
    .sort((a,b)=>(a.morale??60)-(b.morale??60))
    .slice(0, limit);
}

function isRivalPair(a,b){
  return (RIVALRY_MAP.get(a)?.has(b)) || (RIVALRY_MAP.get(b)?.has(a)) || false;
}

function getTeamStreakCached(tid, cache){
  if(cache.has(tid)) return cache.get(tid);
  const results=State.results||[];
  let wins=0, losses=0;
  for(let i=results.length-1;i>=0;i--){
    const game=results[i];
    if(game.home_id!==tid && game.away_id!==tid) continue;
    const won=game.winner_id===tid;
    if(wins===0 && losses===0){
      if(won) wins=1; else losses=1;
    } else if(wins>0){
      if(won) wins++; else break;
    } else if(losses>0){
      if(!won) losses++; else break;
    }
  }
  const data={ wins, losses };
  cache.set(tid,data);
  return data;
}

const narrativeEventTemplates=[
  {
    id:'momentumSurge',
    category:'team',
    mood:'positive',
    baseChance:0.95,
    tag:'士気上昇',
    icon:'party-popper',
    priority:3,
    generate({ resultsToday, streakCache }){
      const events=[];
      const winners=new Set((resultsToday||[]).map(r=>r.winner_id).filter(v=>v!=null));
      winners.forEach(tid=>{
        const streak=getTeamStreakCached(tid, streakCache).wins;
        if(streak>=3){
          const teamName=id2name(tid);
          const core=getTopPlayersByOverall(tid,6);
          const playerIds=core.map(p=>p.id);
          events.push({
            teamId:tid,
            title:'連勝ブースト',
            summary:`${teamName}が${streak}連勝で士気が最高潮に。`,
            detail:'連勝ムードでクラブハウスが一体感に包まれ、主力が自主的にリカバリーワークを行った。',
            playerIds,
            effects:{ morale:4, fatigue:-3 },
            highlightText:`${teamName}が${streak}連勝でチームの士気が跳ね上がる！`
          });
        }
      });
      return events;
    }
  },
  {
    id:'slumpMeeting',
    category:'team',
    mood:'positive',
    baseChance:0.7,
    tag:'士気会議',
    icon:'users',
    priority:1,
    generate({ streakCache }){
      const events=[];
      (State.teams||[]).forEach(team=>{
        const tid=team.team_id;
        const streak=getTeamStreakCached(tid, streakCache);
        const morale=computeTeamAverageMorale(tid);
        if(streak.losses>=3 || morale<48){
          const lowPlayers=getLowestMoralePlayers(tid,4);
          const playerIds=lowPlayers.map(p=>p.id);
          events.push({
            teamId:tid,
            title:'緊急ミーティング',
            summary:`${team.team}はキャプテン主導のミーティングで気持ちを立て直した。`,
            detail:'夜遅くまで課題を共有し、士気は上がったがやや疲労も蓄積。',
            playerIds,
            effects:{ morale:3, fatigue:2 },
            highlightText:`${team.team}がチームミーティングでモチベーションを再点火。`
          });
        }
      });
      return events;
    }
  },
  {
    id:'rivalryClash',
    category:'rivalry',
    mood:'positive',
    baseChance:1,
    tag:'ライバル戦',
    icon:'swords',
    priority:4,
    generate({ resultsToday }){
      const events=[];
      (resultsToday||[]).forEach(res=>{
        if(!isRivalPair(res.home_id, res.away_id)) return;
        const diff=Math.abs((res.home_runs??0)-(res.away_runs??0));
        if(diff>2) return;
        const key=gameRecapKey(res.day, res.home_id, res.away_id);
        const recap=State.gameRecaps?.[key];
        const winner=res.winner_id;
        const loser=winner===res.home_id?res.away_id:res.home_id;
        if(winner!=null){
          const playerId=recap?.decidingPlayerId||null;
          const player=playerId!=null?findPlayerById(winner, playerId):null;
          const abilityAttr=player?determineAbilityAttrFromPlayer(player):null;
          const abilityEffects=abilityAttr?[{ attr:abilityAttr, delta:1 }]:[];
          events.push({
            teamId:winner,
            title:'宿敵撃破',
            summary:`${id2name(winner)}がライバル${id2name(loser)}との接戦を制した。`,
            detail:'ベンチは大歓声。勝負所で集中力が高まり、主力にリラックスデーが与えられた。',
            playerIds:playerId?[playerId]:[],
            effects:{ morale:3, fatigue:-2, ability:abilityEffects },
            highlightText:`${id2name(winner)}がライバル${id2name(loser)}を撃破！`,
            metadata:{ opponentId:loser, rivalry:true }
          });
        }
        if(loser!=null){
          events.push({
            teamId:loser,
            title:'惜敗の悔しさ',
            summary:`${id2name(loser)}はライバル戦の惜敗で士気が沈んだ。`,
            detail:'試合後の反省会で課題を共有したが、気疲れが残っている。',
            effects:{ morale:-2, fatigue:2 },
            icon:'skull',
            mood:'negative',
            highlightText:`${id2name(loser)}はライバルに惜敗し悔しさを募らせている。`,
            metadata:{ opponentId:winner, rivalry:true }
          });
        }
      });
      return events;
    }
  },
  {
    id:'heroSpotlight',
    category:'player',
    mood:'positive',
    baseChance:0.75,
    tag:'モチベ向上',
    icon:'megaphone',
    priority:2,
    generate({ resultsToday }){
      const events=[];
      (resultsToday||[]).forEach(res=>{
        const key=gameRecapKey(res.day, res.home_id, res.away_id);
        const recap=State.gameRecaps?.[key];
        if(!recap?.decidingPlayerId) return;
        const winner=res.winner_id;
        const player=findPlayerById(winner, recap.decidingPlayerId);
        if(!player) return;
        if((player.morale??60) >= 85) return;
        const attr=determineAbilityAttrFromPlayer(player);
        events.push({
          teamId:winner,
          title:'ヒーローインタビュー',
          summary:`${player.name}はヒーローインタビューで闘志を燃やした。`,
          detail:'ファンからの声援に背中を押され、技術面の微調整にも手応えを掴んだ。',
          playerIds:[player.id],
          effects:{ morale:6, fatigue:1, ability: attr ? [{ attr, delta:1 }] : [] },
          highlightText:`${player.name}がヒーローインタビューでモチベーション急上昇！`
        });
      });
      return events;
    }
  },
  {
    id:'restDayReset',
    category:'team',
    mood:'positive',
    baseChance:0.6,
    tag:'調整日',
    icon:'leaf',
    priority:1,
    generate({ restDay }){
      if(!restDay) return [];
      const events=[];
      (State.teams||[]).forEach(team=>{
        const tid=team.team_id;
        if(computeTeamAverageFatigue(tid)>=45){
          events.push({
            teamId:tid,
            title:'リカバリー調整日',
            summary:`${team.team}は休養日を活かしてコンディショニングを実施。`,
            detail:'ストレッチとメンタルケアで疲労を抜き、穏やかな雰囲気が戻った。',
            effects:{ morale:2, fatigue:-6 },
            highlightText:`${team.team}が休養日でリカバリーセッションを実施。`
          });
        }
      });
      return events;
    }
  }
];

function themeChanceModifier(template, evt, theme){
  switch(theme){
    case 'heroic':
      return (evt.mood==='negative'?0.25:1.3);
    case 'drama':
      return (evt.mood==='negative'?1.3:0.9);
    case 'rivalry':
      return (evt.metadata?.rivalry || template.category==='rivalry')?1.4:0.6;
    default:
      return 1;
  }
}

function evaluateDailyNarrativeEvents(context){
  ensureNarrativeState();
  const day=context.day||State.curr_day||1;
  const season=State.season||1;
  const freqSetting=State.narrativeSettings?.frequency||'standard';
  const themeSetting=State.narrativeSettings?.theme||'balanced';
  const freqMult=NARRATIVE_FREQ_MULTIPLIER[freqSetting]??1;
  const resultsToday=context.resultsToday || (State.results||[]).filter(r=>r.day===day);
  const streakCache=context.streakCache||new Map();
  const acceptanceRng=mulberry32(((State.seed||2025)+day*197+season*67)>>>0);
  const baseSeed=((State.seed||2025)+day*149+season*31)>>>0;
  const produced=[];
  narrativeEventTemplates.forEach((template, idx)=>{
    const rng=mulberry32((baseSeed + hashString(template.id) + idx*97)>>>0);
    const generated=template.generate({ ...context, day, resultsToday, streakCache, rng });
    if(!Array.isArray(generated)) return;
    generated.forEach(evt=>{
      if(!evt || evt.teamId==null) return;
      evt.day=evt.day??day;
      evt.icon=evt.icon||template.icon;
      evt.tag=evt.tag||template.tag;
      evt.category=evt.category||template.category;
      evt.mood=evt.mood||template.mood||'positive';
      evt.priority=evt.priority??template.priority??1;
      const baseChance=evt.chance??template.baseChance??1;
      const themeWeight=themeChanceModifier(template, evt, themeSetting);
      if(themeWeight<=0) return;
      const adjustedChance=clamp(baseChance * freqMult * themeWeight, 0, 1);
      if(acceptanceRng()<=adjustedChance){
        produced.push(evt);
      }
    });
  });
  const maxEvents=Math.max(1, Math.round((context.restDay?1.2:2)*freqMult));
  if(produced.length>maxEvents){
    produced.sort((a,b)=> (b.priority||0) - (a.priority||0));
    return produced.slice(0, maxEvents);
  }
  return produced;
}

function applyNarrativeEvent(evt){
  ensureNarrativeState();
  const day=evt.day ?? (State.curr_day||1);
  const tid=evt.teamId;
  const roster=State.rosters?.[tid];
  if(!roster) return false;
  const rosterPlayers=[...(roster.bats||[]), ...(roster.pits||[])];
  const explicitPlayers=(Array.isArray(evt.playerIds)?evt.playerIds:[])
    .map(pid=>findPlayerById(tid,pid))
    .filter(Boolean);
  const targetPlayers=explicitPlayers.length?explicitPlayers:rosterPlayers;
  const abilityEffects=Array.isArray(evt.effects?.ability)?evt.effects.ability:[];
  const abilityTargets=abilityEffects.length && explicitPlayers.length?explicitPlayers: abilityEffects.length?targetPlayers:[];
  const moraleDelta=evt.effects?.morale||0;
  const fatigueDelta=evt.effects?.fatigue||0;
  const affectedNames=new Set();
  const abilityChanges=[];
  let abilityChanged=false;

  targetPlayers.forEach(player=>{
    if(!player) return;
    if(moraleDelta){
      player.morale=clamp((player.morale??60)+moraleDelta,0,100);
      affectedNames.add(player.name);
    }
    if(fatigueDelta){
      player.fatigue=clamp((player.fatigue??20)+fatigueDelta,0,100);
      affectedNames.add(player.name);
    }
  });

  abilityTargets.forEach(player=>{
    if(!player) return;
    abilityEffects.forEach(effect=>{
      const attr=effect?.attr;
      const delta=effect?.delta||0;
      if(!attr || typeof player[attr] !== 'number' || delta===0) return;
      const before=player[attr];
      player[attr]=clamp(before+delta,20,99);
      if(player[attr]!==before){
        abilityChanged=true;
        abilityChanges.push({ playerId:player.id, name:player.name, attr, before, after:player[attr] });
        pushRecentGain(player, `${attr.toUpperCase()}${delta>=0?'+':'-'}${Math.abs(delta)}`);
        affectedNames.add(player.name);
      }
    });
  });

  const narrative=State.teamNarratives[tid];
  const listedPlayers = targetPlayers.length>10 && explicitPlayers.length===0 ? ['チーム全体'] : Array.from(affectedNames);
  const logEntry={
    season:State.season,
    day,
    team_id:tid,
    title:evt.title||'イベント',
    summary:evt.summary||'',
    detail:evt.detail||'',
    icon:evt.icon||'sparkles',
    tag:evt.tag||'NARRATIVE',
    players:listedPlayers,
    metadata:evt.metadata||null,
    effects:{ morale:moraleDelta, fatigue:fatigueDelta, ability:abilityChanges }
  };
  if(narrative){
    if(!Array.isArray(narrative.events)) narrative.events=[];
    narrative.events.push(logEntry);
    if(narrative.events.length>150) narrative.events.splice(0, narrative.events.length-150);
  }
  if(Array.isArray(State.narrativeLog)){
    State.narrativeLog.push({ ...logEntry });
    if(State.narrativeLog.length>400) State.narrativeLog.splice(0, State.narrativeLog.length-400);
  }

  const highlightText=evt.highlightText || `${id2name(tid)}：${evt.summary || evt.title || '士気イベント発生'}`;
  logHighlight(evt.icon || 'sparkles', highlightText, { category:'narrative', tag: evt.tag || 'NARRATIVE', day, tid });

  return abilityChanged;
}

// ====== Player Stats Logic (NEW) ======
function weightedRandom(items, weightFn, rng) {
    let totalWeight = items.reduce((sum, item) => sum + weightFn(item), 0);
    if (totalWeight <= 0) return items[Math.floor(rng() * items.length)];
    let random = rng() * totalWeight;
    for (const item of items) {
        const weight = weightFn(item);
        if (random < weight) return item;
        random -= weight;
    }
    return items[items.length - 1];
}

function initializePlayerStats(pid) {
    if (!State.playerStats[pid]) {
        State.playerStats[pid] = {};
    }
    if(!State.playerGameLogs[pid]) State.playerGameLogs[pid] = [];
}

function allocateGameStatsDetailed(res, detail, rng, key, highlightMeta) {
    const recap = {
        gameKey: key,
        season: State.season,
        day: res.day,
        home_id: res.home_id,
        away_id: res.away_id,
        innings: res.innings || 9,
        score: { home: res.home_runs, away: res.away_runs },
        winner_id: res.winner_id,
        highlights: [],
        teams: {}
    };
    recap.scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
    const injuryCandidates = [];
    const margin = Math.abs(res.home_runs - res.away_runs);
    const winnerSide = res.winner_id === res.home_id ? 'home' : 'away';

    const processTeam = (side) => {
        const tid = side === 'home' ? res.home_id : res.away_id;
        const isWinner = res.winner_id === tid;
        const teamRecap = {
            team_id: tid,
            team_name: id2name(tid),
            runs: side === 'home' ? res.home_runs : res.away_runs,
            batting: [],
            pitching: { starter: null, relievers: [] },
            highlights: []
        };
        const lineupInfo = detail.lineups?.[side] || { batting: [], pitchers: [] };
        const battingStats = new Map((detail.stats?.[side]?.batting || []).map(s => [s.id, s]));
        const pitchingStats = new Map((detail.stats?.[side]?.pitching || []).map(s => [s.id, s]));

        lineupInfo.batting.forEach(info => {
            const stat = battingStats.get(info.id) || {};
            const row = {
                order: info.order,
                id: info.id,
                name: info.name,
                pos: info.pos,
                AB: stat.AB || 0,
                H: stat.H || 0,
                HR: stat.HR || 0,
                RBI: stat.RBI || 0,
                BB: stat.BB || 0,
                SO: stat.SO || 0,
                R: stat.R || 0
            };
            teamRecap.batting.push(row);
            const player = findPlayerById(tid, info.id);
            if(player){
                injuryCandidates.push({ player, tid });
                addWeekXP(player.id, 4);
                player.fatigue = clamp((player.fatigue || 0) + 10, 0, 100);
                player.morale = clamp((player.morale || 60) + (isWinner ? 2 : -1), 0, 100);
                initializePlayerStats(player.id);
                const log = { day: res.day, AB: row.AB, H: row.H, HR: row.HR, RBI: row.RBI, BB: row.BB, SO: row.SO, R: row.R };
                State.playerGameLogs[player.id].push(log);
                if(row.H >= 3 && rng() < 0.1) player.status.hot = Math.max(player.status.hot || 0, 2);
                if(row.AB > 3 && row.H === 0 && rng() < 0.08) player.status.slump = Math.max(player.status.slump || 0, 1);
                if(row.HR >= 3){
                    logHighlight('bomb', `【大爆発】${player.name}が1試合${row.HR}本塁打！`, highlightMeta);
                } else if(row.H >= 4){
                    logHighlight('swords', `【猛打賞】${player.name}が4安打の大暴れ！`, highlightMeta);
                }
            }
        });

        const timeline = detail.pitcherTimeline?.[side] || [];
        timeline.forEach((entry, idx) => {
            const stat = pitchingStats.get(entry.id) || {};
            const outs = stat.outs || 0;
            const ip = outs / 3;
            const ipDisplay = Math.floor(ip) + ((outs % 3) / 10);
            const row = {
                id: entry.id,
                name: entry.name,
                role: entry.role || (idx === 0 ? 'SP' : 'RP'),
                IP: ipDisplay,
                ER: stat.ER || 0,
                SO: stat.SO || 0,
                BB: stat.BB || 0,
                R: stat.R || 0,
                H: stat.H || 0,
                HR: stat.HR || 0,
                W: 0,
                L: 0,
                SV: 0
            };
            if(idx === 0 && isWinner && outs >= 15) row.W = 1;
            if(idx === 0 && !isWinner) row.L = 1;
            if(idx > 0 && isWinner && idx === timeline.length - 1 && margin <= 3) row.SV = 1;
            if(idx === 0) teamRecap.pitching.starter = row; else teamRecap.pitching.relievers.push(row);

            const player = findPlayerById(tid, entry.id);
            if(player){
                injuryCandidates.push({ player, tid });
                initializePlayerStats(player.id);
                const log = { day: res.day, IP: ipDisplay, ER: row.ER, SO: row.SO, BB: row.BB, H: row.H, HR: row.HR };
                if(idx === 0) log.GS = 1;
                if(row.W) log.W = row.W;
                if(row.L) log.L = row.L;
                if(row.SV) log.SV = row.SV;
                State.playerGameLogs[player.id].push(log);
                if(idx === 0){
                    addWeekXP(player.id, 4);
                    player.fatigue = clamp((player.fatigue || 0) + Math.max(8, Math.round((outs / 3) * 12)), 0, 100);
                    player.morale = clamp((player.morale || 60) + (isWinner ? 3 : -2), 0, 100);
                    const totalWins = (State.playerGameLogs[player.id] || []).reduce((sum, lg) => sum + (lg.W || 0), 0);
                    if(row.W === 1 && totalWins === 1 && player.age <= 22){
                        logHighlight('trophy', `【初勝利🎉】ルーキーの${player.name}投手がプロ初勝利！`, highlightMeta);
                    }
                    if(ipDisplay >= 9 && row.ER === 0){
                        logHighlight('shield-check', `【快挙】${player.name}が完封勝利を達成！`, highlightMeta);
                    }
                } else {
                    addWeekXP(player.id, 2);
                    player.fatigue = clamp((player.fatigue || 0) + Math.min(30, Math.round(outs * 4)), 0, 100);
                    player.morale = clamp((player.morale || 60) + (isWinner ? 1 : -1), 0, 100);
                }
            }
        });

        if(!teamRecap.pitching.starter){
            teamRecap.pitching.starter = { id: null, name: '-', role: 'SP', IP: 0, ER: 0, SO: 0, BB: 0, W: 0, L: 0 };
        }

        const topBat = [...teamRecap.batting]
            .filter(b => b.H > 0 || b.RBI > 0 || b.HR > 0)
            .sort((a,b)=>(b.RBI*3 + b.HR*4 + b.H*2) - (a.RBI*3 + a.HR*4 + a.H*2))[0];
        if(topBat){
            const parts=[];
            if(topBat.H>0) parts.push(`${topBat.H}安打`);
            if(topBat.HR>0) parts.push(`${topBat.HR}本塁打`);
            if(topBat.RBI>0) parts.push(`${topBat.RBI}打点`);
            teamRecap.highlights.push(`${topBat.name}が${parts.join('・')}`);
        }
        const starterHighlight = teamRecap.pitching.starter;
        if(starterHighlight && (starterHighlight.W || starterHighlight.IP >= 6)){
            const ipText = typeof starterHighlight.IP === 'number' ? starterHighlight.IP.toFixed(1) : starterHighlight.IP;
            teamRecap.highlights.push(`${starterHighlight.name}が${ipText}回${starterHighlight.ER}失点の力投`);
        }
        return teamRecap;
    };

    const homeTeamRecap = processTeam('home');
    const awayTeamRecap = processTeam('away');

    const seenInjury = new Set();
    const injuryPool = injuryCandidates.filter(entry=>entry && entry.player && !seenInjury.has(entry.player.id) && seenInjury.add(entry.player.id));
    injuryPool.forEach(entry => {
        const player = entry.player;
        const tid = entry.tid;
        if(player.injury) return;
        let injuryChance = 0.003 + (player.fatigue || 0) / 6000;
        const injuryEffects = getPlayerEffects(player, 'player:injury');
        if(injuryEffects.injuryResist != null) injuryChance *= injuryEffects.injuryResist;
        const support = getTeamSupportAdjustments(tid);
        injuryChance *= (support.staff.injuryRate ?? 1) * (support.facilities.injuryRate ?? 1);
        if(rng() < injuryChance){
            const roll = rng();
            let injury_type = INJURY_TYPES[0];
            let acc = 0;
            for(const type of INJURY_TYPES){
                acc += type.chance;
                if(roll < acc){ injury_type = type; break; }
            }
            const durationBase = injury_type.min + Math.floor(rng() * (injury_type.max - injury_type.min + 1));
            const durationMult = Math.max(0.3, (support.staff.injuryDuration ?? 1) * (support.facilities.injuryDuration ?? 1));
            const duration = Math.max(1, Math.round(durationBase * durationMult));
            player.injury = { type: injury_type.name, duration };
            logHighlight('siren', `【負傷離脱】${player.name}が${injury_type.name}で戦線離脱... (全治${duration}日)`, highlightMeta);
            moveSquad(tid, player.id, '二軍', { force:true });
        }
    });

    const keyMoments = detail.keyMoments || [];
    const momentHighlights = keyMoments.map(m => {
        const halfText = m.half === 'top' ? '表' : '裏';
        return `${m.inning}回${halfText} ${m.description}`;
    });

    recap.teams = { home: homeTeamRecap, away: awayTeamRecap };
    recap.keyMoments = keyMoments;
    recap.playLog = detail.events || [];
    recap.inningsLog = detail.innings || [];
    recap.pitcherTimeline = detail.pitcherTimeline || {};

    recap.highlights = [
        ...momentHighlights,
        ...homeTeamRecap.highlights.map(h => `${homeTeamRecap.team_name}: ${h}`),
        ...awayTeamRecap.highlights.map(h => `${awayTeamRecap.team_name}: ${h}`)
    ].filter(Boolean).slice(0, 12);

    const decidingMoment = [...keyMoments].reverse().find(m => m.side === winnerSide);
    const winnerRecap = winnerSide === 'home' ? homeTeamRecap : awayTeamRecap;
    if(decidingMoment){
        recap.decidingPlay = decidingMoment.description;
        if(decidingMoment.playerId) recap.decidingPlayerId = decidingMoment.playerId;
    } else {
        const fallback = winnerRecap.highlights[0] || (winnerRecap.batting[0]?.name ? `${winnerRecap.batting[0].name}が活躍` : null);
        if(fallback) recap.decidingPlay = fallback;
    }
    if(!recap.decidingPlayerId){
        const candidate = [...winnerRecap.batting]
            .filter(b => b.RBI > 0 || b.HR > 0 || b.H >= 2)
            .sort((a,b)=>(b.RBI*3 + b.HR*4 + b.H*1.5) - (a.RBI*3 + a.HR*4 + a.H*1.5))[0];
        if(candidate) recap.decidingPlayerId = candidate.id;
    }

    State.gameRecaps[key] = recap;

    if(keyMoments.length){
        const finalMoment = keyMoments[keyMoments.length-1];
        const scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
        logHighlight('clapperboard', `${scoreText} ${finalMoment.description}`, highlightMeta);
    }

    const storedKeys = Object.keys(State.gameRecaps);
    if (storedKeys.length > 600) {
        const sorted = storedKeys.sort((a,b)=>{
            const pa = parseGameRecapKey(a);
            const pb = parseGameRecapKey(b);
            return (pa?.day||0) - (pb?.day||0);
        });
        while (sorted.length > 600) {
            const oldest = sorted.shift();
            if (oldest && oldest !== key) delete State.gameRecaps[oldest];
        }
    }
    return true;
}

function allocateGameStats(res) {
    const isGameDay = State.schedule.some(evt=>evt.day===res.day && (evt?.type||'game')==='game');
    if(!isGameDay) return;
    const rng = mulberry32(res.day * 101 + res.home_id * 17 + res.away_id);
    const key = gameRecapKey(res.day, res.home_id, res.away_id);
    const highlightMeta = { gameKey: key, day: res.day, home_id: res.home_id, away_id: res.away_id };
    if(res.detailed){
        const handled = allocateGameStatsDetailed(res, res.detailed, rng, key, highlightMeta);
        if(handled) return;
    }
    const recap = {
        gameKey: key,
        season: State.season,
        day: res.day,
        home_id: res.home_id,
        away_id: res.away_id,
        innings: res.innings || 9,
        score: { home: res.home_runs, away: res.away_runs },
        winner_id: res.winner_id,
        highlights: [],
        teams: {}
    };

    const processTeam = (team_id, runs, opp_runs, isWinner) => {
        const lineup = pickDayLineup(team_id, res.day);
        const teamRecap = {
            team_id,
            team_name: id2name(team_id),
            runs,
            batting: [],
            pitching: { starter: null, relievers: [] },
            highlights: []
        };
        if (!lineup.bats.length || !lineup.sp) return teamRecap;

        const allPlaying = [...lineup.bats, lineup.sp, ...lineup.rps];
        allPlaying.forEach(player => {
            if(player.injury) return;
            let injury_chance = 0.003 + (player.fatigue / 6000);
            const injuryEffects = getPlayerEffects(player, 'player:injury');
            if(injuryEffects.injuryResist != null) injury_chance *= injuryEffects.injuryResist;
            const support = getTeamSupportAdjustments(tid);
            injury_chance *= (support.staff.injuryRate ?? 1) * (support.facilities.injuryRate ?? 1);
            if(rng() < injury_chance){
                const r = rng();
                let injury_type = INJURY_TYPES[0];
                let accumulated_chance = 0;
                for(const type of INJURY_TYPES){
                    accumulated_chance += type.chance;
                    if(r < accumulated_chance){
                        injury_type = type;
                        break;
                    }
                }
                const duration = injury_type.min + Math.floor(rng() * (injury_type.max - injury_type.min + 1));
                player.injury = { type: injury_type.name, duration: duration };
                logHighlight('siren', `【負傷離脱】${player.name}が${injury_type.name}で戦線離脱... (全治${duration}日)`, highlightMeta);
                moveSquad(team_id, player.id, '二軍', { force:true });
            }
        });

        lineup.bats.forEach(batter => {
            addWeekXP(batter.id, 4);
            batter.fatigue = clamp((batter.fatigue || 0) + 10, 0, 100);
            batter.morale = clamp(batter.morale + (isWinner ? 2 : -1), 0, 100);
        });

        const sp = lineup.sp;
        const rps = lineup.rps;
        const spIPRaw = clamp(5 + (rng() * 4 - 2), 1, 7);
        const spIP = Math.round(spIPRaw * 10) / 10;
        const totalInnings = res.innings || 9;
        const rpIP = Math.max(0, totalInnings - spIPRaw);

        addWeekXP(sp.id, 4);
        sp.fatigue = clamp((sp.fatigue || 0) + 12 * spIPRaw, 0, 100);
        sp.morale = clamp(sp.morale + (isWinner ? 3 : -2), 0, 100);

        const numRelieversUsed = rpIP > 3 ? 3 : (rpIP > 0 ? 2 : 0);
        if (rpIP > 0 && rps.length > 0) {
             for (let i = 0; i < numRelieversUsed && i < rps.length; i++) {
                const p = rps[i];
                addWeekXP(p.id, 2);
                p.fatigue = clamp((p.fatigue || 0) + 25, 0, 100);
                p.morale = clamp(p.morale + (isWinner ? 1 : -1), 0, 100);
            }
        }

        const hits = Math.round(runs * (1.6 + rng() * 0.8) + (runs > 0 ? 1 : 0));
        const walks = Math.max(0, Math.round((hits / 3.5) + (rng() * 4 - 2)));
        const strikeouts = Math.max(0, Math.round(7 + (rng() * 6 - 3)));
        const batterLogs = new Map();
        let hits_by_player = {}, walks_by_player = {}, so_by_player = {};

        for (let i = 0; i < hits; i++) {
            const p = weightedRandom(lineup.bats, b => b.con, rng);
            hits_by_player[p.id] = (hits_by_player[p.id] || 0) + 1;
        }
        for (let i = 0; i < walks; i++) {
            const p = weightedRandom(lineup.bats, b => b.disc, rng);
            walks_by_player[p.id] = (walks_by_player[p.id] || 0) + 1;
        }
        for (let i = 0; i < strikeouts; i++) {
            const p = weightedRandom(lineup.bats, b => 105 - b.con, rng);
            so_by_player[p.id] = (so_by_player[p.id] || 0) + 1;
        }

        lineup.bats.forEach(b => {
            initializePlayerStats(b.id);
            const log = { day: res.day, H: hits_by_player[b.id] || 0, BB: walks_by_player[b.id] || 0, SO: so_by_player[b.id] || 0, AB: 4 + (rng() > 0.5 ? 1 : 0) };
            log.HR = Math.floor(log.H * (b.pwr / 700.0) * (0.8 + rng() * 0.4));
            log.RBI = Math.round((log.H * 0.5) + (log.HR * 1.5));
            batterLogs.set(b.id, log);
            State.playerGameLogs[b.id].push(log);

            if(log.H >= 3 && rng() < 0.1) { b.status.hot = Math.max(b.status.hot || 0, 2); }
            if(log.AB > 3 && log.H === 0 && rng() < 0.08) { b.status.slump = Math.max(b.status.slump || 0, 1); }
            if (log.HR >= 3) { logHighlight('bomb', `【大爆発】${b.name}が1試合3本塁打の大活躍！`, highlightMeta); }
            else if (log.H >= 4) { logHighlight('swords', `【猛打賞】${b.name}が4安打の大暴れ！`, highlightMeta); }
        });

        teamRecap.batting = lineup.bats.map((b, idx) => {
            const stats = batterLogs.get(b.id) || { AB:0, H:0, HR:0, RBI:0, BB:0, SO:0 };
            return {
                order: idx + 1,
                id: b.id,
                name: b.name,
                pos: b.pos || b.position || '-',
                AB: stats.AB,
                H: stats.H,
                HR: stats.HR,
                RBI: stats.RBI,
                BB: stats.BB,
                SO: stats.SO
            };
        });

        const sps = State.playerStats[sp.id] = State.playerStats[sp.id] || {};
        const spShare = spIPRaw / totalInnings;
        const spRunsAllowed = Math.round(opp_runs * spShare);
        const spLog = {
            day: res.day,
            GS: 1,
            IP: spIP,
            ER: Math.round(spRunsAllowed * 0.92),
            SO: Math.round(Math.max(0, 7 + (rng() * 6 - 3)) * spShare),
            BB: Math.round(Math.max(0, (Math.round(opp_runs * (1.6+rng()*0.8)*spShare) / 3.5) + (rng() * 4 - 2)) * spShare)
        };
        if (isWinner && spIPRaw >= 5) spLog.W=1; else if (!isWinner) spLog.L=1;
        initializePlayerStats(sp.id); State.playerGameLogs[sp.id].push(spLog);

        const totalWins = (State.playerGameLogs[sp.id] || []).reduce((sum, log) => sum + (log.W || 0), 0);
        if (spLog.W === 1 && totalWins === 1 && sp.age <= 22) { logHighlight('trophy', `【初勝利🎉】ルーキーの${sp.name}投手がプロ初勝利を挙げました！記念すべき日です。`, highlightMeta); }
        if (spLog.IP >= 9 && spLog.ER === 0) { logHighlight('shield-check', `【快挙】${sp.name}が完封勝利を達成しました！`, highlightMeta); }

        if (spIPRaw >= 6 && spLog.ER <= 1 && rng() < 0.12) { lineup.sp.status.hot = Math.max(lineup.sp.status.hot || 0, 1); }
        if (spIPRaw < 5 && spLog.ER >= 3 && rng() < 0.09) { lineup.sp.status.slump = Math.max(lineup.sp.status.slump || 0, 1); }

        teamRecap.pitching.starter = {
            id: sp.id,
            name: sp.name,
            IP: spLog.IP,
            ER: spLog.ER,
            SO: spLog.SO,
            BB: spLog.BB,
            W: spLog.W || 0,
            L: spLog.L || 0
        };

        if (rpIP > 0 && rps.length > 0) {
            rps.slice(0, numRelieversUsed).forEach((rp, i) => {
                const rpShare = (rpIP / Math.max(1, numRelieversUsed)) / totalInnings;
                const rpIPEach = Math.round((rpIP / Math.max(1, numRelieversUsed)) * 10) / 10;
                const rpLog = {
                    day: res.day,
                    IP: rpIPEach,
                    ER: Math.round(opp_runs * rpShare * 0.92),
                    SO: Math.max(0, Math.round((4 + rng() * 4 - 2) * rpShare * totalInnings)),
                    BB: Math.max(0, Math.round((2 + rng() * 3 - 1) * rpShare * totalInnings))
                };
                if (isWinner && (runs - opp_runs <= 3) && i === numRelieversUsed - 1) rpLog.SV=1;
                initializePlayerStats(rp.id); State.playerGameLogs[rp.id].push(rpLog);
                teamRecap.pitching.relievers.push({
                    id: rp.id,
                    name: rp.name,
                    IP: rpLog.IP,
                    ER: rpLog.ER,
                    SO: rpLog.SO,
                    BB: rpLog.BB,
                    SV: rpLog.SV || 0
                });
            });
        }

        const battingHighlight = [...teamRecap.batting]
            .filter(b => b.H > 0 || b.RBI > 0 || b.HR > 0)
            .sort((a,b)=> (b.RBI*3 + b.HR*4 + b.H*2) - (a.RBI*3 + a.HR*4 + a.H*2))[0];
        if (battingHighlight) {
            const detail = [`${battingHighlight.H}安打`];
            if (battingHighlight.HR > 0) detail.push(`${battingHighlight.HR}本塁打`);
            if (battingHighlight.RBI > 0) detail.push(`${battingHighlight.RBI}打点`);
            teamRecap.highlights.push(`${battingHighlight.name}が${detail.join('・')}`);
        }

        const starterHighlight = teamRecap.pitching.starter;
        if (starterHighlight && (starterHighlight.W || starterHighlight.IP >= 6)) {
            const parts = [`${starterHighlight.name} ${starterHighlight.IP.toFixed ? starterHighlight.IP.toFixed(1) : starterHighlight.IP}回`];
            parts.push(`${starterHighlight.ER}失点`);
            if (starterHighlight.W) parts.push('勝利投手');
            teamRecap.highlights.push(parts.join(' '));
        }

        return teamRecap;
    };

    const homeRecap = processTeam(res.home_id, res.home_runs, res.away_runs, res.winner_id === res.home_id);
    const awayRecap = processTeam(res.away_id, res.away_runs, res.home_runs, res.winner_id === res.away_id);
    recap.teams = { home: homeRecap, away: awayRecap };

    const scoreText = `${id2name(res.away_id)} ${res.away_runs} - ${id2name(res.home_id)} ${res.home_runs}`;
    recap.scoreText = scoreText;
    recap.highlights = [`${id2name(res.winner_id)}が${scoreText}で勝利`, ...(homeRecap?.highlights||[]), ...(awayRecap?.highlights||[])].filter(Boolean);

    const winnerRecap = res.winner_id === res.home_id ? homeRecap : awayRecap;
    if (winnerRecap) {
        const candidate = [...(winnerRecap.batting||[])]
            .filter(b => b.RBI > 0 || b.HR > 0 || b.H >= 2)
            .sort((a,b)=> (b.RBI*3 + b.HR*4 + b.H*1.5) - (a.RBI*3 + a.HR*4 + a.H*1.5))[0];
        if (candidate) {
            const details = [];
            if (candidate.H > 0) details.push(`${candidate.H}安打`);
            if (candidate.HR > 0) details.push(`${candidate.HR}本塁打`);
            if (candidate.RBI > 0) details.push(`${candidate.RBI}打点`);
            recap.decidingPlay = `${candidate.name}の${details.join('・')}`;
            recap.decidingPlayerId = candidate.id;
        } else if (winnerRecap.pitching?.starter) {
            const p = winnerRecap.pitching.starter;
            recap.decidingPlay = `${p.name}が${(p.IP.toFixed ? p.IP.toFixed(1) : p.IP)}回${p.ER}失点の力投`;
            recap.decidingPlayerId = p.id;
        } else {
            recap.decidingPlay = `${winnerRecap.team_name}が${res.home_runs}-${res.away_runs}で勝利`;
        }
    }

    State.gameRecaps[key] = recap;
    const storedKeys = Object.keys(State.gameRecaps);
    if (storedKeys.length > 600) {
        const sorted = storedKeys.sort((a,b)=>{
            const pa = parseGameRecapKey(a);
            const pb = parseGameRecapKey(b);
            return (pa?.day||0) - (pb?.day||0);
        });
        while (sorted.length > 600) {
            const oldest = sorted.shift();
            if (oldest && oldest !== key) delete State.gameRecaps[oldest];
        }
    }
}

// ====== UI Renderers ======
function id2name(id){return State.teams.find(t=>t.team_id===id)?.team??`Team ${id}`}
const scheduleView = createScheduleView({
  describeStage,
  getCalendarEntry: day => getCalendarEntry(day),
  maxDay: () => maxDay(),
  id2name,
  querySelector: $,
  createElement: el,
  selectors: {
    seasonLabel: '#seasonLabel',
    dayLabel: '#dayLabel',
    gamesLabel: '#gamesLabel',
    container: '#todayMatchups'
  }
});
const draftView = createDraftView({
  createElement: el,
  getState: () => State,
  ensureDraft,
  ensureTeamMeta,
  ensureTeamNeedsAll,
  ensureProspectStructure,
  id2name,
  generateDraftClass: () => {
    const order = draftOrderFromStandings();
    const prospects = generateProspects();
    initializeDraftState(State, { order, prospects, rounds: 5, year: State.season || 1 });
    State.devLogs.push(`ドラフトクラス生成: 候補者${State.draft.pool?.length || 0}名`);
    saveAndRerender();
  },
  scouting: {
    SCOUT_ASSIGN_COST,
    assignmentLimit: scoutingAssignmentLimit,
    progressDisplay: (prospect, tid) => scoutingProgressDisplay(prospect, tid),
    statCell: (prospect, attr, tid) => scoutedStatTd(prospect, attr, tid),
    growthCurveSVG: (type) => createGrowthCurveSVG(type),
    showReport: (prospect, tid) => showScoutReportModal(prospect, tid),
    toggleAssignment: (tid, prospect) => toggleScoutAssignment(tid, prospect),
    evaluateScouted: (prospect, tid) => evaluateScoutedProspect(prospect, tid),
  },
  actions: {
    submitBid: (teamId, prospectId) => submitDraftBid(State, teamId, prospectId),
    selectProspect: (teamId, prospectId) => {
      const result = selectDraftProspect(State, teamId, prospectId, { onLog: handleDraftEvent });
      if (result) {
        completeDraftSelection(teamId, result);
      }
      return result;
    },
    shouldResolveFirstRound: () => shouldResolveDraftFirstRound(State),
    processFirstRoundResolution: () => processFirstRoundResolution(),
    checkDraftCompletion: () => checkDraftCompletion(),
    getPendingTeams: () => getDraftPendingTeams(State),
    getOnClockTeam: () => getDraftOnClockTeamId(State),
    isDraftComplete: () => isDraftComplete(State),
    autoUntilUser: (tid) => autoUntilUserTurn(tid),
    autoDraftStep: (stopTid) => autoDraftStep(stopTid),
    saveAndRerender: () => saveAndRerender(),
    saveState: () => save(),
  },
  qa: {
    evaluateProspectForTeam: (prospect, tid) => evaluateProspectForTeam(prospect, tid),
    getNextDraftActor: () => getNextDraftActor(),
  },
  refreshIcons,
});
const contractsView = createContractsView({
  createElement: el,
  evaluateOffer: evaluateNegotiation,
  valuePlayerContract,
  normalizeContractTerms,
  ensurePlayerPersona,
  ensurePlayerContract,
  normalizeContract,
  upsertFinanceContract,
  updateFinancialSnapshots,
  logHighlight,
  getOverall,
  onStateChange: saveAndRerender,
  recomputeAllRatingsAll,
  processFreeAgentSigning,
  millionFormatter,
  refreshIcons,
});
const faView = createFAView({
  createElement: el,
  ensureFreeAgencyState,
  determineFreeAgencyEligibility,
  rankFreeAgent,
  getOverall,
  millionFormatter,
  onStateChange: saveAndRerender,
  refreshIcons,
});
const staffView = createStaffView({
  createElement: el,
  getState: () => State,
  ensureTeamFinances,
  ensureTeamMeta,
  updateFinancialSnapshots,
  id2name,
  millionFormatter,
  staffCosts: STAFF_COSTS,
  logHighlight,
  actions: {
    saveAndRerender: () => saveAndRerender(),
    canControlTeam,
    showToast,
  },
  refreshIcons,
});
const financeView = createFinanceView({
  createElement: el,
  getState: () => State,
  ensureTeamFinances,
  ensureTeamFans: (state, tid) => ensureTeamFansState(state, tid),
  ensureSponsorDeals: (state, tid) => ensureSponsorDealsState(state, tid),
  millionFormatter,
  yenFormatter,
  createSparklineWithTooltip,
  createSparklineSVG,
  computeAttendanceForGame: (_state, result) => estimateGameAttendance(result.home_id, result.away_id),
  refreshIcons,
});
const facilitiesView = createFacilitiesView({
  createElement: el,
  getState: () => State,
  ensureTeamMeta,
  ensureTeamFacilities,
  updateTeamFacilities,
  computeFacilityAdjustments,
  id2name,
  actions: {
    saveAndRerender: () => saveAndRerender(),
    canControlTeam,
    showToast,
  },
  refreshIcons,
});
function canControlTeam(tid){ return !!State.commissioner || tid === (State.userTeamId??0); }

function logHighlight(icon, text, meta={}) {
    if (!State.highlights) State.highlights = [];
    const entryDay = meta.day ?? State.curr_day;
    const entry = { season: State.season, day: entryDay, icon, text };
    if (meta.gameKey) {
        entry.gameKey = meta.gameKey;
    } else if (meta.day != null && meta.home_id != null && meta.away_id != null) {
        entry.gameKey = gameRecapKey(meta.day, meta.home_id, meta.away_id);
    }
    if (meta.category) entry.category = meta.category;
    if (meta.tag) entry.tag = meta.tag;
    if (meta.financeType) entry.financeType = meta.financeType;
    if (meta.tid != null) entry.team_id = meta.tid;
    State.highlights.push(entry);
}

function renderUserControls(){
  const selU = document.querySelector('#selUserTeam');
  if(selU){ if(selU.options.length===0){ teamOptions(selU); }
    selU.value = String(State.userTeamId??0);
    selU.onchange = ()=>{ State.userTeamId = parseInt(selU.value)||0; saveAndRerender(); };
  }
  const mode = document.querySelector('#modeSelect');
  if(mode){ mode.value = State.commissioner? 'comm':'user';
    mode.onchange = ()=>{ State.commissioner = (mode.value==='comm'); saveAndRerender(); };
  }
}

function renderSeasonSettings(){
  ensureNarrativeState();
  const freqSelect = document.querySelector('#eventFrequency');
  if(freqSelect){
    const freq = State.narrativeSettings?.frequency || 'standard';
    if(freqSelect.value !== freq) freqSelect.value = freq;
    freqSelect.onchange = () => {
      ensureNarrativeState();
      State.narrativeSettings.frequency = freqSelect.value;
      save();
    };
  }
  const themeSelect = document.querySelector('#eventTheme');
  if(themeSelect){
    const theme = State.narrativeSettings?.theme || 'balanced';
    if(themeSelect.value !== theme) themeSelect.value = theme;
    themeSelect.onchange = () => {
      ensureNarrativeState();
      State.narrativeSettings.theme = themeSelect.value;
      save();
    };
  }
}

function renderTeamNarrativePanel(tid){
  ensureNarrativeState();
  const narrative=State.teamNarratives?.[tid];
  if(!narrative) return null;
  const moralePoints=(narrative.morale||[]).slice(-20);
  const recentEvents=(narrative.events||[]).slice(-4).reverse();
  if(!moralePoints.length && !recentEvents.length) return null;

  const panel=el('div',{class:'management-narrative-panel'});
  const header=el('div',{class:'management-narrative-header'},
    el('div',{style:'display:flex;align-items:center;gap:8px;'},
      el('i',{ 'data-lucide':'drama', class:'mini-icon' }),
      el('strong',{}, `${id2name(tid)} 士気ダッシュボード`)
    ),
    (()=>{
      const btn=el('button',{class:'ghost', type:'button'}, el('i',{ 'data-lucide':'notebook-text', class:'mini-icon' }), '履歴');
      btn.onclick=()=>showNarrativeLogModal(tid);
      return btn;
    })()
  );
  panel.append(header);

  const grid=el('div',{class:'management-narrative-grid'});

  const timelineCard=el('div',{class:'narrative-subcard'});
  timelineCard.append(el('h4',{}, el('i',{ 'data-lucide':'activity', class:'mini-icon' }), 'チーム士気トレンド'));
  if(moralePoints.length>=2){
    const values=moralePoints.map(p=>p.value);
    const latest=values[values.length-1];
    const avg=Math.round(values.reduce((a,b)=>a+b,0)/values.length);
    const timelineRow=el('div',{class:'morale-timeline'});
    timelineRow.append(el('span',{},`最新 ${latest}`));
    timelineRow.append(createSparklineSVG(values, 'var(--accent)', 140, 28));
    timelineRow.append(el('span',{},`平均 ${avg}`));
    timelineCard.append(timelineRow);
    const meta=moralePoints[moralePoints.length-1];
    timelineCard.append(el('p',{class:'mini', style:'margin:0;color:var(--text-secondary);'}, `${meta.season}年目 Day ${meta.day}`));
  } else if(moralePoints.length===1){
    const point=moralePoints[0];
    timelineCard.append(el('div',{class:'morale-timeline'},
      el('span',{},`現在値 ${point.value}`)
    ));
    timelineCard.append(el('p',{class:'mini', style:'margin:0;color:var(--text-secondary);'}, `${point.season}年目 Day ${point.day}`));
  } else {
    timelineCard.append(el('div',{class:'narrative-log-empty'},'士気データがまだありません。'));
  }
  grid.append(timelineCard);

  const logCard=el('div',{class:'narrative-subcard'});
  logCard.append(el('h4',{}, el('i',{ 'data-lucide':'sparkles', class:'mini-icon' }), '直近イベント'));
  if(recentEvents.length){
    const list=el('ul',{class:'narrative-log-list'});
    recentEvents.forEach(evt=>{
      const item=el('li',{class:'narrative-log-item'});
      item.append(el('span',{class:'narrative-tag'}, evt.tag || 'NARRATIVE'));
      const summary=evt.summary || evt.title || '';
      if(summary) item.append(document.createTextNode(` ${summary}`));
      item.append(el('div',{class:'mini'}, `${evt.season}年目 Day ${evt.day}`));
      list.append(item);
    });
    logCard.append(list);
  } else {
    logCard.append(el('div',{class:'narrative-log-empty'},'最近のイベントはありません。'));
  }
  grid.append(logCard);

  panel.append(grid);
  return panel;
}
function teamOptions(sel){ sel.innerHTML=""; State.teams.forEach(t=> sel.append(el("option",{value:t.team_id},t.team))); }
function statTd(val){ const tier=val>=90?"s":val>=80?"a":val>=70?"b":val>=60?"c":val>=50?"d":"f"; return el("td",{}, el("span",{class:`stat stat-${tier}`},val)); }

function ensureProspectStructure(prospect){
  if(!prospect) return prospect;
  if(!prospect.trueRatings){
    if(prospect.type==='BAT'){
      prospect.trueRatings={
        con: prospect.con??60,
        disc: prospect.disc??60,
        pwr: prospect.pwr??60,
        spd: prospect.spd??60,
        fld: prospect.fld??60,
        pot: prospect.pot??70
      };
    } else {
      prospect.trueRatings={
        velo: prospect.velo??60,
        ctrl: prospect.ctrl??60,
        mov: prospect.mov??60,
        stam: prospect.stam??60,
        pot: prospect.pot??70
      };
    }
  }
  if(typeof prospect.isForeign !== 'boolean') prospect.isForeign = Boolean(prospect.isForeign);
  if(!prospect.origin) prospect.origin = prospect.isForeign ? 'international' : 'domestic';
  const age=Number.isFinite(prospect.age)?prospect.age:20;
  if(!Number.isFinite(prospect.age)) prospect.age=age;
  const level=resolveProspectLevel(prospect);
  prospect.level=level;
  if(!prospect.ageBand){ prospect.ageBand = age<=19?'18-19歳':age<=21?'20-21歳':age<=24?'22-24歳':age<=27?'25-27歳':'28歳以上'; }
  if(!prospect.scouting){
    const seedBase = hashString(prospect.pid||prospect.name||`${Math.random()}`);
    const rng = mulberry32(seedBase>>>0);
    prospect.scouting=createScoutingProfile(prospect.trueRatings, prospect.type, level, rng);
  }
  prospect.scouting.baseGrades = prospect.scouting.baseGrades||{};
  prospect.scouting.errors = prospect.scouting.errors||{};
  prospect.scouting.hiddenAttrs = prospect.scouting.hiddenAttrs||{};
  prospect.scouting.revealThreshold = prospect.scouting.revealThreshold||{};
  prospect.scouting.teams = prospect.scouting.teams||{};
  prospect.scouting.events = prospect.scouting.events || generateProspectEvents(prospect.type, prospect.trueRatings, mulberry32((hashString((prospect.pid||'')+':events'))>>>0));
  if(!prospect.pos){ if(prospect.type==='PIT'){ const role=(prospect.role||'RP').toUpperCase(); prospect.pos=role==='SP'?'SP':'RP'; } else { prospect.pos='IF'; } }
  if(!prospect.potRange || !Number.isFinite(prospect.potRange.min) || !Number.isFinite(prospect.potRange.max)){ const pot=prospect.trueRatings?.pot??70; const spread=6; prospect.potRange={ min: clamp(pot-spread-1,20,99), max: clamp(pot+spread+2,20,99) }; } else { prospect.potRange={ min: clamp(prospect.potRange.min,20,99), max: clamp(prospect.potRange.max,20,99) }; }
  if(typeof prospect.riskInjury!=='number'){ const seed=hashString((prospect.pid||prospect.name||'risk')+':risk'); const rng=mulberry32(seed>>>0); const base=prospect.type==='PIT'?52:45; const val=Math.round(base + (age-19)*(prospect.type==='PIT'?1.6:1.2) + (rng()*18-9)); prospect.riskInjury=clamp(val,10,95); } else { prospect.riskInjury=clamp(Math.round(prospect.riskInjury),0,100); }
  if(typeof prospect.signWillingness!=='number'){ const seed=hashString((prospect.pid||prospect.name||'sign')+':sign'); const rng=mulberry32(seed>>>0); const baseMap={高校:62,大学:68,社会人:64,独立リーグ:58,海外:66}; const base=baseMap[prospect.level]??63; prospect.signWillingness=clamp(Math.round(base + (rng()*22-11)),25,95); } else { prospect.signWillingness=clamp(Math.round(prospect.signWillingness),0,100); }
  return prospect;
}

function ensureProspectTeamReport(prospect, tid){
  ensureProspectStructure(prospect);
  const teams=prospect.scouting.teams;
  if(!teams[tid]){ teams[tid]={ progress:0, lastUpdate:null }; }
  if(typeof teams[tid].progress!=='number'){ teams[tid].progress=0; }
  return teams[tid];
}

function getProspectAttributeList(prospect){
  if(prospect.type==='BAT') return ['con','disc','pwr','spd','fld','pot'];
  return ['velo','ctrl','mov','stam','pot'];
}

function prospectAttributeLabel(prospect, attr){
  if(prospect.type==='BAT'){
    const map={con:'ミート',disc:'選球眼',pwr:'パワー',spd:'走力',fld:'守備',pot:'潜在'};
    return map[attr]||attr;
  }
  const map={velo:'球速',ctrl:'制球',mov:'変化',stam:'体力',pot:'潜在'};
  return map[attr]||attr;
}

function scoutedDisplayData(prospect, attr, tid){
  ensureProspectStructure(prospect);
  const trueRatings=prospect.trueRatings||{};
  const trueVal=trueRatings[attr];
  if(trueVal==null) return { known:false, value:null, margin:null, progress:0 };
  const baseGrades=prospect.scouting.baseGrades||{};
  const errors=prospect.scouting.errors||{};
  const baseVal=baseGrades[attr]??trueVal;
  const error=errors[attr]??(baseVal-trueVal);
  const report=tid!=null?ensureProspectTeamReport(prospect, tid):{progress:0};
  const progress=clamp(report.progress||0,0,1);
  const revealThreshold=prospect.scouting.revealThreshold?.[attr]??0;
  const hidden=prospect.scouting.hiddenAttrs?.[attr]??false;
  const known=!hidden || progress>=revealThreshold;
  const value=Math.round(clamp(trueVal + error*(1-progress),20,99));
  const margin=known?Math.max(0, Math.round(Math.abs(error)*(1-progress))):null;
  return { known, value, margin, progress };
}

function scoutedStatTd(prospect, attr, tid){
  const data=scoutedDisplayData(prospect, attr, tid);
  if(!data.known){ return el('td',{class:'scout-unknown'}, el('span',{},'??')); }
  const tier=data.value>=90?'s':data.value>=80?'a':data.value>=70?'b':data.value>=60?'c':data.value>=50?'d':'f';
  const span=el('span',{class:`stat stat-${tier}`});
  span.textContent=data.value;
  if(data.margin && data.margin>0){ span.append(el('span',{class:'margin'},`±${data.margin}`)); }
  return el('td',{}, span);
}

function scoutingProgressDisplay(prospect, tid){
  const report=ensureProspectTeamReport(prospect, tid);
  const percent=Math.round(clamp(report.progress||0,0,1)*100);
  const bar=el('div',{class:'scout-progress'}, el('span',{style:`width:${percent}%`}));
  const label=el('div',{class:'scout-progress-label'}, `${percent}%`);
  return el('div',{style:'display:flex;flex-direction:column;align-items:flex-end;gap:4px;'}, bar, label);
}

function evaluateScoutedProspect(prospect, tid){
  ensureProspectStructure(prospect);
  const attrs=prospect.type==='BAT'
    ? [['pot',1.1],['pwr',0.4],['con',0.4],['spd',0.2]]
    : [['pot',1.1],['velo',0.35],['mov',0.35],['ctrl',0.25]];
  let score=0;
  attrs.forEach(([attr,weight])=>{
    const data=scoutedDisplayData(prospect, attr, tid);
    const value=data.known?data.value: (prospect.scouting.baseGrades?.[attr]??60);
    score+=value*weight;
  });
  if(prospect.type!=='BAT' && prospect.role==='SP'){ score+=5; }
  if(tid!=null){
    ensureTeamNeedsAll();
    const team=State.teams?.find(t=>t.team_id===tid);
    if(team){
      const bucket=prospectNeedBucket(prospect);
      const need=clamp((team.needs?.[bucket])??0,0,1.5);
      score*=1+need*0.4;
    }
  }
  if(prospect.potRange){ const range=prospect.potRange; score+=clamp((range.max-range.min),0,25)*0.08; }
  if(typeof prospect.signWillingness==='number'){ score*=1+clamp((prospect.signWillingness-60)/230,-0.2,0.3); }
  if(typeof prospect.riskInjury==='number'){ score*=1-clamp((prospect.riskInjury-50)/230,-0.25,0.25); }
  return score;
}

function createSparklineSVG(data, color, width=40, height=16, ghostData = null) {
    if (!data || data.length < 2) return el('div');
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.style.overflow = 'visible';
    
    const allData = ghostData ? [...data, ...ghostData] : data;
    const maxVal = Math.max(...allData);
    const minVal = Math.min(...allData);
    const range = maxVal - minVal === 0 ? 1 : maxVal - minVal;

    function createPolyline(d, c, dash = false) {
        const points = d.map((val, i) => {
            const x = (i / (d.length - 1)) * width;
            const y = height - ((val - minVal) / range) * (height - 2) - 1;
            return `${x.toFixed(2)},${y.toFixed(2)}`;
        }).join(' ');
        
        const polyline = document.createElementNS(svgNS, 'polyline');
        polyline.setAttribute('points', points);
        polyline.setAttribute('fill', 'none');
        polyline.setAttribute('stroke', c);
        polyline.setAttribute('stroke-width', '1.5');
        polyline.setAttribute('stroke-linecap', 'round');
        polyline.setAttribute('stroke-linejoin', 'round');
        if (dash) polyline.setAttribute('stroke-dasharray', '2,2');
        return polyline;
    }

    if(ghostData) svg.append(createPolyline(ghostData, 'rgba(150,150,180,0.5)', true));
    svg.append(createPolyline(data, color));
    
    return svg;
}

function createGrowthCurveSVG(type, width=40, height=16) {
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const curves = {
        prodigy:  [3, 2, 2, 1, 1],
        late:     [14, 13, 11, 7, 2],
        standard: [14, 11, 8, 5, 2],
        early:    [12, 6, 4, 3, 3],
        bust:     [15, 15, 14, 14, 14]
    };
    const data = curves[type] || curves['standard'];
    
    const points = data.map((d, i) => {
        const x = (i / (data.length - 1)) * width;
        const y = d;
        return `${x.toFixed(2)},${y.toFixed(2)}`;
    }).join(' ');
    
    const polyline = document.createElementNS(svgNS, 'polyline');
    polyline.setAttribute('points', points);
    polyline.setAttribute('fill', 'none');
    polyline.setAttribute('stroke', 'var(--primary)');
    polyline.setAttribute('stroke-width', '2');
    polyline.setAttribute('stroke-linecap', 'round');
    polyline.setAttribute('stroke-linejoin', 'round');

    svg.append(polyline);
    return svg;
}


function createRadarChartSVG(stats) {
    const svgNS = "http://www.w3.org/2000/svg";
    const size = 200;
    const center = size / 2;
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", size);
    svg.setAttribute("height", size);
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);

    const labels = Object.keys(stats);
    const values = Object.values(stats);
    const numAxes = labels.length;
    const angleSlice = (Math.PI * 2) / numAxes;

    function createSvgElement(tag, attrs) {
        const element = document.createElementNS(svgNS, tag);
        for (const [key, value] of Object.entries(attrs)) {
            element.setAttribute(key, value);
        }
        return element;
    }

    // Draw grid lines
    for (let i = 1; i <= 4; i++) {
        const radius = (center * 0.9) * (i / 4);
        let points = "";
        for (let j = 0; j < numAxes; j++) {
            const angle = angleSlice * j - Math.PI / 2;
            const x = center + radius * Math.cos(angle);
            const y = center + radius * Math.sin(angle);
            points += `${x},${y} `;
        }
        points += points.split(' ').slice(0, 2).join(' '); // close the polygon
        svg.append(createSvgElement("polygon", { points, fill: "none", stroke: "var(--border)", "stroke-width": "1" }));
    }

    // Draw axes and labels
    for (let i = 0; i < numAxes; i++) {
        const angle = angleSlice * i - Math.PI / 2;
        const radius = center * 0.95;
        const x1 = center;
        const y1 = center;
        const x2 = center + radius * Math.cos(angle);
        const y2 = center + radius * Math.sin(angle);
        svg.append(createSvgElement("line", { x1, y1, x2, y2, stroke: "var(--border)", "stroke-width": "1" }));

        // Labels
        const labelX = center + (center * 1.08) * Math.cos(angle);
        const labelY = center + (center * 1.08) * Math.sin(angle);
        const labelEl = createSvgElement("text", { x: labelX, y: labelY, "font-size": "10px", fill: "var(--text-secondary)", "text-anchor": "middle", "dominant-baseline": "middle" });
        labelEl.textContent = labels[i];
        svg.append(labelEl);
    }

    // Draw data polygon
    let dataPoints = "";
    for (let i = 0; i < numAxes; i++) {
        const value = Math.max(0, values[i] / 100); // Normalize to 0-1, ensure non-negative
        const radius = (center * 0.9) * value;
        const angle = angleSlice * i - Math.PI / 2;
        const x = center + radius * Math.cos(angle);
        const y = center + radius * Math.sin(angle);
        dataPoints += `${x},${y} `;
    }
    dataPoints += dataPoints.split(' ').slice(0, 2).join(' ');
    svg.append(createSvgElement("polygon", { points: dataPoints, fill: "rgba(255, 71, 126, 0.5)", stroke: "var(--accent)", "stroke-width": "2" }));

    return svg;
}


function showPlayerDetailModal(pid, tid) {
    const player = findPlayerById(tid, pid);
    if (!player) return;

    playSound('A#4', '16n');

    const modal = $('#playerDetailModal');
    $('#modalPlayerName').textContent = `${player.name} (${player.age}歳)`;
    const body = $('#modalBody');
    body.innerHTML = ''; // Clear previous content

    const statsContainer = el('div');
    const isPitcher = !!player.velo;

    // Basic Info
    statsContainer.append(el('p', { class: 'mini' }, `守:${player.pos || player.role} / 投:${player.hand}`));

    // Status
    let statusText = '';
    if (player.injury) statusText = `🩹 怪我: ${player.injury.type} (あと${player.injury.duration}日)`;
    else if (player.status?.hot > 0) statusText = `🔥 好調 (あと${player.status.hot}週)`;
    else if (player.status?.slump > 0) statusText = `❄️ 不調 (あと${player.status.slump}週)`;

    if(statusText){
        statsContainer.append(el('div', { class: 'pill', style: `margin-bottom:12px; background-color: ${player.injury ? 'var(--bad)' : 'var(--warn)'}; color: #fff; border-color: transparent;` }, statusText));
    }


    // Stats Table
    const statsTable = el('table', { style: 'margin-bottom: 16px;' });
    const tbody = el('tbody');

    if (isPitcher) {
        tbody.append(
            el('tr', {}, el('td', {}, '速球'), statTd(player.velo)),
            el('tr', {}, el('td', {}, '制球'), statTd(player.ctrl)),
            el('tr', {}, el('td', {}, '変化'), statTd(player.mov)),
            el('tr', {}, el('td', {}, '体力'), statTd(player.stam))
        );
    } else {
        tbody.append(
            el('tr', {}, el('td', {}, 'ミート'), statTd(player.con)),
            el('tr', {}, el('td', {}, '選球眼'), statTd(player.disc)),
            el('tr', {}, el('td', {}, 'パワー'), statTd(player.pwr)),
            el('tr', {}, el('td', {}, '走力'), statTd(player.spd)),
            el('tr', {}, el('td', {}, '守備力'), statTd(player.fld))
        );
    }
    tbody.append(el('tr', {}, el('td', {}, 'ポテンシャル'), statTd(player.pot)));
    statsTable.append(tbody);
    statsContainer.append(statsTable);

    if (Number.isFinite(player.farmReveal)) {
        const revealPct = clamp(Math.round(player.farmReveal), 0, 100);
        const farmBlock = el('div', { class: 'training-progress-block', style: 'margin-bottom: 16px;' });
        farmBlock.append(
            el('div', { class: 'training-progress-header' },
                el('span', {}, '二軍育成状況'),
                el('span', {}, `${revealPct}%`)
            )
        );
        const bar = el('div', { class: 'training-progress-bar' });
        bar.append(el('span', { style: `width:${revealPct}%` }));
        farmBlock.append(bar);

        const last = player.farmLast || null;
        const meta = el('div', { class: 'training-progress-meta' });
        if (last?.label) meta.append(el('span', {}, last.label));
        if (last?.revealGain) meta.append(el('span', {}, `潜在+${last.revealGain}%`));
        if (last?.fatigueRecovered) meta.append(el('span', {}, `疲労-${last.fatigueRecovered}`));
        if (Array.isArray(last?.traitUnlocks) && last.traitUnlocks.length) meta.append(el('span', {}, `覚醒:${last.traitUnlocks.join('・')}`));
        if (meta.childNodes.length) farmBlock.append(meta);

        if (Array.isArray(player.farmLog) && player.farmLog.length) {
            const logList = el('ul', { class: 'farm-log' });
            player.farmLog.slice().reverse().forEach(entry => {
                const label = entry.label || '二軍';
                const detailParts = [];
                if (entry.revealGain) detailParts.push(`潜在+${entry.revealGain}% → ${Math.round(entry.revealAfter || 0)}%`);
                else detailParts.push(`潜在${Math.round(entry.revealAfter || 0)}%`);
                if (entry.fatigueRecovered) detailParts.push(`疲労-${entry.fatigueRecovered}`);
                if (Array.isArray(entry.traitUnlocks) && entry.traitUnlocks.length) detailParts.push(`覚醒:${entry.traitUnlocks.join('・')}`);
                if (Array.isArray(entry.milestones) && entry.milestones.length) detailParts.push(`節目:${entry.milestones.join('% / ')}%`);
                const item = el('li');
                item.append(el('span', { class: 'farm-log-time' }, label));
                item.append(el('span', {}, detailParts.join(' / ')));
                logList.append(item);
            });
            farmBlock.append(logList);
        }

        statsContainer.append(farmBlock);
    }

    // Traits
    const displayTraits = normalizePlayerSpecials(player);
    if (displayTraits.length > 0) {
        statsContainer.append(el('h4', { class: 'mini', style: 'font-weight:bold;' }, '特能'));
        const traitsDiv = el('div', { style: 'display:flex; flex-wrap:wrap; gap:6px; margin-bottom: 16px;' });
        displayTraits.forEach(token => {
            const traitId = findSpecialId(token) || token;
            const special = getSpecialById(traitId);
            const label = special?.name || token;
            const attrs = { class: 'tag' };
            if (special?.desc) attrs.title = special.desc;
            traitsDiv.append(el('span', attrs, label));
        });
        statsContainer.append(traitsDiv);
    }

    // Morale & Fatigue
    statsContainer.append(moraleBar(player.morale || 60));
    statsContainer.append(fatigueBar(player.fatigue || 20));

    // Radar Chart
    const chartContainer = el('div');
    let chartStats = {};
    if (isPitcher) {
        chartStats = { "速球": player.velo, "制球": player.ctrl, "変化": player.mov, "体力": player.stam, "ポ": player.pot };
    } else {
        chartStats = { "ミート": player.con, "パワー": player.pwr, "走力": player.spd, "守備": player.fld, "選球": player.disc };
    }
    chartContainer.append(el('h4', { class: 'mini', style: 'text-align:center; font-weight:bold;' }, '能力チャート'));
    chartContainer.append(createRadarChartSVG(chartStats));


    body.append(statsContainer, chartContainer);

    modal.style.display = 'flex';
    refreshIcons();
}

function hidePlayerDetailModal() {
    $('#playerDetailModal').style.display = 'none';
    playSound('C3', '16n');
}

function createGameRecapSection(title, content, extraClass='') {
    const className = ['game-recap-section'];
    if (extraClass) className.push(extraClass);
    const section = el('div', { class: className.join(' ') });
    section.append(el('h4', {}, title));
    const body = el('div', { class: 'section-body' });
    if (Array.isArray(content)) content.forEach(node => body.append(node));
    else if (content) body.append(content);
    else body.append(el('div', { class: 'mini' }, '記録なし'));
    section.append(body);
    return section;
}

function buildBattingTable(teamRecap) {
    const rows = teamRecap?.batting || [];
    if (!rows.length) return el('div', { class: 'mini' }, '記録なし');
    const table = el('table', { class: 'game-recap-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, '順'),
            el('th', {}, '選手'),
            el('th', {}, 'Pos'),
            el('th', {}, 'AB'),
            el('th', {}, 'H'),
            el('th', {}, 'HR'),
            el('th', {}, 'RBI'),
            el('th', {}, 'BB'),
            el('th', {}, 'SO')
        )),
        el('tbody')
    );
    rows.forEach(b => {
        table.lastChild.append(el('tr', {},
            el('td', {}, b.order ?? '-'),
            el('td', { style: 'text-align:left;' }, b.name || '-'),
            el('td', {}, b.pos || '-'),
            el('td', {}, b.AB ?? 0),
            el('td', {}, b.H ?? 0),
            el('td', {}, b.HR ?? 0),
            el('td', {}, b.RBI ?? 0),
            el('td', {}, b.BB ?? 0),
            el('td', {}, b.SO ?? 0)
        ));
    });
    return table;
}

function buildPitchingTable(teamRecap) {
    const rows = [];
    if (teamRecap?.pitching?.starter) {
        const s = teamRecap.pitching.starter;
        rows.push({
            name: s.name,
            role: '先発',
            IP: s.IP,
            ER: s.ER,
            SO: s.SO,
            BB: s.BB,
            W: s.W,
            L: s.L,
            SV: 0
        });
    }
    (teamRecap?.pitching?.relievers || []).forEach(rp => {
        rows.push({
            name: rp.name,
            role: rp.SV ? '抑え' : '救援',
            IP: rp.IP,
            ER: rp.ER,
            SO: rp.SO,
            BB: rp.BB,
            W: rp.W || 0,
            L: rp.L || 0,
            SV: rp.SV || 0
        });
    });
    if (!rows.length) return el('div', { class: 'mini' }, '記録なし');
    const table = el('table', { class: 'game-recap-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, '投手'),
            el('th', {}, '役割'),
            el('th', {}, 'IP'),
            el('th', {}, 'ER'),
            el('th', {}, 'SO'),
            el('th', {}, 'BB'),
            el('th', {}, 'W'),
            el('th', {}, 'L'),
            el('th', {}, 'SV')
        )),
        el('tbody')
    );
    rows.forEach(p => {
        table.lastChild.append(el('tr', {},
            el('td', { style: 'text-align:left;' }, p.name || '-'),
            el('td', {}, p.role || '-'),
            el('td', {}, formatInnings(p.IP)),
            el('td', {}, p.ER ?? 0),
            el('td', {}, p.SO ?? 0),
            el('td', {}, p.BB ?? 0),
            el('td', {}, p.W ?? 0),
            el('td', {}, p.L ?? 0),
            el('td', {}, p.SV ?? 0)
        ));
    });
    return table;
}

function resolveGameRecap(ref){
    if(!ref) return { key:null, recap:null };
    let key=null;
    if(typeof ref === 'string') key = ref;
    else if(ref.gameKey) key = ref.gameKey;
    else if(ref.day!=null && ref.home_id!=null && ref.away_id!=null) key = gameRecapKey(ref.day, ref.home_id, ref.away_id);
    if(!key) return { key:null, recap:null };
    return { key, recap: State.gameRecaps?.[key] };
}

function showGameRecapModal(ref) {
    const modal = $('#gameRecapModal');
    const body = $('#gameRecapBody');
    const title = $('#gameRecapTitle');
    if (!modal || !body || !title) return;
    const { key, recap } = resolveGameRecap(ref);
    if (!recap) {
        alert('試合詳細データが見つかりませんでした。');
        return;
    }

    const halfLabel = half => half === 'top' ? '表' : half === 'bottom' ? '裏' : '';
    const buildTimelineBlock = (timeline, label) => {
        const block = el('div', { class: 'timeline-entry' });
        block.append(el('strong', {}, label));
        if (!Array.isArray(timeline) || !timeline.length) {
            block.append(el('span', { class: 'mini' }, '登板なし'));
            return block;
        }
        timeline.forEach(item => {
            const enterHalf = halfLabel(item?.entered?.half || 'top');
            const exitHalf = halfLabel(item?.exit?.half || 'end');
            const exitInning = item?.exit?.inning != null ? item.exit.inning : item?.entered?.inning;
            const outText = item?.outs != null ? `${(item.outs / 3).toFixed(1)}回` : '';
            const line = `${item.name} (${item.role || 'RP'}) - ${item?.entered?.inning || 1}回${enterHalf}〜${exitInning}${exitHalf} ${outText} ${item?.runs || 0}失点`;
            block.append(el('span', {}, line));
        });
        return block;
    };

    title.textContent = `${id2name(recap.away_id)} @ ${id2name(recap.home_id)}`;
    body.innerHTML = '';

    const header = el('div', { class: 'game-recap-header' },
        el('div', { class: 'scoreline' }, `${id2name(recap.away_id)} ${recap.score?.away ?? 0} - ${id2name(recap.home_id)} ${recap.score?.home ?? 0}`),
        el('div', { class: 'game-recap-meta' },
            el('span', {}, `${recap.season}年目`),
            el('span', {}, `Day ${recap.day}`),
            el('span', {}, `${recap.innings || 9} Innings`)
        )
    );
    body.append(header);

    if (recap.decidingPlay) {
        body.append(el('div', { class: 'game-recap-keyplay' }, `決勝点: ${recap.decidingPlay}`));
    }

    if (recap.highlights && recap.highlights.length) {
        const list = el('ul');
        recap.highlights.forEach(h => list.append(el('li', {}, h)));
        const section = createGameRecapSection('試合ハイライト', list, 'game-recap-highlights');
        body.append(section);
    }

    if (Array.isArray(recap.keyMoments) && recap.keyMoments.length) {
        const kmList = el('div', { class: 'key-moment-list' });
        recap.keyMoments.forEach(m => {
            const scoreText = m.score ? ` (${m.score.away}-${m.score.home})` : '';
            kmList.append(el('div', { class: 'key-moment-item' }, `${m.inning}回${halfLabel(m.half)} ${m.description}${scoreText}`));
        });
        body.append(createGameRecapSection('キーモーメント', kmList));
    }

    if (recap.pitcherTimeline) {
        const timelineWrap = el('div', { class: 'game-recap-timeline' });
        timelineWrap.append(buildTimelineBlock(recap.pitcherTimeline.away, `${id2name(recap.away_id)} 継投`));
        timelineWrap.append(buildTimelineBlock(recap.pitcherTimeline.home, `${id2name(recap.home_id)} 継投`));
        body.append(createGameRecapSection('継投タイムライン', timelineWrap));
    }

    if (Array.isArray(recap.playLog) && recap.playLog.length) {
        const highlightEvents = recap.playLog.filter(evt => (evt.runsScored || 0) > 0 || (evt.commentary && evt.commentary.length)).slice(-12);
        if (highlightEvents.length) {
            const playList = el('div', { class: 'play-log-list' });
            highlightEvents.forEach(evt => {
                const desc = evt.description || `${evt.batter?.name || ''} ${evt.result || ''}`;
                const scoreText = evt.scoreAfter ? ` (${evt.scoreAfter.away}-${evt.scoreAfter.home})` : '';
                const commentary = evt.commentary ? ` ｜ ${evt.commentary}` : '';
                playList.append(el('div', { class: 'play-log-item' }, `${evt.inning}回${halfLabel(evt.half)} ${desc}${scoreText}${commentary}`));
            });
            body.append(createGameRecapSection('得点プレー', playList));
        }
    }

    const grid = el('div', { class: 'game-recap-grid' });
    grid.append(
        createGameRecapSection(`${id2name(recap.away_id)} 打撃`, buildBattingTable(recap.teams?.away)),
        createGameRecapSection(`${id2name(recap.home_id)} 打撃`, buildBattingTable(recap.teams?.home)),
        createGameRecapSection(`${id2name(recap.away_id)} 投手`, buildPitchingTable(recap.teams?.away)),
        createGameRecapSection(`${id2name(recap.home_id)} 投手`, buildPitchingTable(recap.teams?.home))
    );
    body.append(grid);

    modal.style.display = 'flex';
    modal.dataset.gameKey = key;
    refreshIcons();
}

function showFinanceModal(config = {}) {
    const modal = $('#financeModal');
    const body = $('#financeModalBody');
    const title = $('#financeModalTitle');
    if (!modal || !body || !title) return;
    title.textContent = config.title || 'フロントオフィス操作';
    body.innerHTML = '';
    const content = typeof config.render === 'function' ? config.render(body) : config.content;
    if (content) body.append(content);
    modal.style.display = 'flex';
    refreshIcons();
}

function hideFinanceModal() {
    const modal = $('#financeModal');
    if (modal) modal.style.display = 'none';
}

const financeCloseBtn = $('#financeModalCloseBtn');
if (financeCloseBtn) financeCloseBtn.onclick = hideFinanceModal;

function buildFreeAgentRow(tid, player) {
    const overall = Math.round(getOverall(player));
    const expectation = valuePlayerContract(player, { overall: getOverall(player) });
    const row = el('tr');
    row.append(
        el('td', {}, player.name),
        el('td', {}, player.pos || player.role || '-'),
        el('td', {}, overall),
        el('td', {}, `${millionFormatter(expectation.AAV)}${expectation.incentives?.total ? ` (+${millionFormatter(expectation.incentives.total)})` : ''}`),
        (() => {
            const cell = el('td');
            const btn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'user-plus' }), '契約');
            btn.onclick = () => {
                const res = negotiateContract(tid, player.id, { AAV: expectation.AAV, incentives: expectation.incentives, years: expectation.years });
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    btn.textContent = '条件見直し';
                }
            };
            cell.append(btn);
            return cell;
        })()
    );
    return row;
}

function openFreeAgentModal(tid) {
    ensureFreeAgents();
    const candidates = State.freeAgents.slice().sort((a, b) => getOverall(b) - getOverall(a)).slice(0, 25);
    showFinanceModal({
        title: 'FA市場',
        render: () => {
            const container = el('div', { class: 'finance-section' });
            if (!candidates.length) {
                container.append(el('div', { class: 'mini' }, '現在獲得可能なFA選手はいません。'));
                return container;
            }
            const table = el('table', { class: 'contract-table' },
                el('thead', {}, el('tr', {},
                    el('th', {}, '選手'),
                    el('th', {}, '守備/役割'),
                    el('th', {}, '総合'),
                    el('th', {}, '想定AAV'),
                    el('th', {}, '操作')
                )),
                el('tbody')
            );
            candidates.forEach(player => table.lastChild.append(buildFreeAgentRow(tid, player)));
            container.append(el('div', { class: 'table-scroll', style: 'max-height:320px;' }, table));
            return container;
        }
    });
}

function openContractModal(tid, contract) {
    const player = findPlayerById(tid, contract.playerId) || State.freeAgents.find(p => p.id === contract.playerId);
    const expectation = player
        ? valuePlayerContract(player, { overall: getOverall(player) })
        : { AAV: contract.AAV || 12000000, years: contract.yearsRemaining || 1, incentives: contract.incentives || { total: 0 } };
    showFinanceModal({
        title: `${contract.name} 契約交渉`,
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const currentIncentives = contract.incentives?.total ? ` +${millionFormatter(contract.incentives.total)}` : '';
            container.append(el('div', { class: 'finance-stat' }, el('span', {}, '現行条件'), el('strong', {}, `${millionFormatter(contract.AAV || 0)}${currentIncentives} / ${contract.yearsRemaining ?? 1}年`)));
            const aavInput = el('input', { type: 'number', min: '5000000', step: '1000000', value: contract.AAV || expectation.AAV || 10000000 });
            const yearInput = el('input', { type: 'number', min: '1', max: '6', value: Math.max(1, contract.yearsRemaining ?? 1) });
            const feedback = el('div', { class: 'mini' });
            const controls = el('div', { class: 'finance-actions' },
                el('label', { class: 'finance-stat' }, el('span', {}, '提示AAV'), aavInput),
                el('label', { class: 'finance-stat' }, el('span', {}, '契約年数'), yearInput)
            );
            const submit = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'wallet' }), '提示を行う');
            submit.onclick = () => {
                const offer = {
                    AAV: parseInt(aavInput.value, 10) || expectation.AAV,
                    years: parseInt(yearInput.value, 10) || expectation.years,
                    incentives: expectation.incentives
                };
                const res = negotiateContract(tid, contract.playerId, offer);
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    const expect = res.expectation || {};
                    feedback.textContent = `提示が拒否されました。目安: ¥${yenFormatter.format(expect.AAV || expectation.AAV)} / ${expect.years || offer.years}年`;
                }
            };
            container.append(controls, submit, feedback);
            return container;
        }
    });
}

function tradeCandidates(teamId) {
    const roster = State.rosters[teamId];
    if (!roster) return [];
    const players = [...roster.bats, ...roster.pits];
    return players.sort((a, b) => getOverall(b) - getOverall(a)).slice(0, 20);
}

function populateTradeSelect(select, teamId) {
    select.innerHTML = '';
    tradeCandidates(teamId).forEach(player => {
        const label = `${player.name} (${player.pos || player.role || '-'} / ${Math.round(getOverall(player))})`;
        select.append(el('option', { value: player.id }, label));
    });
}

function openTradeModal(tid) {
    const otherTeams = State.teams.filter(t => t.team_id !== tid);
    if (!otherTeams.length) return;
    showFinanceModal({
        title: 'トレード提案',
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const partnerSelect = el('select');
            otherTeams.forEach(team => partnerSelect.append(el('option', { value: team.team_id }, team.team)));
            const userSelect = el('select', { multiple: true, size: 8, style: 'width:100%;' });
            const partnerPlayerSelect = el('select', { multiple: true, size: 8, style: 'width:100%;' });
            populateTradeSelect(userSelect, tid);
            populateTradeSelect(partnerPlayerSelect, parseInt(partnerSelect.value, 10));
            partnerSelect.onchange = () => populateTradeSelect(partnerPlayerSelect, parseInt(partnerSelect.value, 10));
            const cashInput = el('input', { type: 'number', min: '0', step: '10', value: '0', style: 'width:100%;' });
            const feedback = el('div', { class: 'mini' });
            const submit = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'handshake' }), '交渉する');
            submit.onclick = () => {
                const partnerTid = parseInt(partnerSelect.value, 10);
                const outgoing = Array.from(userSelect.selectedOptions).map(opt => opt.value);
                const incoming = Array.from(partnerPlayerSelect.selectedOptions).map(opt => opt.value);
                const cash = (parseInt(cashInput.value, 10) || 0) * 1000000;
                if (!outgoing.length && !incoming.length && cash === 0) {
                    feedback.textContent = '選手または金銭を選択してください。';
                    return;
                }
                const res = proposeTrade(tid, partnerTid, outgoing, incoming, { cash });
                if (res.success) {
                    hideFinanceModal();
                    saveAndRerender();
                } else {
                    feedback.textContent = `トレード失敗: ${res.reason || '条件が合いません'}`;
                }
            };
            container.append(
                el('label', { class: 'finance-stat' }, el('span', {}, '相手チーム'), partnerSelect),
                el('div', { class: 'finance-stat' }, el('span', {}, '放出候補'), userSelect),
                el('div', { class: 'finance-stat' }, el('span', {}, '獲得候補'), partnerPlayerSelect),
                el('label', { class: 'finance-stat' }, el('span', {}, '金銭 (百万円単位)'), cashInput),
                submit,
                feedback
            );
            return container;
        }
    });
}

function openLedgerModal(tid) {
    const finance = State.teamFinances[tid];
    showFinanceModal({
        title: `${id2name(tid)} 財務レポート`,
        render: () => {
            const container = el('div', { class: 'finance-section' });
            const ledger = finance?.ledger ? finance.ledger.slice(-40).reverse() : [];
            if (!ledger.length) {
                container.append(el('div', { class: 'mini' }, 'まだ財務取引履歴はありません。'));
                return container;
            }
            const list = el('ul', { style: 'list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px;' });
            ledger.forEach(entry => {
                const amount = entry.amount || 0;
                const label = entry.label || (entry.type === 'expense' ? '支出' : '収入');
                list.append(el('li', { class: 'finance-stat' }, el('span', {}, `Day ${entry.day}: ${label}`), el('strong', {}, millionFormatter(amount))));
            });
            container.append(list);
            return container;
        }
    });
}

function hideGameRecapModal() {
    const modal = $('#gameRecapModal');
    if (modal) {
        modal.style.display = 'none';
        delete modal.dataset.gameKey;
    }
}

function showRosterViolationModal(compliance){
  const modal=$('#rosterViolationModal');
  const body=$('#rosterViolationBody');
  const title=$('#rosterViolationModalTitle');
  if(!modal || !body || !title){
    alert('外国人枠超過のため進行できません。');
    return;
  }
  const teamName=id2name(compliance?.teamId ?? (State.userTeamId ?? 0));
  title.textContent=`${teamName} 登録制限アラート`;
  body.innerHTML='';

  const header=el('div',{class:'banner-header'}, el('i',{'data-lucide':'shield-alert',class:'mini-icon'}), `${compliance?.label || '外国人枠'}超過`);
  const summary=el('div',{class:'banner-body'},`現在 ${compliance?.foreignCount ?? 0}/${compliance?.limit ?? '—'} 枠（一軍登録 ${compliance?.activeCount ?? 0}名）`);
  const banner=el('div',{class:'roster-compliance-banner error'}, header, summary);

  if(Array.isArray(compliance?.foreignPlayers) && compliance.foreignPlayers.length){
    const list=el('ul');
    compliance.foreignPlayers.forEach(player=>{
      const role=player.type==='PIT'?'投手':'野手';
      list.append(el('li',{},`${player.name} (${role})`));
    });
    banner.append(list);
  }

  body.append(banner, el('p',{class:'mini'},'対象選手を二軍へ移すか、外国人選手の構成を見直してください。'));
  modal.style.display='flex';
  modal.dataset.teamId=String(compliance?.teamId ?? '');
  refreshIcons();
}

function hideRosterViolationModal(){
  const modal=$('#rosterViolationModal');
  if(modal) modal.style.display='none';
}

function showScoutReportModal(prospect, tid){
  ensureProspectStructure(prospect);
  const modal=$('#scoutReportModal');
  const body=$('#scoutReportBody');
  const title=$('#scoutReportTitle');
  if(!modal||!body||!title) return;
  const report=ensureProspectTeamReport(prospect, tid);
  const progressPercent=Math.round(clamp(report.progress||0,0,1)*100);
  const growthMap={prodigy:'怪物',late:'晩成',standard:'標準',early:'早熟',bust:'伸び悩み'};
  title.textContent=`${prospect.name} スカウトレポート`;
  body.innerHTML='';

  const overviewSection=el('div',{class:'scout-report-section'});
  overviewSection.append(el('h4',{},'基本情報'));
  const overviewBody=el('div',{class:'scout-report-body'});
  const infoLine=el('div',{class:'mini',style:'display:flex;flex-wrap:wrap;gap:8px;line-height:1.6;'});
  infoLine.append(
    el('span',{},`年齢: ${prospect.age}`),
    el('span',{},`利き手: ${prospect.hand||'-'}`),
    el('span',{}, prospect.type==='BAT'?`守備: ${prospect.pos}`:`役割: ${prospect.role}`),
    el('span',{},`成長: ${growthMap[prospect.growthCurve]||prospect.growthCurve}`)
  );
  const progressWrap=el('div',{style:'display:flex;flex-direction:column;gap:4px;'});
  progressWrap.append(el('div',{class:'scout-progress'}, el('span',{style:`width:${progressPercent}%`})));
  progressWrap.append(el('div',{class:'scout-progress-label',style:'text-align:left;'}, `進捗 ${progressPercent}%`));
  const attrTable=el('table',{}, el('tbody'));
  getProspectAttributeList(prospect).forEach(attr=>{
    const row=el('tr');
    row.append(el('td',{}, prospectAttributeLabel(prospect, attr)), scoutedStatTd(prospect, attr, tid));
    attrTable.lastChild.append(row);
  });
  overviewBody.append(infoLine, progressWrap, attrTable);
  overviewSection.append(overviewBody);
  body.append(overviewSection);

  const events=prospect.scouting.events || {};
  if(events.combine){
    const combineSection=el('div',{class:'scout-report-section'});
    combineSection.append(el('h4',{},'コンバイン / 測定結果'));
    const combineBody=el('div',{class:'scout-report-body'});
    if(events.combine.summary) combineBody.append(el('div',{class:'scout-note'}, events.combine.summary));
    if(Array.isArray(events.combine.metrics) && events.combine.metrics.length){
      const metricList=el('div',{class:'scout-metric-list'});
      events.combine.metrics.forEach(metric=>{
        metricList.append(el('div',{class:'scout-metric'}, el('strong',{}, metric.label||'-'), el('span',{}, `${metric.value||'-'} / 評価 ${metric.grade||'-'}`)));
      });
      combineBody.append(metricList);
    }
    combineSection.append(combineBody);
    body.append(combineSection);
  }

  if(Array.isArray(events.tournaments) && events.tournaments.length){
    const tourSection=el('div',{class:'scout-report-section'});
    tourSection.append(el('h4',{},'大会ハイライト'));
    const tourBody=el('div',{class:'scout-report-body'});
    events.tournaments.forEach(tourney=>{
      tourBody.append(el('div',{class:'scout-tournament-item'},
        el('strong',{}, `${tourney.stage||'大会'} / ${tourney.team||'-'}`),
        el('span',{class:'mini'}, tourney.stat||'-'),
        el('span',{class:'scout-note'}, tourney.highlight||'印象的なプレー')));
    });
    tourSection.append(tourBody);
    body.append(tourSection);
  }

  if(events.notes){
    const notesSection=el('div',{class:'scout-report-section'});
    notesSection.append(el('h4',{},'スカウトメモ'));
    const notesBody=el('div',{class:'scout-report-body'}, el('div',{class:'scout-note'}, events.notes));
    notesSection.append(notesBody);
    body.append(notesSection);
  }

  modal.style.display='flex';
  refreshIcons();
}

function hideScoutReportModal(){ const modal=$('#scoutReportModal'); if(modal) modal.style.display='none'; }

function showNarrativeLogModal(tid = State.userTeamId ?? 0){
  ensureNarrativeState();
  const modal = $('#narrativeLogModal');
  const body = $('#narrativeLogBody');
  const title = $('#narrativeLogTitle');
  if(!modal || !body || !title) return;
  const teamName = id2name(tid);
  title.textContent = `${teamName} イベントログ`;
  body.innerHTML = '';
  const log = (State.teamNarratives?.[tid]?.events || []).slice().reverse();
  if(!log.length){
    body.append(el('div',{class:'narrative-log-empty'},'記録されたイベントはありません。'));
  } else {
    log.forEach(evt => {
      const entry = el('div',{class:'narrative-modal-entry'});
      entry.append(el('span',{class:'narrative-tag'}, evt.tag || 'NARRATIVE'));
      entry.append(el('h4',{}, el('i',{ 'data-lucide': evt.icon || 'sparkles', class:'mini-icon' }), evt.title || evt.summary || 'イベント'));
      if(evt.summary) entry.append(el('p',{}, evt.summary));
      if(evt.detail) entry.append(el('p',{}, evt.detail));
      const metaBits=[`${evt.season}年目 Day ${evt.day}`];
      if(evt.metadata?.opponentId != null) metaBits.push(`vs ${id2name(evt.metadata.opponentId)}`);
      entry.append(el('div',{class:'meta-line'}, metaBits.join(' ｜ ')));
      if(Array.isArray(evt.players) && evt.players.length){
        entry.append(el('p',{class:'mini'}, `対象: ${evt.players.join(', ')}`));
      }
      if(evt.effects){
        const effectBits=[];
        if(evt.effects.morale) effectBits.push(`士気 ${evt.effects.morale>0?'+':''}${evt.effects.morale}`);
        if(evt.effects.fatigue) effectBits.push(`疲労 ${evt.effects.fatigue>0?'+':''}${evt.effects.fatigue}`);
        if(Array.isArray(evt.effects.ability) && evt.effects.ability.length){
          effectBits.push('能力変化');
        }
        if(effectBits.length) entry.append(el('p',{class:'mini'}, effectBits.join(' ／ ')));
      }
      body.append(entry);
    });
  }
  modal.dataset.tid = String(tid);
  modal.style.display='flex';
  refreshIcons();
}

function hideNarrativeLogModal(){ const modal=$('#narrativeLogModal'); if(modal) modal.style.display='none'; }


function renderStandings(target){ const host=resolveTarget(target,'#standings'); if(!host) return; const st=computeStandings(State.teams, State.results||[]); const leagues=["Central","Pacific"]; const container=document.createDocumentFragment();
  leagues.forEach(lg=>{ const sub=st.filter(r=>r.league===lg); const title=el("div",{class:"mini",style:"padding:8px 12px;font-weight:bold;text-transform:uppercase;background: var(--card-header-bg); border-bottom: 2px solid var(--card-border);",html:`<b>${lg}</b>`});
    const tbl=el("table",{}, el("thead",{}, el("tr",{}, el("th",{},"チーム"), el("th",{},"W"), el("th",{},"L"), el("th",{},"Pct"), el("th",{},"GB"))), el("tbody"));
    for(const r of sub){ tbl.lastChild.append(el("tr",{}, el("td",{},r.team), el("td",{},r.W), el("td",{},r.L), el("td",{},r.Pct.toFixed(3)), el("td",{},(r.GB??0).toFixed(1)))); }
    container.append(title,tbl); });
  host.innerHTML=""; host.append(container);
}

function computeSeasonSummary(tid){
  if(!State || !Array.isArray(State.teams)) return null;
  const team = State.teams.find(t=>t.team_id===tid) || State.teams[0];
  if(!team) return null;
  tid = team.team_id;
  ensureTeamFinances();

  const record = teamRecord(tid);
  const results = (State.results||[]).filter(res=>res.home_id===tid || res.away_id===tid);
  const orderedResults = results.slice().sort((a,b)=> (a.day||0) - (b.day||0));
  const lastTen = orderedResults.slice(-10);
  const lastTenWins = lastTen.filter(r=>r.winner_id===tid).length;
  const winPct = record.total ? record.wins / record.total : 0;

  let streakCount = 0;
  let streakType = null;
  for(let i=orderedResults.length-1; i>=0; i--){
    const isWin = orderedResults[i].winner_id === tid;
    if(streakType===null){ streakType = isWin ? 'win' : 'loss'; streakCount = 1; }
    else if((isWin && streakType==='win') || (!isWin && streakType==='loss')){ streakCount++; }
    else break;
  }
  const streakText = streakType ? `${streakCount}${streakType==='win'?'連勝':'連敗'}` : '—';
  const streakMood = streakType ? (streakType==='win' ? '勢い上昇中' : '巻き返しが課題') : 'データ不足';
  const lastGame = orderedResults[orderedResults.length-1] || null;
  let lastGameText = '試合なし';
  if(lastGame){
    const opponentId = lastGame.home_id===tid ? lastGame.away_id : lastGame.home_id;
    const opponentName = id2name(opponentId);
    const marker = lastGame.winner_id===tid ? '◯' : '●';
    const score = `${lastGame.away_runs}-${lastGame.home_runs}`;
    lastGameText = `Day ${lastGame.day} vs ${opponentName} ${marker} ${score}`;
  }

  const finance = State.teamFinances?.[tid];
  const reserves = finance?.budget?.reserves ?? 0;
  const netFlow = Math.round((finance?.revenue?.total||0) - (finance?.expenses?.total||0));
  const ledger = finance?.ledger || [];
  let lastLedgerText = '取引履歴なし';
  if(ledger.length){
    const entry = ledger[ledger.length-1];
    const amount = entry?.amount || 0;
    const direction = entry?.type === 'income' ? 1 : entry?.type === 'expense' ? -1 : (amount>=0?1:-1);
    const label = entry?.label || (direction>=0 ? '収入' : '支出');
    const dayLabel = entry?.day != null ? `Day ${entry.day}` : 'Day ?';
    const displayAmount = millionFormatter(Math.abs(amount));
    lastLedgerText = `${dayLabel} ${label} ${direction>=0?'+':'-'}${displayAmount}`;
  }

  const narrative = State.teamNarratives?.[tid] || {};
  const moralePoints = (narrative.morale||[]).filter(p=>p.season===State.season);
  let moraleCurrent = Math.round(computeTeamAverageMorale(tid));
  let moraleDelta = 0;
  let moraleMeta = '士気ログ未記録';
  if(moralePoints.length){
    const lastPoint = moralePoints[moralePoints.length-1];
    moraleCurrent = lastPoint.value;
    const prevPoint = moralePoints.slice(0,-1).reverse().find(p=>p.season===lastPoint.season);
    if(prevPoint) moraleDelta = lastPoint.value - prevPoint.value;
    moraleMeta = `Day ${lastPoint.day} 更新`;
  } else if(record.total){
    moraleMeta = '試合後に自動更新されます';
  }

  const recentResults = orderedResults.slice(-12);
  const sparklineData = recentResults.map(res=>res.winner_id===tid ? 1 : -1);
  const recentWins = recentResults.filter(res=>res.winner_id===tid).length;
  const recentRecord = recentResults.length ? `${recentWins}-${recentResults.length-recentWins}` : '';

  const timelineEvents = [];
  if(moralePoints.length){
    const lastPoint = moralePoints[moralePoints.length-1];
    const prevPoint = moralePoints.slice(0,-1).reverse().find(p=>p.season===lastPoint.season);
    const delta = prevPoint ? lastPoint.value - prevPoint.value : 0;
    timelineEvents.push({
      icon:'smile',
      title:`士気 ${lastPoint.value}`,
      detail: delta ? `前回比 ${delta>0?'+':''}${delta}` : '前回比 ±0',
      meta:`Day ${lastPoint.day}`
    });
  }

  (narrative.events||[]).slice(-4).reverse().forEach(evt=>{
    const title = evt.tag ? `[${evt.tag}] ${evt.summary || evt.title || 'イベント'}` : (evt.summary || evt.title || 'イベント');
    timelineEvents.push({
      icon: evt.icon || 'sparkles',
      title,
      detail: evt.detail || evt.summary || '',
      meta: evt.day != null ? `${evt.season}年目 Day ${evt.day}` : ''
    });
  });

  const teamName = id2name(tid);
  const devEntries = (State.devLogs||[])
    .filter(log=>log && typeof log === 'string' && log.includes(teamName))
    .slice(-3)
    .reverse();
  devEntries.forEach(log=>{
    timelineEvents.push({
      icon:'flame',
      title:'育成ログ',
      detail: log,
      meta:'最近'
    });
  });

  if(timelineEvents.length>6) timelineEvents.length = 6;

  return {
    tid,
    teamName: team.team,
    record:{
      wins: record.wins,
      losses: record.losses,
      total: record.total,
      winPct,
      lastTen: record.total ? `${lastTenWins}-${lastTen.length-lastTenWins}` : '0-0'
    },
    streak:{
      text: streakText,
      kind: streakType,
      status: streakMood,
      lastGame: lastGameText
    },
    finances:{
      reserves,
      netFlow,
      lastLedgerText
    },
    morale:{
      current: Math.round(moraleCurrent),
      delta: Math.round(moraleDelta),
      meta: moraleMeta
    },
    timeline:{
      sparklineData,
      rangeLabel: recentResults.length ? `直近${recentResults.length}試合` : '',
      recordSummary: recentResults.length ? `成績 ${recentRecord}` : '',
      events: timelineEvents
    }
  };
}

function renderSeasonTimeline(timeline){
  const card=el('div',{class:'season-timeline-card',id:'season-timeline'});
  const header=el('div',{class:'timeline-header'}, el('div',{class:'timeline-title'}, el('i',{ 'data-lucide':'calendar-range', class:'mini-icon' }), 'シーズンタイムライン'));
  card.append(header);

  if(Array.isArray(timeline.sparklineData) && timeline.sparklineData.length>=2){
    const sparklineRow=el('div',{class:'timeline-sparkline'});
    sparklineRow.append(el('span',{class:'mini'}, timeline.rangeLabel || `直近${timeline.sparklineData.length}試合`));
    sparklineRow.append(createSparklineSVG(timeline.sparklineData, 'var(--accent)', 220, 36));
    if(timeline.recordSummary){
      sparklineRow.append(el('span',{class:'mini'}, timeline.recordSummary));
    }
    card.append(sparklineRow);
  } else {
    card.append(el('div',{class:'timeline-empty'},'試合データがまだありません。'));
  }

  if(Array.isArray(timeline.events) && timeline.events.length){
    const eventsWrap=el('div',{class:'timeline-events'});
    timeline.events.forEach(evt=>{
      const eventCard=el('div',{class:'timeline-event'});
      eventCard.append(el('div',{class:'timeline-event-title'}, el('i',{ 'data-lucide':evt.icon||'sparkles', class:'mini-icon' }), evt.title||'イベント'));
      if(evt.detail) eventCard.append(el('div',{class:'timeline-event-detail'}, evt.detail));
      if(evt.meta) eventCard.append(el('div',{class:'timeline-event-meta'}, evt.meta));
      eventsWrap.append(eventCard);
    });
    card.append(eventsWrap);
  } else {
    card.append(el('div',{class:'timeline-empty'},'まだハイライトが記録されていません。'));
  }

  return card;
}

function renderDashboardOverview(){
  const container=$('#dashboard-overview');
  if(!container) return;
  ensureNarrativeState();
  const selManage=$('#selTeamManage');
  let tid = parseInt(selManage?.value||'',10);
  if(Number.isNaN(tid)) tid = State.userTeamId ?? 0;
  if(!State.teams.some(t=>t.team_id===tid) && State.teams.length){
    tid = State.teams[0].team_id;
  }

  const summary=computeSeasonSummary(tid);
  container.innerHTML='';
  if(!summary){
    container.append(el('div',{class:'timeline-empty'},'チーム情報を取得できませんでした。'));
    return;
  }

  const formatSignedMillions=(val)=>{
    const sign=val>=0?'+':'-';
    return `${sign}${millionFormatter(Math.abs(val))}`;
  };

  const createCard=(icon,title,value,metaLines,valueClass='')=>{
    const classes=['summary-card-value'];
    if(valueClass) classes.push(valueClass);
    const card=el('div',{class:'summary-card'});
    card.append(el('div',{class:'summary-card-header'}, el('i',{ 'data-lucide':icon, class:'mini-icon' }), title));
    card.append(el('div',{class:classes.join(' ')}, value));
    if(Array.isArray(metaLines) && metaLines.length){
      const meta=el('div',{class:'summary-card-meta'});
      metaLines.filter(Boolean).forEach(line=>{
        if(line && typeof line === 'object' && 'nodeType' in line){
          meta.append(line);
        } else {
          meta.append(el('div',{}, line));
        }
      });
      card.append(meta);
    }
    return card;
  };

  const root=el('div',{class:'dashboard-overview'});
  root.append(el('div',{class:'dashboard-overview-header'}, `${summary.teamName} チーム状況`));

  const cardsWrap=el('div',{class:'dashboard-overview-grid'});
  const pctText=summary.record.total ? summary.record.winPct.toFixed(3).slice(1) : '.---';
  cardsWrap.append(createCard('trophy','戦績', `${summary.record.wins}-${summary.record.losses}`, [
    `勝率 ${pctText}`,
    `試合数 ${summary.record.total}`
  ]));

  const streakClass=summary.streak.kind==='win'?'positive': summary.streak.kind==='loss'?'negative':'';
  cardsWrap.append(createCard('flame','連勝・連敗', summary.streak.text, [
    `直近10戦 ${summary.record.lastTen}`,
    summary.streak.lastGame,
    summary.streak.status
  ], streakClass));

  const netFlowClass=summary.finances.netFlow>0?'positive': summary.finances.netFlow<0?'negative':'';
  const netFlowLine=el('div',{class:`summary-trend ${netFlowClass}`.trim()}, `収支 ${formatSignedMillions(summary.finances.netFlow||0)}`);
  cardsWrap.append(createCard('wallet','財務状況', millionFormatter(summary.finances.reserves||0), [
    netFlowLine,
    summary.finances.lastLedgerText
  ]));

  const moraleTrendClass=summary.morale.delta>0?'positive': summary.morale.delta<0?'negative':'';
  const moraleDeltaLine=el('div',{class:`summary-trend ${moraleTrendClass}`.trim()}, `前回比 ${summary.morale.delta>0?'+':''}${summary.morale.delta}`);
  cardsWrap.append(createCard('smile','チーム士気', `${summary.morale.current}`, [
    moraleDeltaLine,
    summary.morale.meta
  ], moraleTrendClass));

  root.append(cardsWrap);
  root.append(renderSeasonTimeline(summary.timeline));
  container.append(root);
  refreshIcons();
}

const DASHBOARD_TAB_CONFIG={
  season:{ sections:[
    { selector:'#dashboard-standings', render:renderStandings },
    { selector:'#dashboard-playoffs', render:renderPlayoffs }
  ]},
  finance:{ sections:[
    { selector:'#dashboard-front-office', render:renderFrontOffice }
  ]},
  development:{ sections:[
    { selector:'#dashboard-recent', render:renderRecent },
    { selector:'#dashboard-highlights', render:renderHighlights }
  ]}
};

function renderDashboardTabs(activeTab){
  const tabsWrap=$('#dashboard-tabs');
  const panelsWrap=$('#dashboard-panels');
  if(!tabsWrap || !panelsWrap) return;
  if(!State.ui) State.ui={};
  const tabKey=activeTab && DASHBOARD_TAB_CONFIG[activeTab]? activeTab : (State.ui.dashboardTab && DASHBOARD_TAB_CONFIG[State.ui.dashboardTab]? State.ui.dashboardTab : 'season');
  State.ui.dashboardTab=tabKey;

  $$('#dashboard-tabs .dashboard-tab').forEach(btn=>{
    const isActive=btn.dataset.tab===tabKey;
    btn.classList.toggle('active',isActive);
    btn.setAttribute('aria-selected',isActive?'true':'false');
    btn.setAttribute('tabindex',isActive?'0':'-1');
  });

  $$('#dashboard-panels .dashboard-panel').forEach(panel=>{
    const isActive=panel.dataset.panel===tabKey;
    panel.classList.toggle('active',isActive);
    panel.setAttribute('aria-hidden',isActive?'false':'true');
  });

  const config=DASHBOARD_TAB_CONFIG[tabKey];
  if(config && Array.isArray(config.sections)){
    config.sections.forEach(section=>{
      const target=resolveTarget(section.selector, section.selector);
      if(target && typeof section.render==='function'){
        section.render(target);
      }
    });
  }

  refreshIcons();
}
function renderPlayoffSeries(series, isCurrentStage){
  const block=el('div',{class:'playoff-series'});
  block.append(el('h4',{}, series.name));
  const teamsWrap=el('div',{class:'series-teams'});
  series.teams.forEach(entry=>{
    const resolved=resolvePlayoffTeam(entry) || null;
    const tid=resolved?.team_id ?? entry.team_id ?? null;
    const name=resolved?.name || entry.name || '未定';
    const wins=(tid!=null && series.wins)?(series.wins[tid]||0):0;
    const seedLabel=entry.seed?` (${entry.seed}位)`:'';
    const row=el('div',{class:'series-team'},
      el('span',{}, tid!=null ? `${name}${seedLabel}` : name),
      el('span',{class:'wins'}, `${wins}勝`)
    );
    teamsWrap.append(row);
  });
  block.append(teamsWrap);
  if(series.games && series.games.length){
    const gameList=el('ul',{class:'series-games'});
    series.games.slice(-5).toReversed().forEach(g=>{
      const line=`G${g.game}: ${id2name(g.away_id)} ${g.away_runs} - ${id2name(g.home_id)} ${g.home_runs}`;
      gameList.append(el('li',{}, line));
    });
    block.append(gameList);
  }
  const info=el('div',{class:'series-status'}, `先に${series.winsNeeded}勝で決着`);
  if(State.playoffs?.active && !series.completed && isCurrentStage){
    const action=el('div',{class:'series-action'});
    const btn=el('button',{class:'primary'}, el('i',{'data-lucide':'play'}), '次の試合');
    if(!playoffSeriesReady(series)){
      btn.disabled=true;
      btn.title='対戦相手が確定するまで待機';
    } else {
      btn.onclick=()=>{ playPlayoffGame(series.id); saveAndRerender(); };
    }
    action.append(btn, info);
    block.append(action);
  } else {
    block.append(info);
  }
  return block;
}
function renderPlayoffs(target){
  const container=resolveTarget(target,'#playoffsView');
  if(!container) return;
  const card=container.closest('[data-playoff-card]') || $("#playoffs-card");
  const playoffs=State.playoffs||defaultPlayoffState();
  const shouldShow=playoffs.started || playoffs.active || playoffs.completed;
  if(card) card.style.display=shouldShow?'' : 'none';
  container.innerHTML='';
  if(!shouldShow){ return; }
  const wrapper=el('div',{class:'playoffs-wrapper'});
  if(!playoffs.stages.length){
    wrapper.append(el('div',{class:'playoffs-empty'},'ポストシーズンは未設定です。'));
  } else {
    playoffs.stages.forEach((stage, idx)=>{
      const stageClasses=['playoff-stage'];
      if(stage.series.every(s=>s.completed)) stageClasses.push('done');
      else if(idx> (State.playoffs.stageIndex??0)) stageClasses.push('upcoming');
      const stageBlock=el('div',{class:stageClasses.join(' ')});
      const statusText = stage.series.every(s=>s.completed) ? '終了' : (idx===(State.playoffs.stageIndex??0) && State.playoffs.active ? '進行中' : '待機中');
      stageBlock.append(el('div',{class:'playoff-stage-header'}, el('span',{}, stage.name), el('span',{class:'series-status'}, statusText)));
      stage.series.forEach(series=> stageBlock.append(renderPlayoffSeries(series, idx===(State.playoffs.stageIndex??0))));
      wrapper.append(stageBlock);
    });
  }
  if(playoffs.completed && playoffs.champion!=null){
    const champName=id2name(playoffs.champion);
    const runner=playoffs.runnerUp!=null?id2name(playoffs.runnerUp):null;
    const banner=el('div',{class:'champion-banner'},
      el('div',{},`🏆 ${champName}`),
      el('div',{class:'mini'}, runner?`準優勝: ${runner}`:'おめでとうございます！')
    );
    wrapper.append(banner);
  }
  container.append(wrapper);
}
function renderRecent(target){ const container=resolveTarget(target,'#recent'); if(!container) return; const last=(State.results||[]).slice(-20).toReversed(); const tbl=el("table",{}, el("thead",{}, el("tr",{}, el("th",{},"Day"), el("th",{},"Score"), el("th",{},"Inn"), el("th",{},"Key Moment"))), el("tbody"));
  for(const r of last){ const score=`${id2name(r.away_id)} ${r.away_runs} - ${id2name(r.home_id)} ${r.home_runs}`; const key=gameRecapKey(r.day, r.home_id, r.away_id); const hasRecap=!!(State.gameRecaps&&State.gameRecaps[key]); const attrs={ class:`recent-game-row${hasRecap?"":" disabled"}` };
    if(hasRecap){ attrs.role='button'; attrs.tabindex='0'; }
    let keyMomentText='-';
    if(hasRecap){
      const recap=State.gameRecaps[key];
      if(recap){
        if(Array.isArray(recap.keyMoments) && recap.keyMoments.length){
          const moment=recap.keyMoments[recap.keyMoments.length-1];
          if(moment){
            const halfText=moment.half==='top'?'表':'裏';
            keyMomentText=`${moment.inning}回${halfText} ${moment.description}`;
          }
        } else if(recap.decidingPlay){
          keyMomentText=recap.decidingPlay;
        }
      }
    }
    const tr=el("tr",attrs, el("td",{},r.day||"?"), el("td",{style:"white-space:normal;"},score), el("td",{},r.innings||9), el("td",{style:"white-space:normal;"}, keyMomentText));
    if(hasRecap){ tr.dataset.gameKey=key; tr.onclick=()=>showGameRecapModal({ day:r.day, home_id:r.home_id, away_id:r.away_id, gameKey:key }); tr.onkeydown=(e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); tr.click(); } }; }
    tbl.lastChild.append(tr);
  }
  container.innerHTML=""; container.append(tbl);
}

function renderHighlights(target) {
    const feed = resolveTarget(target,'#highlightsFeed');
    if (!feed) return;
    feed.innerHTML = '';

    const narrativeSummary = (() => {
        const tid = State.userTeamId ?? 0;
        const narrative = State.teamNarratives?.[tid];
        if (!narrative) return null;
        const moralePoints = (narrative.morale || []).slice(-12);
        const events = (narrative.events || []).slice(-3).reverse();
        if (!moralePoints.length && !events.length) return null;

        const block = el('div', { class: 'narrative-feed-summary' });
        block.append(
            el('div', { class: 'daily-digest-header' },
                el('i', { 'data-lucide': 'drama', class: 'mini-icon' }),
                el('span', {}, `${id2name(tid)} 士気ログ`)
            )
        );

        if (moralePoints.length) {
            const values = moralePoints.map(p => p.value);
            const latest = values[values.length - 1];
            const avg = Math.round(values.reduce((a,b)=>a+b,0) / values.length);
            const meta = moralePoints[moralePoints.length - 1];
            const timeline = el('div', { class: 'morale-timeline' });
            timeline.append(el('span', {}, `最新 ${latest}`));
            timeline.append(createSparklineSVG(values, 'var(--accent)', 160, 28));
            timeline.append(el('span', {}, `平均 ${avg}`));
            block.append(timeline);
            block.append(el('p', { class: 'mini', style: 'margin:0 0 4px 0;color:var(--text-secondary);' }, `${meta.season}年目 Day ${meta.day}`));
        }

        if (events.length) {
            const list = el('ul', { class: 'narrative-log-list' });
            events.forEach(evt => {
                const item = el('li', { class: 'narrative-log-item' });
                item.append(el('span', { class: 'narrative-tag' }, evt.tag || 'NARRATIVE'));
                const summary = evt.summary || evt.title || '';
                if (summary) item.append(document.createTextNode(` ${summary}`));
                item.append(el('div', { class: 'mini' }, `${evt.season}年目 Day ${evt.day}`));
                list.append(item);
            });
            block.append(list);
        } else {
            block.append(el('div', { class: 'narrative-log-empty' }, '最新のイベントはありません。'));
        }

        const detailBtn = el('button', { class: 'ghost narrative-detail-button', type: 'button' },
            el('i', { 'data-lucide': 'notebook-text', class: 'mini-icon' }),
            'イベント履歴'
        );
        detailBtn.onclick = () => showNarrativeLogModal(tid);
        block.append(detailBtn);
        return block;
    })();

    if (narrativeSummary) feed.append(narrativeSummary);

    const buildDailyDigest = () => {
        const recaps = State.gameRecaps || {};
        const results = State.results || [];
        if (!results.length) return null;

        const byDay = new Map();
        for (let i = results.length - 1; i >= 0 && byDay.size < 7; i--) {
            const res = results[i];
            const key = gameRecapKey(res.day, res.home_id, res.away_id);
            const recap = recaps[key];
            if (!recap) continue;
            if (!byDay.has(res.day)) byDay.set(res.day, []);
            byDay.get(res.day).push({ recap, res, key });
        }
        if (!byDay.size) return null;

        const halfLabel = half => half === 'top' ? '表' : half === 'bottom' ? '裏' : '';
        const pickMoment = recap => {
            if (Array.isArray(recap.keyMoments) && recap.keyMoments.length) {
                const dramatic = [...recap.keyMoments].reverse().find(m => (m.description || '').includes('サヨナラ'));
                const candidate = dramatic || recap.keyMoments[recap.keyMoments.length - 1];
                const tid = candidate.side === 'home' ? recap.home_id : recap.away_id;
                const teamName = id2name(tid);
                const playerName = candidate.playerId ? (findPlayerById(tid, candidate.playerId)?.name || null) : null;
                return {
                    description: `${candidate.inning}回${halfLabel(candidate.half)} ${candidate.description}`,
                    score: candidate.score,
                    before: candidate.before,
                    teamName,
                    playerName
                };
            }
            if (recap.decidingPlay) {
                const tid = recap.winner_id;
                const teamName = id2name(tid);
                const playerName = recap.decidingPlayerId ? (findPlayerById(tid, recap.decidingPlayerId)?.name || null) : null;
                return {
                    description: recap.decidingPlay,
                    score: recap.score,
                    before: null,
                    teamName,
                    playerName
                };
            }
            return null;
        };

        const block = el('div', { class: 'daily-digest' });
        block.append(
            el('div', { class: 'daily-digest-header' },
                el('i', { 'data-lucide': 'calendar-clock', class: 'mini-icon' }),
                el('span', {}, '日次ダイジェスト')
            )
        );

        const list = el('div', { class: 'daily-digest-list' });
        const days = Array.from(byDay.keys()).sort((a, b) => b - a).slice(0, 5);
        days.forEach(day => {
            const entries = (byDay.get(day) || []).slice();
            entries.sort((a, b) => {
                const marginA = Math.abs((a.res.home_runs || 0) - (a.res.away_runs || 0));
                const marginB = Math.abs((b.res.home_runs || 0) - (b.res.away_runs || 0));
                if (marginA !== marginB) return marginA - marginB;
                const kmA = (a.recap.keyMoments || []).length;
                const kmB = (b.recap.keyMoments || []).length;
                return kmB - kmA;
            });

            const momentList = el('ul', { class: 'digest-moment-list' });
            let shown = 0;
            for (const entry of entries) {
                if (shown >= 3) break;
                const moment = pickMoment(entry.recap);
                if (!moment) continue;
                const scoreLine = entry.recap.scoreText || `${id2name(entry.res.away_id)} ${entry.res.away_runs} - ${id2name(entry.res.home_id)} ${entry.res.home_runs}`;
                const item = el('li', { class: 'digest-moment' });
                item.append(el('div', { class: 'digest-moment-score' }, scoreLine));

                let desc = moment.description;
                if (moment.teamName) desc = `${moment.teamName}：${desc}`;
                if (moment.before && moment.score) {
                    const beforeLine = `${moment.before.away}-${moment.before.home}`;
                    const afterLine = `${moment.score.away}-${moment.score.home}`;
                    desc += beforeLine !== afterLine ? `（${beforeLine}→${afterLine}）` : `（${afterLine}）`;
                } else if (moment.score) {
                    desc += `（${moment.score.away}-${moment.score.home}）`;
                }
                item.append(el('div', { class: 'digest-moment-desc' }, desc));

                if (moment.playerName) {
                    item.append(el('div', { class: 'digest-moment-hero' }, `ヒーロー: ${moment.playerName}`));
                }

                if (entry.key) {
                    const btn = el('button', { class: 'highlight-link ghost', type: 'button' },
                        el('i', { 'data-lucide': 'book-open', class: 'mini-icon' }),
                        '試合詳細'
                    );
                    btn.style.alignSelf = 'flex-start';
                    btn.style.marginTop = '4px';
                    btn.onclick = () => showGameRecapModal({ gameKey: entry.key, day: entry.recap.day, home_id: entry.recap.home_id, away_id: entry.recap.away_id });
                    item.append(btn);
                }

                momentList.append(item);
                shown++;
            }

            if (momentList.childElementCount) {
                const dayBlock = el('div', { class: 'digest-day' },
                    el('div', { class: 'digest-day-header' },
                        el('span', {}, `Day ${day}`),
                        el('span', { class: 'mini' }, `${entries.length}試合`)
                    ),
                    momentList
                );
                list.append(dayBlock);
            }
        });

        if (!list.childElementCount) return null;
        block.append(list);
        return block;
    };

    const digestBlock = buildDailyDigest();
    if (digestBlock) feed.append(digestBlock);

    const highlights = (State.highlights || []).slice(-50).toReversed();

    if (highlights.length === 0) {
        const message = digestBlock ? '最新の単独ハイライトはありません。日次ダイジェストを確認しましょう。' : 'まだハイライトはありません。シーズンを進めましょう！';
        feed.append(el('div', { class: 'digest-empty' }, message));
        return;
    }

    highlights.forEach(h => {
        const item = el('div', { class: 'feed-item' },
            el('div', { class: 'feed-icon' }, el('i', { 'data-lucide': h.icon, class: 'mini-icon' })),
            (() => {
                const message = el('p', {});
                if (h.category === 'finance') {
                    const label = h.financeType ? `FIN-${String(h.financeType).toUpperCase()}` : 'FINANCE';
                    const badge = el('span', { class: 'finance-tag', style: 'margin-right:6px;' }, label);
                    message.append(badge, document.createTextNode(h.text));
                } else if (h.category === 'narrative') {
                    const label = h.tag ? String(h.tag).toUpperCase() : 'NARRATIVE';
                    const badge = el('span', { class: 'narrative-tag', style: 'margin-right:6px;' }, label);
                    message.append(badge, document.createTextNode(h.text));
                } else {
                    message.textContent = h.text;
                }
                const metaBits = [`${h.season}年目 Day ${h.day}`];
                if (h.team_id != null) metaBits.push(id2name(h.team_id));
                if (h.category === 'narrative' && h.tag) metaBits.push(String(h.tag));
                if (h.category === 'finance' && h.team_id != null) {
                    const reserves = State.teamFinances?.[h.team_id]?.budget?.reserves;
                    if (typeof reserves === 'number') {
                        metaBits.push(`残高 ¥${Math.round(reserves / 1000000)}M`);
                    }
                }
                const content = el('div', { class: 'feed-content', style: 'width: 100%;' },
                    message,
                    el('p', { class: 'mini' }, metaBits.join(' ｜ '))
                );
                if (h.gameKey && State.gameRecaps?.[h.gameKey]) {
                    const btn = el('button', { class: 'highlight-link', type: 'button' },
                        el('i', { 'data-lucide': 'book-open-check', class: 'mini-icon' }),
                        '試合詳細'
                    );
                    btn.onclick = () => showGameRecapModal(h);
                    content.append(btn);
                }
                return content;
            })()
        );
        feed.append(item);
    });
}

function renderFrontOffice(target) {
    ensureTeamMeta();
    ensureTeamFinances();
    ensureFreeAgents();
    const faState = ensureFreeAgencyState(State);
    const tid = parseInt($("#selTeamManage").value || State.userTeamId || 0);
    const meta = State.teamMeta[tid];
    const finance = State.teamFinances[tid];
    const frontOfficeEl = resolveTarget(target,'#frontOffice');
    if (!frontOfficeEl) return;
    frontOfficeEl.innerHTML = "";
    if (!finance) {
        frontOfficeEl.append(el('div', { class: 'mini' }, '財務データが見つかりません。シーズンを開始してください。'));
        return;
    }
    computeAttendanceForecast(tid);
    updateFinancialSnapshots(tid);
    const allowed = canControlTeam(tid);
    const wrap = el('div', { class: 'finance-section' });

    function createSummaryCard(icon, title, headline, stats) {
        const card = el('div', { class: 'finance-card' },
            el('h3', {}, el('i', { 'data-lucide': icon, class: 'mini-icon' }), title),
            el('div', { style: 'font-size:22px;font-weight:700;' }, headline)
        );
        stats.forEach(([label, value]) => card.append(el('div', { class: 'finance-stat' }, el('span', {}, label), el('strong', {}, value))));
        return card;
    }

    const summaryGrid = el('div', { class: 'finance-grid' });
    summaryGrid.append(
        createSummaryCard('piggy-bank', '運転資金', millionFormatter(finance.budget.reserves || 0), [
            ['年間収入', millionFormatter(finance.revenue.total || 0)],
            ['年間支出', millionFormatter(finance.expenses.total || 0)]
        ]),
        createSummaryCard('wallet', '年俸総額', millionFormatter(finance.expenses.payroll || 0), [
            ['スタッフ', millionFormatter(finance.expenses.staff || 0)],
            ['施設投資', millionFormatter(finance.expenses.facilities || 0)]
        ]),
        createSummaryCard('users', '観客動員', `${yenFormatter.format(finance.attendance.forecast || 0)} 人`, [
            ['平均', `${yenFormatter.format(finance.attendance.average || 0)} 人`],
            ['累計', `${yenFormatter.format(finance.attendance.seasonTotal || 0)} 人`]
        ]),
        createSummaryCard('sprout', 'Devポイント', `${Math.floor(meta.dp || 0)} pt`, [
            ['FA候補', `${State.freeAgents.length} 名`],
            ['チケット', `¥${yenFormatter.format(finance.ticketPrice || DEFAULT_TICKET_PRICE)}`]
        ])
    );
    wrap.append(summaryGrid);

    const budgetCard = el('div', { class: 'finance-card' });
    budgetCard.append(el('h3', {}, el('i', { 'data-lucide': 'pie-chart' }), '予算配分'));
    const budgetLabels = { payroll: '選手年俸', staff: 'スタッフ', facilities: '施設整備', marketing: 'マーケティング' };
    function setAllocation(cat, ratio) {
        finance.budget.allocations[cat] = ratio;
        const total = BUDGET_CATEGORIES.reduce((sum, key) => sum + (finance.budget.allocations[key] || 0), 0);
        if (Math.abs(total - 1) > 0.001) {
            const others = BUDGET_CATEGORIES.filter(c => c !== cat);
            const remainder = 1 - finance.budget.allocations[cat];
            const otherTotal = others.reduce((sum, key) => sum + (finance.budget.allocations[key] || 0), 0);
            others.forEach(key => {
                finance.budget.allocations[key] = otherTotal > 0 ? (finance.budget.allocations[key] || 0) / otherTotal * remainder : remainder / others.length;
            });
        }
        updateFinancialSnapshots(tid);
        saveAndRerender();
    }
    BUDGET_CATEGORIES.forEach(cat => {
        const ratio = finance.budget.allocations[cat] || 0;
        const percent = el('strong', {}, `${Math.round(ratio * 100)}%`);
        const slider = el('input', { type: 'range', min: '5', max: '80', value: Math.round(ratio * 100), class: 'budget-slider' });
        slider.oninput = () => percent.textContent = `${slider.value}%`;
        slider.onchange = () => setAllocation(cat, parseInt(slider.value, 10) / 100);
        slider.disabled = !allowed;
        const block = el('div', { style: 'display:flex; flex-direction:column; gap:4px; margin-bottom:6px;' },
            el('div', { class: 'finance-stat' }, el('span', {}, budgetLabels[cat] || cat), percent),
            slider
        );
        budgetCard.append(block);
    });
    wrap.append(budgetCard);

    const ticketCard = el('div', { class: 'finance-card' });
    ticketCard.append(el('h3', {}, el('i', { 'data-lucide': 'ticket' }), 'チケット価格 & 需要'));
    const ticketInput = el('input', { type: 'number', min: '1200', max: '7000', step: '100', value: finance.ticketPrice || DEFAULT_TICKET_PRICE });
    ticketInput.disabled = !allowed;
    ticketInput.onchange = () => {
        const val = clamp(parseInt(ticketInput.value, 10) || DEFAULT_TICKET_PRICE, 1200, 7000);
        finance.ticketPrice = val;
        computeAttendanceForecast(tid);
        updateFinancialSnapshots(tid);
        saveAndRerender();
    };
    ticketCard.append(el('div', { class: 'finance-stat' }, el('span', {}, '価格(円)'), ticketInput));
    const forecastBlock = el('div', { class: 'finance-forecast' },
        el('span', {}, el('strong', {}, '予測'), `${yenFormatter.format(finance.attendance.forecast || 0)} 人`),
        el('span', {}, el('strong', {}, '平均'), `${yenFormatter.format(finance.attendance.average || 0)} 人`),
        el('span', {}, el('strong', {}, '累計'), `${yenFormatter.format(finance.attendance.seasonTotal || 0)} 人`)
    );
    ticketCard.append(forecastBlock);
    wrap.append(ticketCard);

    const contractSection = el('div', { class: 'finance-section' });
    contractSection.append(el('h3', {}, el('i', { 'data-lucide': 'notebook-pen' }), '契約状況'));
    const contractsHost = el('div', { id: 'contractsViewHost' });
    contractSection.append(contractsHost);
    const contractActions = el('div', { class: 'finance-actions' });
    const faBtn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'user-plus' }), 'FA市場');
    faBtn.disabled = !allowed;
    faBtn.onclick = () => openFreeAgentModal(tid);
    const tradeBtn = el('button', {}, el('i', { 'data-lucide': 'handshake' }), 'トレード提案');
    tradeBtn.disabled = !allowed;
    tradeBtn.onclick = () => openTradeModal(tid);
    const ledgerBtn = el('button', {}, el('i', { 'data-lucide': 'file-text' }), '財務レポート');
    ledgerBtn.onclick = () => openLedgerModal(tid);
    contractActions.append(faBtn, tradeBtn, ledgerBtn);
    contractSection.append(contractActions);
    wrap.append(contractSection);
    contractsView.render({
        container: contractsHost,
        roster: State.rosters?.[tid],
        finance,
        teamId: tid,
        season: State.season,
        day: State.curr_day,
        canControl: allowed,
    });

    const faSection = el('div', { class: 'finance-section' });
    faSection.append(el('h3', {}, el('i', { 'data-lucide': 'user-cog', class: 'mini-icon' }), 'FA市場 & 補償管理'));
    const faHost = el('div', { id: 'faViewHost' });
    faSection.append(faHost);
    wrap.append(faSection);
    faView.render({
        container: faHost,
        roster: State.rosters?.[tid],
        freeAgents: State.freeAgents,
        faState,
        teamId: tid,
        canControl: allowed,
        season: State.season,
        state: State,
    });

    const staffCard = el('div', { class: 'finance-card' });
    staffCard.append(el('h3', {}, el('i', { 'data-lucide': 'briefcase-business' }), 'スタッフ雇用'));
    const staffLabels = { coaches: 'コーチ', scouts: 'スカウト', analysts: 'アナリスト', marketing: '営業/広報' };
    Object.entries(staffLabels).forEach(([key, label]) => {
        const count = finance.staff[key] || 0;
        const cost = STAFF_COSTS[key] || 0;
        staffCard.append(el('div', { class: 'finance-stat' }, el('span', {}, label), el('strong', {}, `${count} 名`)));
        const buttons = el('div', { class: 'finance-actions' });
        const hireBtn = el('button', { class: 'primary' }, el('i', { 'data-lucide': 'plus' }), '採用');
        hireBtn.disabled = !allowed || (finance.budget.reserves || 0) < cost;
        hireBtn.onclick = () => {
            if (!allowed || (finance.budget.reserves || 0) < cost) return;
            finance.staff[key] = (finance.staff[key] || 0) + 1;
            finance.budget.reserves -= cost;
            logHighlight('briefcase', `【スタッフ採用】${id2name(tid)}が${label}を追加雇用。`, { category: 'finance', financeType: 'staff', tid, day: State.curr_day });
            updateFinancialSnapshots(tid);
            saveAndRerender();
        };
        const fireBtn = el('button', {}, el('i', { 'data-lucide': 'minus' }), '削減');
        fireBtn.disabled = !allowed || count <= 0;
        fireBtn.onclick = () => {
            if (!allowed || finance.staff[key] <= 0) return;
            finance.staff[key]--;
            finance.budget.reserves += Math.round(cost * 0.3);
            logHighlight('briefcase', `【スタッフ再編】${label}体制を見直しました。`, { category: 'finance', financeType: 'staff', tid, day: State.curr_day });
            updateFinancialSnapshots(tid);
            saveAndRerender();
        };
        buttons.append(hireBtn, fireBtn, el('span', { class: 'mini' }, `コスト ${millionFormatter(cost)}`));
        staffCard.append(buttons);
    });
    wrap.append(staffCard);

    const upgradeCard = el('div', { class: 'finance-card' });
    upgradeCard.append(el('h3', {}, el('i', { 'data-lucide': 'wrench' }), '育成投資 (DevP)'));
    upgradeCard.append(el('div', { class: 'finance-stat' }, el('span', {}, '保有Devポイント'), el('strong', {}, `${Math.floor(meta.dp || 0)} pt`)));
    const upgradeTable = el('table', { class: 'contract-table' },
        el('thead', {}, el('tr', {},
            el('th', {}, '種別'),
            el('th', {}, 'レベル'),
            el('th', {}, '効果'),
            el('th', {}, '操作')
        )),
        el('tbody')
    );
    function upgradeRow(name, currentLevel, desc, updateFn) {
        const tr = el('tr');
        const level = currentLevel || 0;
        const maxLevel = 3;
        const cost = 20 + (level * 10);
        const btn = el('button', {}, el('i', { 'data-lucide': 'plus' }), level >= maxLevel ? 'MAX' : `強化(${cost})`);
        if (level >= maxLevel) {
            btn.disabled = true;
        } else if (!allowed) {
            btn.disabled = true;
            btn.title = '自チーム以外は操作できません（コミッショナーモードで可）';
        } else {
            btn.onclick = () => {
                if (dpSpend(tid, cost)) {
                    updateFn();
                    State.devLogs.push(`[${id2name(tid)}] 強化: ${name} → Lv${level + 1}`);
                    saveAndRerender();
                } else {
                    console.error(`ポイント不足 (必要: ${cost})`);
                }
            };
        }
        tr.append(
            el('td', {}, name),
            el('td', {}, level),
            el('td', { style: 'white-space:normal;text-align:left' }, desc),
            el('td', {}, btn)
        );
        return tr;
    }
    upgradeTable.lastChild.append(
        upgradeRow('トレーニングジム', meta.facilities.gym, 'パワー/球威/体力の伸び+2%/Lv', () => meta.facilities.gym++),
        upgradeRow('ビデオ・ラボ', meta.facilities.video, 'コン/選球/制球/変化/守備の伸び+2%/Lv', () => meta.facilities.video++),
        upgradeRow('メディカルセンター', meta.facilities.medical, '週の回復 +6/Lv・故障率軽減', () => { meta.facilities.medical++; meta.facilities.recovery = meta.facilities.medical; }),
        upgradeRow('打撃コーチ', meta.coaches.hit, '打撃系の伸び+3%/Lv', () => meta.coaches.hit++),
        upgradeRow('投手コーチ', meta.coaches.pit, '投手系の伸び+3%/Lv', () => meta.coaches.pit++),
        upgradeRow('コンディショニング', meta.coaches.cond, '全体の伸び+1%/Lv・疲労耐性', () => meta.coaches.cond++)
    );
    upgradeCard.append(el('div', { class: 'table-scroll', style: 'max-height:220px;' }, upgradeTable));
    wrap.append(upgradeCard);

    frontOfficeEl.append(wrap);
    refreshIcons();
}

function renderManagementView(){ const tab = $(".tab.active").getAttribute("data-tab"); const tid = parseInt($("#selTeamManage").value||0); const container = $("#management-content"); container.innerHTML = "";
  const narrativePanel = renderTeamNarrativePanel(tid);
  if(narrativePanel) container.append(narrativePanel);
  if(tab === "roster") container.append(renderRosterView(tid));
  if(tab === "training") container.append(renderTrainingView(tid));
  if(tab === "stats") container.append(renderStatsView(tid));
  if(tab === "draft") draftView.render({ container, teamId: tid, userTeamId: State.userTeamId??0, isCommissioner: !!State.commissioner });
  if(tab === "front") {
    const frontContainer = el('div', { class: 'front-office-view' });
    container.append(frontContainer);
    financeView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
    staffView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
    facilitiesView.render({ container: frontContainer, teamId: tid, canControl: canControlTeam(tid) });
  }
  if(tab === "report") container.append(renderReportView());
}

function moraleBar(v){ const wrap=el("div",{style:"min-width:140px;text-align:left"}); wrap.append(el("div",{class:"mini",style:"margin-bottom:4px;"},`士気 ${v}`)); const bar=el("div",{class:"bar",style:"width:140px;"}, el("span",{style:`width:${v}%;`})); wrap.append(bar); return wrap; }
function fatigueBar(v){ const wrap=el("div",{style:"min-width:140px;text-align:left"}); wrap.append(el("div",{class:"mini",style:"margin-bottom:4px;"},`疲労 ${v}`)); const bar=el("div",{class:"bar",style:"width:140px;"}, el("span",{style:`width:${v}%;background:linear-gradient(90deg,#ef4444,#f59e0b);`})); wrap.append(bar); return wrap; }

function squadSelect(tid, pid, cur){
  const sl = el("select", {"data-id":pid, class:"squad", style:"width:80px;"});
  ["一軍","二軍"].forEach(k=>sl.append(el("option", {value:k, selected:k===cur?true:null}, k)));
  const allowed = canControlTeam(tid);
  if(!allowed){
    sl.disabled = true;
    sl.title = "自チーム以外は操作できません（コミッショナーモードで可）";
    return sl;
  }
  sl.dataset.prev = cur;
  sl.onchange = ()=>{
    const prevValue=sl.dataset.prev||cur;
    const result=moveSquad(tid, pid, sl.value);
    if(!result?.ok){
      sl.value=prevValue;
      const remaining=result?.remainingDays;
      let desc='';
      if(Number.isFinite(remaining)){
        desc=`あと${remaining}日必要です。`;
        if(result?.error?.availableDay){
          desc+=` (${result.error.availableDay}日目以降に移動可能)`;
        }
      }
      showToast(result?.reason||'移動できませんでした。', { type:'error', description:desc || undefined, duration:5000 });
      return;
    }
    sl.dataset.prev=result.to||sl.value;
    if(!result.changed){
      return;
    }
    recomputeAllRatingsAll();
    save();
    renderManagementView();
    updateAdvanceButtonsState();
  };
  return sl;
}

function renderRosterView(tid){
  ensureSquads(); const R=State.rosters[tid]; const ichiSet=new Set(State.squads[tid].ichi); const niSet=new Set(State.squads[tid].ni); const frag=document.createDocumentFragment();
  const compliance=getRosterCompliance(tid) || null;
  if(compliance && ((Array.isArray(compliance.errors) && compliance.errors.length) || (Array.isArray(compliance.warnings) && compliance.warnings.length))){
    const hasError=Array.isArray(compliance.errors) && compliance.errors.length>0;
    const severity=hasError?'error':'warning';
    const icon=hasError?'shield-alert':'alert-triangle';
    const headline=hasError?compliance.errors[0]:compliance.warnings[0];
    const banner=el('div',{class:`roster-compliance-banner ${severity}`});
    banner.append(
      el('div',{class:'banner-header'}, el('i',{'data-lucide':icon,class:'mini-icon'}), headline),
      el('div',{class:'banner-body'},`現在 ${compliance.foreignCount}/${compliance.limit ?? '—'} 枠（一軍 ${compliance.activeCount ?? 0}名、${compliance.label}）`)
    );
    if(Array.isArray(compliance.foreignPlayers) && compliance.foreignPlayers.length){
      const list=el('ul');
      compliance.foreignPlayers.forEach(player=>{
        const role=player.type==='PIT'?'投手':'野手';
        list.append(el('li',{},`${player.name} (${role})`));
      });
      banner.append(list);
    }
    frag.append(banner);
  }
  const allowed = canControlTeam(tid);
  const hBat=el("h3",{class:"mini",style:"padding:8px;font-weight:bold;",html:"<br>野手"});
  const tBat=el("table",{},el("thead",{},el("tr",{},...['選手','年','守','投','ミ','選','パ','走','守','ポ','所属', '<i data-lucide="trending-up" class="mini-icon"></i>', '<i data-lucide="battery-warning" class="mini-icon"></i>', '<i data-lucide="smile" class="mini-icon"></i>','特能','特訓'].map(h=>el('th',{html:h})))),el("tbody"));
  
  const prevSeason = State.season - 1;

  R.bats.slice().sort((a,b)=> battingScore(b,"R")-battingScore(a,"R")).forEach(batter=>{
    const tr = el('tr');
    if (batter.injury) tr.classList.add('injured');

    let statusIcon = '';
    if (batter.injury) statusIcon = '🩹';
    else if (batter.status?.hot > 0) statusIcon = '🔥';
    else if (batter.status?.slump > 0) statusIcon = '❄️';
    
    const nameTd = el('td', { style: 'display:flex; align-items:center; gap: 4px;'});
    const nameBtn = el('button', { class: 'ghost', style: 'text-decoration: underline; box-shadow: none; padding: 4px; text-align: left;', html: `${statusIcon} ${batter.name}` });
    nameBtn.onclick = () => showPlayerDetailModal(batter.id, tid);
    nameTd.append(nameBtn);
    if(batter.isForeign){
      nameTd.append(el('span',{class:'foreign-badge', title:'外国人枠対象'},'外'));
    }

    if (batter.recentGains && batter.recentGains.length > 0) {
        const statGain = batter.recentGains.find(g => /^[A-Za-z]+\+\d+$/.test(g));
        if (statGain) {
            let [stat, val] = statGain.split('+');
            const gainBadge = el('span', { class: 'pill', style: 'font-size: 9px; padding: 1px 4px; background: var(--good); color: #fff; border: none; font-weight: 700;' }, `${stat.slice(0,3)} +${val}`);
            nameTd.append(gainBadge);
        }
    }

    if (niSet.has(batter.id)) {
        const reveal = Math.round(batter.farmReveal || 0);
        if (Number.isFinite(reveal)) {
            const gain = Math.round(batter.farmLast?.revealGain || 0);
            const label = gain > 0 ? `潜在${reveal}% (+${gain})` : `潜在${reveal}%`;
            const badge = el('span', { class: 'pill farm', title: `二軍潜在開示度 ${reveal}%` }, label);
            nameTd.append(badge);
        }
        const recovered = Math.round(batter.farmLast?.fatigueRecovered || 0);
        if (recovered > 0) {
            nameTd.append(el('span', { class: 'pill farm-fatigue', title: '二軍追加回復量' }, `回復${recovered}`));
        }
        if (Array.isArray(batter.farmLast?.traitUnlocks) && batter.farmLast.traitUnlocks.length > 0) {
            const title = batter.farmLast.traitUnlocks.join(' / ');
            nameTd.append(el('span', { class: 'pill farm-trait', title }, '覚醒'));
        }
    }
    
    const prevHistory = State.historicalStats?.[prevSeason]?.[batter.id]?.history;

    tr.append( nameTd, el('td',{},batter.age), el('td',{},batter.pos), el('td',{},batter.hand), statTd(batter.con), statTd(batter.disc), statTd(batter.pwr), statTd(batter.spd), statTd(batter.fld), statTd(batter.pot), 
        el('td',{},squadSelect(tid, batter.id, ichiSet.has(batter.id)?'一軍':'二軍')), 
        el('td', {}, createSparklineSVG(batter.history.overall, 'var(--primary)', 40, 16, prevHistory?.overall)),
        el('td', {}, createSparklineSVG(batter.history.fatigue, 'var(--warn)', 40, 16, prevHistory?.fatigue)),
        el('td', {}, createSparklineSVG(batter.history.morale, 'var(--accent)', 40, 16, prevHistory?.morale)),
        el('td',{style:'white-space:normal; font-size: 11px;'}, (batter.traits||[]).join(' '))
    );

    const btnWrap=el('td',{});
    const btn=el('button',{class:'ghost'}, el('i',{"data-lucide":"flame"}), '特訓(5)');
    if(!allowed || batter.injury){ btn.disabled=true; btn.title= batter.injury ? '怪我のため不可' : '自チーム以外は操作できません'; }
    else { btn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevP不足'); return; } doSpecialTraining(tid, batter.id); }; }
    btnWrap.append(btn); 
    tr.append(btnWrap); 
    tBat.lastChild.append(tr);
  });
  const hPit=el("h3",{class:"mini",style:"padding:8px;font-weight:bold;",html:"<br>投手"});
  const tPit=el("table",{},el("thead",{},el("tr",{},...['選手','年','役','投','速','コ','変','体','ポ','所属', '<i data-lucide="trending-up" class="mini-icon"></i>', '<i data-lucide="battery-warning" class="mini-icon"></i>', '<i data-lucide="smile" class="mini-icon"></i>','特能','特訓'].map(h=>el('th',{html:h})))),el("tbody"));

  R.pits.slice().sort((a,b)=> (b.velo*0.45+b.mov*0.35+b.ctrl*0.2)-(a.velo*0.45+a.mov*0.35+a.ctrl*0.2)).forEach(p=>{
    const tr = el('tr');
    if (p.injury) tr.classList.add('injured');

    let statusIcon = '';
    if (p.injury) statusIcon = '🩹';
    else if (p.status?.hot > 0) statusIcon = '🔥';
    else if (p.status?.slump > 0) statusIcon = '❄️';

    const nameTd = el('td', { style: 'display:flex; align-items:center; gap: 4px;'});
    const nameBtn = el('button', { class: 'ghost', style: 'text-decoration: underline; box-shadow: none; padding: 4px; text-align: left;', html: `${statusIcon} ${p.name}` });
    nameBtn.onclick = () => showPlayerDetailModal(p.id, tid);
    nameTd.append(nameBtn);
    if(p.isForeign){
      nameTd.append(el('span',{class:'foreign-badge', title:'外国人枠対象'},'外'));
    }

    if (p.recentGains && p.recentGains.length > 0) {
        const statGain = p.recentGains.find(g => /^[A-Za-z]+\+\d+$/.test(g));
        if (statGain) {
            let [stat, val] = statGain.split('+');
            const gainBadge = el('span', { class: 'pill', style: 'font-size: 9px; padding: 1px 4px; background: var(--good); color: #fff; border: none; font-weight: 700;' }, `${stat.slice(0,3)} +${val}`);
            nameTd.append(gainBadge);
        }
    }

    if (niSet.has(p.id)) {
        const reveal = Math.round(p.farmReveal || 0);
        if (Number.isFinite(reveal)) {
            const gain = Math.round(p.farmLast?.revealGain || 0);
            const label = gain > 0 ? `潜在${reveal}% (+${gain})` : `潜在${reveal}%`;
            nameTd.append(el('span', { class: 'pill farm', title: `二軍潜在開示度 ${reveal}%` }, label));
        }
        const recovered = Math.round(p.farmLast?.fatigueRecovered || 0);
        if (recovered > 0) {
            nameTd.append(el('span', { class: 'pill farm-fatigue', title: '二軍追加回復量' }, `回復${recovered}`));
        }
        if (Array.isArray(p.farmLast?.traitUnlocks) && p.farmLast.traitUnlocks.length > 0) {
            nameTd.append(el('span', { class: 'pill farm-trait', title: p.farmLast.traitUnlocks.join(' / ') }, '覚醒'));
        }
    }
    
    const roleCell = el('td');
    if (p.role === 'SP') {
        roleCell.textContent = 'SP';
    } else {
        const subRoleSelect = el('select', { style: 'width: 110px;' });
        const subRoles = ['中継ぎ', 'セットアッパー', 'クローザー'];
        subRoles.forEach(sr => {
            subRoleSelect.append(el('option', { value: sr, selected: (p.sub_role || '中継ぎ') === sr }, sr));
        });
        if (!allowed) {
            subRoleSelect.disabled = true;
        } else {
            subRoleSelect.onchange = () => {
                p.sub_role = subRoleSelect.value;
                recomputeAllRatingsAll();
                save();
            };
        }
        roleCell.append(subRoleSelect);
    }

    const prevHistory = State.historicalStats?.[prevSeason]?.[p.id]?.history;

    tr.append( nameTd, el('td',{},p.age), roleCell, el('td',{},p.hand), statTd(p.velo), statTd(p.ctrl), statTd(p.mov), statTd(p.stam), statTd(p.pot), 
        el('td',{},squadSelect(tid, p.id, ichiSet.has(p.id)?'一軍':'二軍')), 
        el('td', {}, createSparklineSVG(p.history.overall, 'var(--primary)', 40, 16, prevHistory?.overall)),
        el('td', {}, createSparklineSVG(p.history.fatigue, 'var(--warn)', 40, 16, prevHistory?.fatigue)),
        el('td', {}, createSparklineSVG(p.history.morale, 'var(--accent)', 40, 16, prevHistory?.morale)),
        el('td',{style:'white-space:normal; font-size: 11px;'}, (p.traits||[]).join(' '))
    );
    
    const btnWrap=el('td',{});
    const btn=el('button',{class:'ghost'}, el('i',{"data-lucide":"flame"}), '特訓(5)');
    if(!allowed || p.injury){ btn.disabled=true; btn.title= p.injury ? '怪我のため不可' : '自チーム以外は操作できません'; }
    else { btn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevP不足'); return; } doSpecialTraining(tid, p.id); }; }
    btnWrap.append(btn); 
    tr.append(btnWrap); 
    tPit.lastChild.append(tr);
  });
  frag.append(el("div",{class:"table-scroll"}, hBat, tBat), el("div", {class:"table-scroll", style:"margin-top:16px;"}, hPit, tPit));
  return frag;
}

function renderTrainingView(tid){
  ensureSquads(); ensureTrainingDefaults(tid); const R=State.rosters[tid]; const tp=State.trainingPlans[tid]; const ichiSet=new Set(State.squads[tid].ichi); const frag=document.createDocumentFragment();
  const allowed = canControlTeam(tid);

  ensureTeamStrategy(tid);
  const strategy = State.teamStrategy[tid];

  const steps = el('ol', { class: 'training-steps', 'aria-label': '育成ワークフロー' });
  ['方針設定','フィルター','選手操作','詳細'].forEach((label, idx) => {
    const step = el('li', { class: `training-step${idx===0?' active':''}` });
    step.append(el('span', { class: 'training-step-number' }, String(idx+1)), el('span', {}, label));
    steps.append(step);
  });

  const controls=el("div",{class:"controls"},
    el("button",{id:"btnAutoAssign"}, el("i",{"data-lucide":"shuffle"}), "1軍/2軍を自動編成"),
    el("button",{id:"btnAutoPlan"}, el("i",{"data-lucide":"brain-circuit"}), "全員トレーニング自動割当"),
    el("button",{id:"btnTrainWeek", class:"primary"}, el("i",{"data-lucide":"arrow-right"}), "育成を1週進める"),
    el("button",{id:"btnSpringCamp", style:"background-color:#166534; border-color:#14532d; color: #fff;"}, el("i",{"data-lucide":"sprout"}),"春季キャンプ")
  );
  const topBar = el('div', { class: 'training-top' }, steps, controls);

  controls.querySelector("#btnAutoAssign").onclick=()=>{
    if(!allowed){ console.error('自チーム以外は操作できません'); return; }
    autoAssignSquads(tid);
    recomputeAllRatingsAll();
    renderManagementView();
    save();
  };
  controls.querySelector("#btnAutoPlan").onclick=()=>{ if(!allowed){ console.error('自チーム以外は操作できません'); return; } autoPlan(tid); renderManagementView(); };
  controls.querySelector("#btnTrainWeek").onclick=()=>{ if(!allowed){ console.error('自チーム以外は操作できません'); return; } applyTrainingWeek(tid, 1, "手動週次育成"); recomputeAllRatingsAll(); renderAll(); };
  controls.querySelector("#btnSpringCamp").onclick=()=>{ if(!allowed){ console.error('自チーム以外は操作できません'); return; }State.squads[tid].ichi.forEach(pid=>{ addWeekXP(pid, 8); }); State.squads[tid].ni.forEach(pid=>{ addWeekXP(pid, 16); }); applyTrainingWeek(tid, 5, "春季キャンプ"); recomputeAllRatingsAll(); renderAll(); };
  if(!allowed){ controls.querySelectorAll('button').forEach(b=>{ b.disabled=true; b.title='自チーム以外は操作できません（コミッショナーモードで可）'; }); }

  const policyContainer = el('div', { class: 'card', style: 'margin-bottom: 24px;' });
  const policyHeader = el('div', { class: 'card-header' }, el('h2', {}, el('i', { 'data-lucide': 'clipboard-list' }), 'チーム方針'));
  const policyContent = el('div', { class: 'card-content', style: 'display: flex; flex-direction: column; gap: 12px;' });

  const rosterLabel = el('label', { style: 'display:flex; justify-content: space-between; align-items: center;' }, '昇降格方針');
  const rosterSelect = el('select', { style: 'width: 180px;' });
  const rosterOptions = { 'default': 'AI総合評価', 'youth': '若手育成重視', 'veteran': 'ベテラン重視' };
  for (const [value, text] of Object.entries(rosterOptions)) {
      rosterSelect.append(el('option', { value, selected: strategy.roster === value }, text));
  }
  rosterSelect.onchange = () => { strategy.roster = rosterSelect.value; save(); };
  rosterLabel.append(rosterSelect);

  const lineupLabel = el('label', { style: 'display:flex; justify-content: space-between; align-items: center;' }, 'スタメン方針');
  const lineupSelect = el('select', { style: 'width: 180px;' });
  const lineupOptions = { 'condition': 'コンディション重視', 'best_member': 'ベストメンバー重視' };
  for (const [value, text] of Object.entries(lineupOptions)) {
      lineupSelect.append(el('option', { value, selected: strategy.lineup === value }, text));
  }
  lineupSelect.onchange = () => { strategy.lineup = lineupSelect.value; save(); };
  lineupLabel.append(lineupSelect);

  if (!allowed) {
      rosterSelect.disabled = true;
      lineupSelect.disabled = true;
  }
  policyContent.append(rosterLabel, lineupLabel);
  policyContainer.append(policyHeader, policyContent);

  function focusSelect(id, isPitch, cur){ const sl=el("select",{"data-id":id,class:"focus",style:"width:100%;"}); const arr=isPitch?FOCUS_PIT:FOCUS_BAT; arr.forEach(k=>sl.append(el("option",{value:k,selected:k===cur?true:null},k))); if(!allowed){ sl.disabled=true; sl.title='自チーム以外は変更不可'; } return sl; }
  function intensSelect(id, cur){ const sl=el("select",{"data-id":id,class:"intens",style:"width:100%;"}); ["軽","標準","強"].forEach(k=>sl.append(el("option",{value:k,selected:k===cur?true:null},k))); if(!allowed){ sl.disabled=true; sl.title='自チーム以外は変更不可'; } return sl; }
  function boostTxt(pid){ return ((appearanceBoost(pid)-1)*100).toFixed(0)+"%"; }

  const rosterMap = new Map();
  R.bats.forEach(p=> rosterMap.set(p.id, { player:p, type:'BAT' }));
  R.pits.forEach(p=> rosterMap.set(p.id, { player:p, type:'PIT' }));

  const grouped={ ichi:{ bats:[], pits:[] }, ni:{ bats:[], pits:[] } };
  const assigned=new Set();
  ['ichi','ni'].forEach(key=>{
    (State.squads[tid][key]||[]).forEach(pid=>{
      const entry=rosterMap.get(pid);
      if(entry){
        grouped[key][entry.type==='BAT'?'bats':'pits'].push(entry.player);
        assigned.add(pid);
      }
    });
  });
  rosterMap.forEach((entry,pid)=>{
    if(!assigned.has(pid)){
      const key=ichiSet.has(pid)?'ichi':'ni';
      grouped[key][entry.type==='BAT'?'bats':'pits'].push(entry.player);
    }
  });

  ensureWeekXPLog();
  const prevSeason=(State.season||0)-1;
  function createSparklineItem(label, series, color, prev){
    const wrap=el('div',{class:'sparkline-item'});
    wrap.append(el('span',{},label), createSparklineSVG(series, color, 100, 24, prev));
    return wrap;
  }
  function createControl(labelText, inputEl, id){
    const wrap=el('div',{class:'player-card-control'});
    if(id){ inputEl.id=id; }
    const label=el('label',{for:id},labelText);
    wrap.append(label, inputEl);
    return wrap;
  }
  function createFilterControl(labelText, inputEl){
    const wrap=el('div',{class:'training-filter'});
    wrap.append(el('label',{},labelText), inputEl);
    return wrap;
  }
  const filterDefaults={ role:'all', squad:'all', focus:'all', moraleMax:100, fatigueMin:0, sort:'name' };
  if(!State.ui) State.ui={};
  if(!State.ui.trainingFilters) State.ui.trainingFilters={};
  const existingFilters=State.ui.trainingFilters[tid];
  const mergedFilters={ ...filterDefaults, ...(existingFilters||{}) };
  const moraleVal=parseInt(mergedFilters.moraleMax,10);
  const fatigueVal=parseInt(mergedFilters.fatigueMin,10);
  mergedFilters.moraleMax=Number.isFinite(moraleVal)?clamp(moraleVal,0,100):100;
  mergedFilters.fatigueMin=Number.isFinite(fatigueVal)?clamp(fatigueVal,0,100):0;
  State.ui.trainingFilters[tid]=mergedFilters;
  State.ui.trainingFiltersActiveTid=tid;
  const filters=State.ui.trainingFilters[tid];
  const focusOptions=Array.from(new Set([...FOCUS_BAT, ...FOCUS_PIT]));
  function ensurePlan(player, type){
    return tp[player.id]||(tp[player.id]={ focus:(type==='PIT'?FOCUS_PIT:FOCUS_BAT)[0], intens:'標準' });
  }
  function createConditionBadge(kind, value){
    if(value===undefined || value===null) return null;
    if(kind==='fatigue'){
      if(value>=90) return el('span',{class:'condition-badge danger', title:'極度の疲労: 怪我リスクが高まります'},`疲労 ${value}`);
      if(value>=75) return el('span',{class:'condition-badge warn', title:'疲労が蓄積しています。調整を検討してください'},`疲労 ${value}`);
      return null;
    }
    if(kind==='morale'){
      if(value<=30) return el('span',{class:'condition-badge danger', title:'士気低下: パフォーマンスに悪影響が出ています'},`士気 ${value}`);
      if(value<=45) return el('span',{class:'condition-badge warn', title:'士気が落ちています。起用やケアを再検討しましょう'},`士気 ${value}`);
      return null;
    }
    return null;
  }
  function computeProgress(player, plan){
    const xp=State.weekXP[player.id]||0;
    const intensityValue=INTENS[plan.intens]||1;
    const xpGoal=Math.max(1, Math.round(20*intensityValue));
    const xpProgress=clamp(xp/xpGoal,0,1);
    const boost=appearanceBoost(player.id);
    const boostProgress=clamp((boost-1)/0.2,0,1);
    const intensityProgress=clamp((intensityValue-0.7)/0.6,0,1);
    const score=clamp((xpProgress*0.5)+(boostProgress*0.3)+(intensityProgress*0.2),0,1);
    const percent=clamp(Math.round(score*100),0,100);
    const series=getWeekXPSeries(player.id).slice(-WEEK_XP_LOG_WINDOW);
    return { xp, xpGoal, boost, percent, score, xpSeries:series, focus:plan.focus, intensity:plan.intens, intensityValue };
  }
  function createPlayerCard(player, type, squadKey, plan, progress){
    const card=el('article',{class:`player-card${player.injury?' injured':''}`});
    const header=el('div',{class:'player-card-header'});
    const title=el('div',{class:'player-card-title'});
    let statusIcon='';
    if(player.injury) statusIcon='🩹';
    else if(player.status?.hot>0) statusIcon='🔥';
    else if(player.status?.slump>0) statusIcon='❄️';
    const nameBtn=el('button',{class:'player-name-button', html:`${statusIcon} ${player.name}`});
    nameBtn.onclick=()=>showPlayerDetailModal(player.id, tid);
    title.append(nameBtn);
    if(player.recentGains && player.recentGains.length>0){
      const statGain=player.recentGains.find(g=>/^[A-Za-z]+\+\d+$/.test(g));
      if(statGain){
        const [stat,val]=statGain.split('+');
        title.append(el('span',{class:'pill', style:'font-size:9px; padding:1px 4px; background:var(--good); color:#fff; border:none; font-weight:700; align-self:flex-start;'}, `${stat.slice(0,3)} +${val}`));
      }
    }
    header.append(title);
    const roleText= type==='BAT' ? (player.pos||'') : (player.role==='SP'?'SP':(player.sub_role||player.role||''));
    if(roleText){ header.append(el('span',{class:'player-card-role'}, roleText)); }
    card.append(header);

    const meta=el('div',{class:'player-card-meta'});
    const prevHistory=State.historicalStats?.[prevSeason]?.[player.id]?.history||{};
    const sparkWrap=el('div',{class:'sparkline-pair'});
    if(player.history?.morale){ sparkWrap.append(createSparklineItem('士気', player.history.morale, 'var(--accent)', prevHistory.morale)); }
    if(player.history?.fatigue){ sparkWrap.append(createSparklineItem('疲労', player.history.fatigue, 'var(--warn)', prevHistory.fatigue)); }
    if(sparkWrap.children.length>0) meta.append(sparkWrap);
    meta.append(el('span',{class:'boost-chip'},`実戦補正 ${boostTxt(player.id)}`));
    const fatigueBadge=createConditionBadge('fatigue', player.fatigue);
    const moraleBadge=createConditionBadge('morale', player.morale);
    if(fatigueBadge) meta.append(fatigueBadge);
    if(moraleBadge) meta.append(moraleBadge);
    card.append(meta);

    const controlsRow=el('div',{class:'player-card-controls'});
    const squadCurrent=squadKey==='ichi'?'一軍':'二軍';
    const squadSel=squadSelect(tid, player.id, squadCurrent);
    squadSel.style.width='100%';
    const focusSel=focusSelect(player.id, type==='PIT', plan.focus);
    const intensSel=intensSelect(player.id, plan.intens);
    const squadId=`squad-${player.id}`;
    const focusId=`focus-${player.id}`;
    const intensId=`intens-${player.id}`;
    controlsRow.append(
      createControl('所属', squadSel, squadId),
      createControl('焦点', focusSel, focusId),
      createControl('強度', intensSel, intensId)
    );
    card.append(controlsRow);

    if(allowed){
      focusSel.onchange=()=>{ plan.focus=focusSel.value; State.trainingPlans[tid]=tp; save(); rebuildSections(); };
      intensSel.onchange=()=>{ plan.intens=intensSel.value; State.trainingPlans[tid]=tp; save(); rebuildSections(); };
    }

    const progressBlock=el('div',{class:'training-progress-block'});
    const headerLine=el('div',{class:'training-progress-header'});
    headerLine.append(el('span',{},`進捗 ${progress.percent}%`), el('span',{},`XP ${progress.xp}/${progress.xpGoal}`));
    progressBlock.append(headerLine);
    progressBlock.append(el('div',{class:'training-progress-bar'}, el('span',{style:`width:${progress.percent}%`})));
    const metaLine=el('div',{class:'training-progress-meta'});
    metaLine.append(
      el('span',{},`焦点 ${plan.focus}`),
      el('span',{},`強度 ${plan.intens}`),
      el('span',{},`実戦補正 +${Math.round((progress.boost-1)*100)}%`)
    );
    progressBlock.append(metaLine);
    const xpSeries=progress.xpSeries.length>=2?progress.xpSeries:(progress.xpSeries.length===1?[progress.xpSeries[0],progress.xpSeries[0]]:[]);
    if(xpSeries.length>=2){
      progressBlock.append(el('div',{class:'training-progress-spark'}, el('span',{},'最近XP'), createSparklineSVG(xpSeries,'var(--primary)',140,32)));
    }
    card.append(progressBlock);

    const actions=el('div',{class:'player-card-actions'});
    const detailBtn=el('button',{class:'ghost'}, el('i',{'data-lucide':'user-round'}),'詳細');
    detailBtn.onclick=()=>showPlayerDetailModal(player.id, tid);
    const trainBtn=el('button',{class:'ghost'}, el('i',{'data-lucide':'flame'}),'特訓(5)');
    if(!allowed || player.injury){
      trainBtn.disabled=true;
      trainBtn.title= player.injury ? '怪我のため不可' : '自チーム以外は操作できません';
    }else{
      trainBtn.onclick=()=>{ if((State.teamMeta[tid]?.dp||0) < 5){ console.error('DevP不足'); return; } doSpecialTraining(tid, player.id); };
    }
    actions.append(detailBtn, trainBtn);
    card.append(actions);

    return card;
  }
  function passesFilters(player, type, squadKey, plan){
    if(filters.role==='BAT' && type!=='BAT') return false;
    if(filters.role==='PIT' && type!=='PIT') return false;
    if(filters.squad!=='all' && filters.squad!==squadKey) return false;
    if(filters.focus!=='all' && plan.focus!==filters.focus) return false;
    const morale=player.morale??60;
    const fatigue=player.fatigue??0;
    if(filters.moraleMax<100 && morale>filters.moraleMax) return false;
    if(filters.fatigueMin>0 && fatigue<filters.fatigueMin) return false;
    return true;
  }
  const intensityOrder={ '軽':0,'標準':1,'強':2 };
  function compareEntries(a,b){
    const mode=filters.sort||'name';
    if(mode==='progress'){
      if(b.progress.score!==a.progress.score) return b.progress.score-a.progress.score;
    }else if(mode==='focus'){
      const cmp=a.plan.focus.localeCompare(b.plan.focus,'ja');
      if(cmp!==0) return cmp;
    }else if(mode==='intensity'){
      const diff=(intensityOrder[b.plan.intens]??0)-(intensityOrder[a.plan.intens]??0);
      if(diff!==0) return diff;
    }
    return a.player.name.localeCompare(b.player.name,'ja');
  }
  function prepareEntries(players, type, squadKey){
    const entries=[];
    players.forEach(player=>{
      const plan=ensurePlan(player, type);
      if(!passesFilters(player, type, squadKey, plan)) return;
      const progress=computeProgress(player, plan);
      entries.push({ player, type, plan, progress });
    });
    entries.sort(compareEntries);
    return entries;
  }
  function createRoleGroup(label, entries, squadKey, roleKey, roleState){
    const group=el('details',{class:'training-role-group'});
    group.dataset.role=roleKey;
    const stateKey=`${squadKey}:${roleKey}`;
    const previous=roleState?.get(stateKey);
    group.open=previous!==undefined?previous:entries.length>0;
    const summary=el('summary',{},
      el('span',{},label),
      el('span',{class:'mini'},`${entries.length}人`),
      el('span',{class:'summary-icon'}, el('i',{'data-lucide':'chevron-down'}))
    );
    group.append(summary);
    if(entries.length===0){
      group.append(el('div',{class:'training-empty'},`フィルターに一致する${label}がいません。`));
    }else{
      const grid=el('div',{class:'player-card-grid'});
      entries.forEach(entry=>{ grid.append(createPlayerCard(entry.player, entry.type, squadKey, entry.plan, entry.progress)); });
      group.append(grid);
    }
    return group;
  }
  const filterBar=el('div',{class:'training-filter-bar'});
  const disabledHint='自チーム以外は閲覧のみです（コミッショナーモードで可）';
  function persistFilters(){ save(); rebuildSections(); }
  const roleSelect=el('select',{});
  [['all','全て'],['BAT','野手'],['PIT','投手']].forEach(([value,text])=>{
    roleSelect.append(el('option',{value, selected:filters.role===value},text));
  });
  if(allowed){ roleSelect.onchange=()=>{ filters.role=roleSelect.value; persistFilters(); }; } else { roleSelect.disabled=true; roleSelect.title=disabledHint; }
  const squadFilter=el('select',{});
  [['all','全て'],['ichi','一軍'],['ni','二軍']].forEach(([value,text])=>{
    squadFilter.append(el('option',{value, selected:filters.squad===value},text));
  });
  if(allowed){ squadFilter.onchange=()=>{ filters.squad=squadFilter.value; persistFilters(); }; } else { squadFilter.disabled=true; squadFilter.title=disabledHint; }
  const focusFilter=el('select',{});
  focusFilter.append(el('option',{value:'all', selected:filters.focus==='all'},'全て'));
  focusOptions.forEach(opt=>{ focusFilter.append(el('option',{value:opt, selected:filters.focus===opt}, opt)); });
  if(allowed){ focusFilter.onchange=()=>{ filters.focus=focusFilter.value; persistFilters(); }; } else { focusFilter.disabled=true; focusFilter.title=disabledHint; }
  const moraleInput=el('input',{type:'number', min:0, max:100, step:5, value:filters.moraleMax});
  moraleInput.placeholder='100';
  if(allowed){ moraleInput.onchange=()=>{ const val=parseInt(moraleInput.value,10); filters.moraleMax=Number.isFinite(val)?clamp(val,0,100):100; moraleInput.value=filters.moraleMax; persistFilters(); }; } else { moraleInput.disabled=true; moraleInput.title=disabledHint; }
  const fatigueInput=el('input',{type:'number', min:0, max:100, step:5, value:filters.fatigueMin});
  fatigueInput.placeholder='0';
  if(allowed){ fatigueInput.onchange=()=>{ const val=parseInt(fatigueInput.value,10); filters.fatigueMin=Number.isFinite(val)?clamp(val,0,100):0; fatigueInput.value=filters.fatigueMin; persistFilters(); }; } else { fatigueInput.disabled=true; fatigueInput.title=disabledHint; }
  const sortSelect=el('select',{});
  [['name','名前順'],['focus','焦点順'],['intensity','強度順'],['progress','進捗順']].forEach(([value,text])=>{
    sortSelect.append(el('option',{value, selected:filters.sort===value},text));
  });
  if(allowed){ sortSelect.onchange=()=>{ filters.sort=sortSelect.value; persistFilters(); }; } else { sortSelect.disabled=true; sortSelect.title=disabledHint; }
  filterBar.append(
    createFilterControl('役割', roleSelect),
    createFilterControl('所属', squadFilter),
    createFilterControl('焦点', focusFilter),
    createFilterControl('士気≦', moraleInput),
    createFilterControl('疲労≧', fatigueInput),
    createFilterControl('並び替え', sortSelect)
  );

  const sections=el('div',{class:'training-sections'});
  function rebuildSections(){
    const sectionState=new Map();
    const roleState=new Map();
    sections.querySelectorAll('.training-section').forEach(section=>{
      const key=section.dataset.key;
      sectionState.set(key, section.open);
      section.querySelectorAll('.training-role-group').forEach(group=>{
        roleState.set(`${key}:${group.dataset.role}`, group.open);
      });
    });
    sections.innerHTML='';
    [
      { key:'ichi', label:'一軍' },
      { key:'ni', label:'二軍' }
    ].forEach(cfg=>{
      const baseBats=grouped[cfg.key].bats;
      const basePits=grouped[cfg.key].pits;
      const batEntries=prepareEntries(baseBats, 'BAT', cfg.key);
      const pitEntries=prepareEntries(basePits, 'PIT', cfg.key);
      const baseTotal=baseBats.length+basePits.length;
      const filteredTotal=batEntries.length+pitEntries.length;
      const section=el('details',{class:'training-section'});
      section.dataset.key=cfg.key;
      section.open=sectionState.has(cfg.key)?sectionState.get(cfg.key):(cfg.key==='ichi');
      const summary=el('summary',{},
        el('span',{},cfg.label),
        el('span',{class:'mini'},`${filteredTotal}/${baseTotal}人`),
        el('span',{class:'summary-icon'}, el('i',{'data-lucide':'chevron-down'}))
      );
      section.append(summary);
      const body=el('div',{class:'training-section-body'});
      body.append(
        createRoleGroup('野手', batEntries, cfg.key, 'bats', roleState),
        createRoleGroup('投手', pitEntries, cfg.key, 'pits', roleState)
      );
      section.append(body);
      sections.append(section);
    });
    setTimeout(refreshIcons,0);
  }

  rebuildSections();

  frag.append(topBar, policyContainer, filterBar, sections, el("div",{class:"mini",style:"margin-top:8px;"}, "実戦補正 = 出場数に応じ最大+20%（1軍は1試合=+4pt換算 / 2軍は週あたり+12pt換算）"));
  return frag;
}


function renderReportView(){ const frag=document.createDocumentFragment();
  // Summary box
  const box=el("div",{class:"controls",style:"margin-bottom:8px;gap:16px;flex-wrap:wrap;"});
  const topGainers=collectTopGainers(12); // last ~100 logs already
  box.append(el("span",{class:"pill"},`直近の育成イベント: ${topGainers.events}`), el("span",{class:"pill"},`直近の伸び最大: ${topGainers.max}`));
  frag.append(box);
  const tbl=el("table",{}, el("thead",{}, el("tr",{}, el("th",{},"ログ（最新100件）"))), el("tbody"));
  (State.devLogs||[]).slice(-100).toReversed().forEach(m=> tbl.lastChild.append(el("tr",{}, el("td",{style:"font-size:13px;text-align:left;white-space:normal;"}, m))));
  frag.append(el("div",{class:"table-scroll"},tbl));
  return frag;
}
function collectTopGainers(n){ const arr=(State.devLogs||[]).slice(-150); let events=0, maxGain="-"; for(const s of arr){ if(s.includes("特訓")||s.includes("開眼")||s.includes("フォーム崩れ")) events++; const m=s.match(/([A-Za-zぁ-んァ-ン一-龥々]+)(\+\d+)/); if(m){ if(maxGain==="-"|| parseInt(m[2].slice(1))>parseInt(maxGain.slice(1))) maxGain=m[2]; } } return {events, max:maxGain}; }

// ====== Stats View (Enhanced) ======
function ensureStatsViewState(tid){
  if(!State.ui) State.ui={};
  if(!State.ui.statsView) State.ui.statsView={};
  if(!State.ui.statsView[tid]){
    State.ui.statsView[tid]={ tab:'overview', period:'total', selected:[null,null] };
  }
  const view=State.ui.statsView[tid];
  view.tab=view.tab||'overview';
  view.period=view.period||'total';
  if(!Array.isArray(view.selected)) view.selected=[null,null];
  view.selected=view.selected.slice(0,2);
  while(view.selected.length<2) view.selected.push(null);
  if(view.selected[0] && view.selected[1] && view.selected[0]===view.selected[1]) view.selected[1]=null;
  return view;
}

function filterLogsByPeriod(logs, period){
  if(!Array.isArray(logs) || logs.length===0) return [];
  if(period==='recent') return logs.slice(-10);
  if(period==='month'){
    const currDay=State.curr_day||1;
    const currentMonth=Math.floor((currDay-1)/30);
    return logs.filter(log=>{
      if(!log || typeof log.day!=='number') return false;
      return Math.floor((log.day-1)/30)===currentMonth;
    });
  }
  return logs;
}

function ipToOuts(ip){
  if(!Number.isFinite(ip)) return 0;
  const whole=Math.trunc(ip);
  const decimal=Math.round((ip-whole)*10);
  return whole*3 + Math.max(0, Math.min(2, decimal));
}

function outsToIP(outs){
  if(!Number.isFinite(outs) || outs<=0) return 0;
  const whole=Math.floor(outs/3);
  const remainder=outs%3;
  return whole + remainder/10;
}

function aggregateBatterLogs(logs){
  const totals={ games:0, ab:0, h:0, hr:0, bb:0, so:0, r:0, rbi:0 };
  if(!Array.isArray(logs)) return { ...totals, pa:0 };
  for(const log of logs){
    if(!log) continue;
    totals.games++;
    totals.ab += log.AB||0;
    totals.h += log.H||0;
    totals.hr += log.HR||0;
    totals.bb += log.BB||0;
    totals.so += log.SO||0;
    totals.r += log.R||0;
    totals.rbi += log.RBI||0;
  }
  totals.pa=totals.ab+totals.bb;
  return totals;
}

function aggregatePitcherLogs(logs){
  const totals={ games:0, outs:0, er:0, hr:0, bb:0, so:0, h:0, wins:0, losses:0, saves:0 };
  if(!Array.isArray(logs)) return { ...totals, ip:0 };
  for(const log of logs){
    if(!log) continue;
    totals.games++;
    totals.outs += ipToOuts(log.IP||0);
    totals.er += log.ER||0;
    totals.hr += log.HR||0;
    totals.bb += log.BB||0;
    totals.so += log.SO||0;
    totals.h += log.H||0;
    totals.wins += log.W||0;
    totals.losses += log.L||0;
    totals.saves += log.SV||0;
  }
  totals.ip=outsToIP(totals.outs);
  return totals;
}

function computeBatterRates(totals){
  const singles=Math.max(0,(totals.h||0)-(totals.hr||0));
  const obpDen=(totals.ab||0)+(totals.bb||0);
  const obp=obpDen>0?((totals.h||0)+(totals.bb||0))/obpDen:0;
  const slgDen=totals.ab||0;
  const slg=slgDen>0?(singles+(totals.hr||0)*4)/slgDen:0;
  const ops=obp+slg;
  const avgDen=totals.ab||0;
  const avg=avgDen>0?(totals.h||0)/avgDen:0;
  return { avg, obp, slg, ops };
}

function ensureLeagueMetrics(){
  if(!State.cachedMetrics) State.cachedMetrics={};
  const key=`season-${State.season||1}`;
  const day=State.curr_day||1;
  const resultCount=(State.results||[]).length;
  const cached=State.cachedMetrics[key];
  if(cached && cached.day===day && cached.resultCount===resultCount) return cached;
  let batNumer=0, batDenom=0, batPA=0, totalRuns=0;
  let leagueHR=0, leagueBB=0, leagueSO=0, leagueOuts=0, leagueER=0, leagueHits=0;
  const logsObj=State.playerGameLogs||{};
  for(const logs of Object.values(logsObj)){
    if(!Array.isArray(logs)) continue;
    for(const log of logs){
      if(!log) continue;
      const ab=log.AB||0;
      const h=log.H||0;
      const hr=log.HR||0;
      const bb=log.BB||0;
      const singles=Math.max(0,h-hr);
      const pa=ab+bb;
      batNumer += 0.69*bb + 0.89*singles + 2.1*hr;
      batDenom += pa;
      batPA += pa;
      totalRuns += log.R||0;
      if(log.IP!=null || log.ER!=null){
        leagueOuts += ipToOuts(log.IP||0);
        leagueER += log.ER||0;
        leagueHits += log.H||0;
        leagueHR += log.HR||0;
        leagueBB += log.BB||0;
        leagueSO += log.SO||0;
      }
    }
  }
  if(totalRuns<=0){
    totalRuns=(State.results||[]).reduce((sum,res)=>sum+(res.home_runs||0)+(res.away_runs||0),0);
  }
  const leagueWoba=batDenom>0?batNumer/batDenom:0;
  const runsPerPA=batPA>0?totalRuns/batPA:0.12;
  const ip=leagueOuts/3;
  const leagueERA=ip>0?(leagueER*9)/ip:0;
  const denom=ip>0?ip:1;
  const fipConst=denom>0?leagueERA-((13*leagueHR+3*leagueBB-2*leagueSO)/denom):0;
  const metrics={
    day,
    resultCount,
    batting:{ woba:leagueWoba, wobaScale:1.15, runsPerPA:runsPerPA||0.12 },
    pitching:{ fipConst, era:leagueERA }
  };
  State.cachedMetrics[key]=metrics;
  return metrics;
}

function computeAdvancedBattingMetrics(totals, league){
  const rates=computeBatterRates(totals);
  const singles=Math.max(0,(totals.h||0)-(totals.hr||0));
  const numerator=0.69*(totals.bb||0)+0.89*singles+2.1*(totals.hr||0);
  const denom=totals.pa||0;
  const woba=denom>0?numerator/denom:0;
  const leagueRef=league||{ woba:0, wobaScale:1.15, runsPerPA:0.12 };
  const wobaScale=leagueRef.wobaScale||1.15;
  const leagueRuns=leagueRef.runsPerPA>0?leagueRef.runsPerPA:0.12;
  const wRCPlus=leagueRuns>0?(((woba-(leagueRef.woba||0))/wobaScale)+leagueRuns)/leagueRuns*100:0;
  return { ...rates, woba, wrcPlus:Number.isFinite(wRCPlus)?wRCPlus:0 };
}

function computeAdvancedPitchingMetrics(totals, league){
  const ip=totals.outs/3;
  const era=ip>0?(totals.er*9)/ip:null;
  const whip=ip>0?((totals.bb+totals.h)/ip):null;
  const fip=ip>0?((13*totals.hr+3*totals.bb-2*totals.so)/ip)+((league&&league.fipConst)||0):null;
  const kbb=totals.bb>0?totals.so/totals.bb:(totals.so>0?Infinity:null);
  const k9=ip>0?(totals.so*9)/ip:null;
  const bb9=ip>0?(totals.bb*9)/ip:null;
  return { era, whip, fip, kbb, k9, bb9, ip, games:totals.games, wins:totals.wins, losses:totals.losses, saves:totals.saves };
}

function computeRollingSeries(logs, windowSize, reducer){
  if(!Array.isArray(logs) || logs.length===0) return { series:[], labels:[] };
  const series=[], labels=[];
  for(let i=0;i<logs.length;i++){
    const slice=logs.slice(Math.max(0,i-windowSize+1), i+1);
    const value=reducer(slice);
    series.push(Number.isFinite(value)?value:0);
    const day=logs[i]?.day;
    labels.push(day!=null?`Day ${day}`:`#${i+1}`);
  }
  return { series, labels };
}

function createSparklineWithTooltip(data, labels, color, width=160, height=32, formatter=(v)=>v.toFixed(2)){
  if(!Array.isArray(data) || data.length<2) return el('span',{class:'mini', style:'color:var(--text-secondary);'},'データ不足');
  const valid=data.map(v=>Number.isFinite(v)?v:0);
  const wrap=el('div',{class:'sparkline-hover'});
  const svg=createSparklineSVG(valid, color, width, height);
  const tooltip=el('div',{class:'sparkline-tooltip'});
  wrap.append(svg, tooltip);
  attachSparklineTooltip(wrap, valid, labels, formatter);
  return wrap;
}

function attachSparklineTooltip(wrapper, data, labels, formatter){
  const tooltip=wrapper.querySelector('.sparkline-tooltip');
  if(!tooltip) return;
  wrapper.addEventListener('mousemove',ev=>{
    const rect=wrapper.getBoundingClientRect();
    if(rect.width<=0) return;
    let ratio=(ev.clientX-rect.left)/rect.width;
    ratio=Math.max(0, Math.min(1, ratio));
    const idx=Math.min(data.length-1, Math.round(ratio*(data.length-1)));
    const label=labels && labels[idx]?labels[idx]:`#${idx+1}`;
    tooltip.textContent=`${label}: ${formatter(data[idx])}`;
    tooltip.style.left=`${ratio*100}%`;
    tooltip.style.opacity=1;
  });
  wrapper.addEventListener('mouseleave',()=>{ tooltip.style.opacity=0; });
}

function resolvePitcherHand(entry, tid){
  if(!entry) return null;
  const player=findPlayerById(tid, entry.id);
  return player?.hand||null;
}

function computeLineupHandRatio(list, tid){
  if(!Array.isArray(list) || !tid) return 0.5;
  let left=0,total=0;
  for(const entry of list){
    const player=findPlayerById(tid, entry?.id);
    const hand=player?.hand||'R';
    if(hand==='L') left++;
    total++;
  }
  if(total===0) return 0.5;
  return left/total;
}

function buildGameMetaMap(){
  const map=new Map();
  const results=State.results||[];
  for(const res of results){
    if(!res) continue;
    const detail=res.detailed||null;
    const homeLineup=detail?.lineups?.away;
    const awayLineup=detail?.lineups?.home;
    map.set(`${res.day}-${res.home_id}`,{
      location:'home',
      opponentId:res.away_id,
      starterHand:resolvePitcherHand(homeLineup?.pitchers?.[0], res.away_id),
      lineupHandRatio:computeLineupHandRatio(homeLineup?.batting, res.away_id)
    });
    map.set(`${res.day}-${res.away_id}`,{
      location:'away',
      opponentId:res.home_id,
      starterHand:resolvePitcherHand(awayLineup?.pitchers?.[0], res.home_id),
      lineupHandRatio:computeLineupHandRatio(awayLineup?.batting, res.home_id)
    });
  }
  return map;
}

function accumulateBatterSplit(target, entry){
  target.games=(target.games||0)+1;
  target.ab=(target.ab||0)+entry.ab;
  target.h=(target.h||0)+entry.h;
  target.hr=(target.hr||0)+entry.hr;
  target.bb=(target.bb||0)+entry.bb;
}

function computeBatterSplits(logs, metaMap, tid){
  const makeSplit=()=>({ games:0, ab:0, h:0, hr:0, bb:0, pa:0 });
  const splits={ vsLeft:makeSplit(), vsRight:makeSplit(), home:makeSplit(), away:makeSplit() };
  if(!Array.isArray(logs)) return splits;
  for(const log of logs){
    if(!log) continue;
    const meta=metaMap.get(`${log.day}-${tid}`);
    if(!meta) continue;
    const entry={ ab:log.AB||0, h:log.H||0, hr:log.HR||0, bb:log.BB||0 };
    if(meta.starterHand){
      const key=meta.starterHand==='L'?'vsLeft':'vsRight';
      accumulateBatterSplit(splits[key], entry);
    }
    const locKey=meta.location==='home'?'home':'away';
    accumulateBatterSplit(splits[locKey], entry);
  }
  const result={};
  Object.entries(splits).forEach(([key,tot])=>{
    tot.pa=(tot.ab||0)+(tot.bb||0);
    const rates=computeBatterRates({ ...tot, pa:tot.pa, games:tot.games, hr:tot.hr, h:tot.h, bb:tot.bb, ab:tot.ab, so:0, r:0, rbi:0 });
    result[key]={ totals:tot, metrics:rates };
  });
  return result;
}

function accumulatePitcherSplit(target, entry){
  target.games=(target.games||0)+1;
  target.outs=(target.outs||0)+entry.outs;
  target.er=(target.er||0)+entry.er;
  target.hr=(target.hr||0)+entry.hr;
  target.bb=(target.bb||0)+entry.bb;
  target.so=(target.so||0)+entry.so;
  target.h=(target.h||0)+entry.h;
}

function computePitcherSplits(logs, metaMap, tid, league){
  const makeSplit=()=>({ games:0, outs:0, er:0, hr:0, bb:0, so:0, h:0 });
  const splits={ vsLeft:makeSplit(), vsRight:makeSplit(), home:makeSplit(), away:makeSplit() };
  if(!Array.isArray(logs)) return splits;
  const leagueRef=league||ensureLeagueMetrics().pitching;
  for(const log of logs){
    if(!log) continue;
    const meta=metaMap.get(`${log.day}-${tid}`);
    if(!meta) continue;
    const entry={ outs:ipToOuts(log.IP||0), er:log.ER||0, hr:log.HR||0, bb:log.BB||0, so:log.SO||0, h:log.H||0 };
    const vsKey=(meta.lineupHandRatio||0.5)>=0.5?'vsLeft':'vsRight';
    accumulatePitcherSplit(splits[vsKey], entry);
    const locKey=meta.location==='home'?'home':'away';
    accumulatePitcherSplit(splits[locKey], entry);
  }
  const result={};
  Object.entries(splits).forEach(([key,tot])=>{
    const totals={ outs:tot.outs, er:tot.er, hr:tot.hr, bb:tot.bb, so:tot.so, h:tot.h, games:tot.games, wins:0, losses:0, saves:0 };
    result[key]={ totals:tot, metrics:computeAdvancedPitchingMetrics(totals, leagueRef) };
  });
  return result;
}

function formatAverage(value){
  if(!Number.isFinite(value) || value<0) return '.---';
  return value.toFixed(3).substring(1);
}

function formatRate(value){
  if(!Number.isFinite(value)) return '-';
  return value.toFixed(3);
}

function formatNumber(value, decimals=1){
  if(!Number.isFinite(value)) return '-';
  return value.toFixed(decimals);
}

function formatERA(value){
  if(!Number.isFinite(value)) return '-.--';
  return value.toFixed(2);
}

function formatSignedNumber(value, decimals=1){
  if(!Number.isFinite(value)) return '-';
  const fixed=value.toFixed(decimals);
  if(Number(fixed)===0) return decimals>0?`0.${'0'.repeat(decimals)}`:'0';
  return value>0?`+${fixed}`:fixed;
}

function createStatsTableWrapper(icon, title, table){
  const wrapper=el('div',{class:'stats-table-wrapper'});
  wrapper.append(el('div',{class:'table-header'}, el('i',{ 'data-lucide':icon, class:'mini-icon'}), title));
  const body=el('div',{class:'table-body'});
  body.append(table);
  wrapper.append(body);
  return wrapper;
}

function renderStatsView(tid){
  const frag=document.createDocumentFragment();
  const roster=State.rosters[tid]||{ bats:[], pits:[] };
  const viewState=ensureStatsViewState(tid);
  const leagueMetrics=ensureLeagueMetrics();
  const gameMeta=buildGameMetaMap();
  const tabConfigs=[
    { key:'overview', label:'概要', icon:'layout-dashboard' },
    { key:'trend', label:'トレンド', icon:'activity' },
    { key:'advanced', label:'高度指標', icon:'radar' },
    { key:'compare', label:'比較', icon:'users' }
  ];
  const tabBar=el('div',{class:'stats-tab-bar'});
  const tabButtons=new Map();
  tabConfigs.forEach(cfg=>{
    const btn=el('button',{class:`stats-tab ${viewState.tab===cfg.key?'active':''}`, 'data-tab':cfg.key}, el('i',{ 'data-lucide':cfg.icon, class:'mini-icon'}), cfg.label);
    btn.onclick=()=>{
      if(viewState.tab===cfg.key) return;
      viewState.tab=cfg.key;
      State.ui.statsView[tid]=viewState;
      save();
      setActiveTab(cfg.key);
    };
    tabButtons.set(cfg.key, btn);
    tabBar.append(btn);
  });

  const panels={
    overview:el('div',{class:'stats-panel'}),
    trend:el('div',{class:'stats-panel'}),
    advanced:el('div',{class:'stats-panel'}),
    compare:el('div',{class:'stats-panel'})
  };
  const panelHost=el('div',{class:'stats-panels'}, panels.overview, panels.trend, panels.advanced, panels.compare);
  frag.append(tabBar, panelHost);

  const renderers={
    overview:()=>{
      const panel=panels.overview;
      panel.innerHTML='';
      const periods={ total:'シーズン累計', recent:'直近10試合', month:'月間' };
      const periodBar=el('div',{class:'stats-period-filter'});
      periodBar.append(el('span',{class:'mini'},'期間選択'));
      Object.entries(periods).forEach(([key,label])=>{
        const btn=el('button',{class:viewState.period===key?'active':''},label);
        btn.onclick=()=>{
          if(viewState.period===key) return;
          viewState.period=key;
          State.ui.statsView[tid]=viewState;
          save();
          renderers.overview();
        };
        periodBar.append(btn);
      });
      panel.append(periodBar);

      const batterRows=roster.bats.map(player=>{
        const logs=filterLogsByPeriod(State.playerGameLogs[player.id]||[], viewState.period);
        const totals=aggregateBatterLogs(logs);
        const rates=computeBatterRates(totals);
        return { player, totals, rates };
      }).sort((a,b)=> (b.totals.pa||0)-(a.totals.pa||0) || a.player.name.localeCompare(b.player.name));

      const batTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'G'),
          el('th',{},'打率'),
          el('th',{class:'col-secondary'},'HR'),
          el('th',{class:'col-secondary'},'打点'),
          el('th',{},'OPS')
        )),
        el('tbody')
      );
      batterRows.forEach(row=>{
        const { player, totals, rates }=row;
        const AVG=totals.ab>0?formatAverage(rates.avg):'.---';
        const OPS=totals.pa>0?formatRate(rates.ops):'-';
        batTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, totals.games||0),
          el('td',{}, AVG),
          el('td',{class:'col-secondary'}, totals.hr||0),
          el('td',{class:'col-secondary'}, totals.rbi||0),
          el('td',{}, OPS)
        ));
      });
      panel.append(createStatsTableWrapper('users','野手概要', batTable));

      const pitcherRows=roster.pits.map(player=>{
        const logs=filterLogsByPeriod(State.playerGameLogs[player.id]||[], viewState.period);
        const totals=aggregatePitcherLogs(logs);
        const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
        return { player, totals, metrics };
      }).sort((a,b)=> (b.totals.outs||0)-(a.totals.outs||0) || a.player.name.localeCompare(b.player.name));

      const pitTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'W-L-SV'),
          el('th',{},'G'),
          el('th',{},'IP'),
          el('th',{},'ERA'),
          el('th',{class:'col-secondary'},'K/BB')
        )),
        el('tbody')
      );
      pitcherRows.forEach(row=>{
        const { player, totals, metrics }=row;
        const ip=totals.ip?totals.ip.toFixed(1):'0.0';
        const era=(metrics.era!=null)?formatERA(metrics.era):'-.--';
        let kbb='0.00';
        if(metrics.kbb===Infinity) kbb='∞';
        else if(metrics.kbb!=null) kbb=formatNumber(metrics.kbb,2);
        pitTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{},`${totals.wins||0}-${totals.losses||0}-${totals.saves||0}`),
          el('td',{}, totals.games||0),
          el('td',{}, ip),
          el('td',{}, era),
          el('td',{class:'col-secondary'}, kbb)
        ));
      });
      panel.append(createStatsTableWrapper('flame','投手概要', pitTable));
      setTimeout(refreshIcons,0);
    },
    trend:()=>{
      const panel=panels.trend;
      panel.innerHTML='';
      const batterSectionTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'activity', class:'mini-icon'}),'野手トレンド');
      panel.append(batterSectionTitle);
      const batterGrid=el('div',{class:'stats-trend-grid'});
      let batterCount=0;
      roster.bats.forEach(player=>{
        const logs=(State.playerGameLogs[player.id]||[]).slice();
        if(logs.length<3) return;
        const totals=aggregateBatterLogs(logs);
        if((totals.pa||0)<12) return;
        const { series, labels }=computeRollingSeries(logs,7, slice=>{
          const t=aggregateBatterLogs(slice);
          return t.ab>0?(t.h||0)/(t.ab||1):0;
        });
        if(series.length<2) return;
        batterCount++;
        const latest=series[series.length-1];
        const card=el('div',{class:'stats-trend-card'});
        card.append(el('h4',{}, el('i',{ 'data-lucide':'user', class:'mini-icon'}), player.name));
        card.append(el('div',{class:'trend-meta'},
          el('span',{},`最新AVG ${formatAverage(latest)}`),
          el('span',{},`試合 ${logs.length}`)
        ));
        card.append(createSparklineWithTooltip(series, labels, 'var(--primary)', 180, 36, val=>`AVG ${formatAverage(val)}`));
        batterGrid.append(card);
      });
      if(batterCount===0) batterGrid.append(el('div',{class:'stats-empty'},'打者のトレンドデータが不足しています。'));
      panel.append(batterGrid);

      const pitcherSectionTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'trending-up', class:'mini-icon'}),'投手トレンド');
      panel.append(pitcherSectionTitle);
      const pitcherGrid=el('div',{class:'stats-trend-grid'});
      let pitcherCount=0;
      roster.pits.forEach(player=>{
        const logs=(State.playerGameLogs[player.id]||[]).slice();
        if(logs.length<2) return;
        const totals=aggregatePitcherLogs(logs);
        if((totals.outs||0)<9) return;
        const { series, labels }=computeRollingSeries(logs,5, slice=>{
          const t=aggregatePitcherLogs(slice);
          return t.outs>0?(t.er*9)/(t.outs/3):0;
        });
        if(series.length<2) return;
        pitcherCount++;
        const latest=series[series.length-1];
        const card=el('div',{class:'stats-trend-card'});
        card.append(el('h4',{}, el('i',{ 'data-lucide':'shield', class:'mini-icon'}), player.name));
        card.append(el('div',{class:'trend-meta'},
          el('span',{},`最新ERA ${formatERA(latest)}`),
          el('span',{},`登板 ${logs.length}`)
        ));
        card.append(createSparklineWithTooltip(series, labels, 'var(--accent)', 180, 36, val=>`ERA ${formatERA(val)}`));
        pitcherGrid.append(card);
      });
      if(pitcherCount===0) pitcherGrid.append(el('div',{class:'stats-empty'},'投手のトレンドデータが不足しています。'));
      panel.append(pitcherGrid);
      setTimeout(refreshIcons,0);
    },
    advanced:()=>{
      const panel=panels.advanced;
      panel.innerHTML='';
      const batAdvancedTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'sparkles', class:'mini-icon'}),'野手高度指標');
      panel.append(batAdvancedTitle);
      const batTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'PA'),
          el('th',{},'wOBA'),
          el('th',{},'wRC+'),
          el('th',{class:'col-secondary'},'OBP'),
          el('th',{class:'col-secondary'},'SLG')
        )),
        el('tbody')
      );
      roster.bats.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const totals=aggregateBatterLogs(logs);
        if((totals.pa||0)===0) return;
        const metrics=computeAdvancedBattingMetrics(totals, leagueMetrics.batting);
        batTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, totals.pa||0),
          el('td',{}, formatRate(metrics.woba)),
          el('td',{}, formatNumber(metrics.wrcPlus,0)),
          el('td',{class:'col-secondary'}, formatRate(metrics.obp)),
          el('td',{class:'col-secondary'}, formatRate(metrics.slg))
        ));
      });
      if(!batTable.lastChild.hasChildNodes()) batTable.lastChild.append(el('tr',{}, el('td',{colspan:6},'データなし')));
      panel.append(createStatsTableWrapper('bar-chart-3','野手指標まとめ', batTable));

      const pitAdvancedTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'gauge', class:'mini-icon'}),'投手高度指標');
      panel.append(pitAdvancedTitle);
      const pitTable=el('table',{},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'IP'),
          el('th',{},'FIP'),
          el('th',{},'ERA'),
          el('th',{},'WHIP'),
          el('th',{class:'col-secondary'},'K/BB')
        )),
        el('tbody')
      );
      roster.pits.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const totals=aggregatePitcherLogs(logs);
        if((totals.outs||0)===0) return;
        const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
        let kbb='-';
        if(metrics.kbb===Infinity) kbb='∞';
        else if(metrics.kbb!=null) kbb=formatNumber(metrics.kbb,2);
        pitTable.lastChild.append(el('tr',{},
          el('td',{style:'text-align:left;'},player.name),
          el('td',{}, (totals.ip||0).toFixed(1)),
          el('td',{}, metrics.fip!=null?formatERA(metrics.fip):'-.--'),
          el('td',{}, metrics.era!=null?formatERA(metrics.era):'-.--'),
          el('td',{}, metrics.whip!=null?formatRate(metrics.whip):'-'),
          el('td',{class:'col-secondary'}, kbb)
        ));
      });
      if(!pitTable.lastChild.hasChildNodes()) pitTable.lastChild.append(el('tr',{}, el('td',{colspan:6},'データなし')));
      panel.append(createStatsTableWrapper('pie-chart','投手指標まとめ', pitTable));

      const splitTitle=el('div',{class:'stats-section-title'}, el('i',{ 'data-lucide':'grid', class:'mini-icon'}),'スプリット・ヒートマップ');
      panel.append(splitTitle);
      const splitGrid=el('div',{class:'stats-split-grid'});

      const batterSplitTable=el('table',{class:'heatmap-table'},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'vs左'),
          el('th',{},'vs右'),
          el('th',{},'ホーム'),
          el('th',{},'ビジター')
        )),
        el('tbody')
      );
      roster.bats.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const splits=computeBatterSplits(logs, gameMeta, tid);
        const values=['vsLeft','vsRight','home','away'].map(key=>splits[key]?.metrics?.ops||0).filter(v=>v>0);
        const max=Math.max(0,...values);
        const hasData=['vsLeft','vsRight','home','away'].some(key=>(splits[key]?.totals?.pa||0)>0);
        if(!hasData) return;
        const row=el('tr',{});
        row.append(el('th',{style:'text-align:left;'},player.name));
        ['vsLeft','vsRight','home','away'].forEach(key=>{
          const entry=splits[key];
          const ops=entry?.metrics?.ops||0;
          const avg=entry?.metrics?.avg||0;
          const pa=entry?.totals?.pa||0;
          const cell=el('td',{'data-heat':''}, el('div',{}, pa>0?formatRate(ops):'-'), el('div',{class:'mini'},`AVG ${pa>0?formatAverage(avg):'.---'} / PA ${pa}`));
          const heat=max>0?Math.max(0, Math.min(1, ops/max)):0;
          cell.style.setProperty('--heat-level', `${Math.round(heat*100)}%`);
          row.append(cell);
        });
        batterSplitTable.lastChild.append(row);
      });
      if(!batterSplitTable.lastChild.hasChildNodes()) batterSplitTable.lastChild.append(el('tr',{}, el('td',{colspan:5},'データ不足')));
      splitGrid.append(createStatsTableWrapper('table','野手スプリット', batterSplitTable));

      const pitcherSplitTable=el('table',{class:'heatmap-table'},
        el('thead',{}, el('tr',{},
          el('th',{},'選手'),
          el('th',{},'vs左'),
          el('th',{},'vs右'),
          el('th',{},'ホーム'),
          el('th',{},'ビジター')
        )),
        el('tbody')
      );
      roster.pits.forEach(player=>{
        const logs=State.playerGameLogs[player.id]||[];
        const splits=computePitcherSplits(logs, gameMeta, tid, leagueMetrics.pitching);
        const eras=['vsLeft','vsRight','home','away'].map(key=>splits[key]?.metrics?.era).filter(v=>Number.isFinite(v));
        const minEra=eras.length?Math.min(...eras):null;
        const maxEra=eras.length?Math.max(...eras):null;
        const hasData=['vsLeft','vsRight','home','away'].some(key=>(splits[key]?.totals?.outs||0)>0);
        if(!hasData) return;
        const row=el('tr',{});
        row.append(el('th',{style:'text-align:left;'},player.name));
        ['vsLeft','vsRight','home','away'].forEach(key=>{
          const entry=splits[key];
          const era=entry?.metrics?.era;
          const whip=entry?.metrics?.whip;
          const ip=outsToIP(entry?.totals?.outs||0);
          const cell=el('td',{'data-heat':''},
            el('div',{}, era!=null?formatERA(era):'-.--'),
            el('div',{class:'mini'},`WHIP ${whip!=null?formatRate(whip):'-'} / IP ${ip.toFixed(1)}`)
          );
          if(minEra!=null && maxEra!=null && maxEra>minEra){
            const heat=1-((era||maxEra)-minEra)/(maxEra-minEra);
            cell.style.setProperty('--heat-level', `${Math.round(Math.max(0,Math.min(1,heat))*100)}%`);
          } else {
            cell.style.setProperty('--heat-level','50%');
          }
          row.append(cell);
        });
        pitcherSplitTable.lastChild.append(row);
      });
      if(!pitcherSplitTable.lastChild.hasChildNodes()) pitcherSplitTable.lastChild.append(el('tr',{}, el('td',{colspan:5},'データ不足')));
      splitGrid.append(createStatsTableWrapper('table','投手スプリット', pitcherSplitTable));

      panel.append(splitGrid);
      setTimeout(refreshIcons,0);
    },
    compare:()=>{
      const panel=panels.compare;
      panel.innerHTML='';
      const controls=el('div',{class:'stats-compare-controls'});
      const selectA=el('select',{'data-slot':'0'});
      const selectB=el('select',{'data-slot':'1'});
      selectA.append(el('option',{value:''},'選手を選択'));
      selectB.append(el('option',{value:''},'選手を選択'));
      const options=[...roster.bats.map(p=>({ id:p.id, label:`野手 / ${p.name}` })), ...roster.pits.map(p=>({ id:p.id, label:`投手 / ${p.name}` }))];
      options.forEach(opt=>{
        selectA.append(el('option',{value:opt.id}, opt.label));
        selectB.append(el('option',{value:opt.id}, opt.label));
      });
      selectA.value=viewState.selected[0]||'';
      selectB.value=viewState.selected[1]||'';
      function handleChange(e){
        const slot=parseInt(e.target.dataset.slot,10)||0;
        const value=e.target.value||null;
        viewState.selected[slot]=value;
        if(viewState.selected[0] && viewState.selected[0]===viewState.selected[1]){
          const other=slot===0?1:0;
          viewState.selected[other]=null;
        }
        State.ui.statsView[tid]=viewState;
        save();
        renderers.compare();
      }
      selectA.onchange=handleChange;
      selectB.onchange=handleChange;
      controls.append(selectA, selectB);
      panel.append(controls);

      const selectedPlayers=viewState.selected.map(pid=>pid? (roster.bats.find(b=>b.id===pid)||roster.pits.find(p=>p.id===pid)||null) : null).filter(Boolean);
      if(selectedPlayers.length<2){
        panel.append(el('div',{class:'stats-empty'},'比較する選手を2名選択してください。'));
        setTimeout(refreshIcons,0);
        return;
      }
      const grid=el('div',{class:'stats-compare-grid'});
      const cards=[];
      const metricsCache=[];
      selectedPlayers.forEach(player=>{
        const isBatter=roster.bats.some(b=>b.id===player.id);
        if(isBatter){
          const logs=State.playerGameLogs[player.id]||[];
          const totals=aggregateBatterLogs(logs);
          const metrics=computeAdvancedBattingMetrics(totals, leagueMetrics.batting);
          metricsCache.push({ player, type:'BAT', totals, metrics });
          const card=el('div',{class:'stats-compare-card'});
          card.append(el('header',{}, el('h4',{},`${player.name} (${player.pos||'-'})`), el('span',{class:'mini'},'野手')));
          const list=el('div',{class:'stats-compare-metrics'});
          const avgDisplay=totals.ab>0?formatAverage(metrics.avg):'.---';
          list.append(
            el('span',{}, el('strong',{},'AVG'), avgDisplay),
            el('span',{}, el('strong',{},'OPS'), totals.pa>0?formatRate(metrics.ops):'-'),
            el('span',{}, el('strong',{},'HR'), totals.hr||0),
            el('span',{}, el('strong',{},'RBI'), totals.rbi||0),
            el('span',{}, el('strong',{},'wOBA'), totals.pa>0?formatRate(metrics.woba):'-'),
            el('span',{}, el('strong',{},'wRC+'), totals.pa>0?formatNumber(metrics.wrcPlus,0):'-')
          );
          card.append(list);
          cards.push(card);
        } else {
          const logs=State.playerGameLogs[player.id]||[];
          const totals=aggregatePitcherLogs(logs);
          const metrics=computeAdvancedPitchingMetrics(totals, leagueMetrics.pitching);
          metricsCache.push({ player, type:'PIT', totals, metrics });
          const card=el('div',{class:'stats-compare-card'});
          card.append(el('header',{}, el('h4',{},`${player.name} (${player.role||'-'})`), el('span',{class:'mini'},'投手')));
          const list=el('div',{class:'stats-compare-metrics'});
          list.append(
            el('span',{}, el('strong',{},'IP'), (totals.ip||0).toFixed(1)),
            el('span',{}, el('strong',{},'ERA'), metrics.era!=null?formatERA(metrics.era):'-.--'),
            el('span',{}, el('strong',{},'FIP'), metrics.fip!=null?formatERA(metrics.fip):'-.--'),
            el('span',{}, el('strong',{},'WHIP'), metrics.whip!=null?formatRate(metrics.whip):'-'),
            el('span',{}, el('strong',{},'K'), totals.so||0),
            el('span',{}, el('strong',{},'BB'), totals.bb||0)
          );
          cards.push(card);
        }
      });
      cards.forEach(card=>grid.append(card));

      if(metricsCache.length===2 && metricsCache[0].type===metricsCache[1].type){
        const [a,b]=metricsCache;
        const diffCard=el('div',{class:'stats-compare-card'});
        diffCard.append(el('header',{}, el('h4',{},'差分ハイライト'), el('span',{class:'mini'},'選手A - 選手B')));
        const list=el('div',{class:'stats-compare-metrics'});
        if(a.type==='BAT'){
          const paA=a.totals.pa||0;
          const paB=b.totals.pa||0;
          const hasSample=paA>0 && paB>0;
          list.append(
            el('span',{}, el('strong',{},'AVG Δ'), hasSample?formatSignedNumber((a.metrics.avg||0)-(b.metrics.avg||0),3):'-'),
            el('span',{}, el('strong',{},'OPS Δ'), hasSample?formatSignedNumber((a.metrics.ops||0)-(b.metrics.ops||0),3):'-'),
            el('span',{}, el('strong',{},'HR Δ'), formatSignedNumber((a.totals.hr||0)-(b.totals.hr||0),0)),
            el('span',{}, el('strong',{},'wRC+ Δ'), hasSample?formatSignedNumber((a.metrics.wrcPlus||0)-(b.metrics.wrcPlus||0),0):'-')
          );
        } else {
          const outsA=a.totals.outs||0;
          const outsB=b.totals.outs||0;
          const hasSample=outsA>0 && outsB>0;
          const eraDiff=(hasSample && a.metrics.era!=null && b.metrics.era!=null)?formatSignedNumber((a.metrics.era||0)-(b.metrics.era||0),2):'-';
          const fipDiff=(hasSample && a.metrics.fip!=null && b.metrics.fip!=null)?formatSignedNumber((a.metrics.fip||0)-(b.metrics.fip||0),2):'-';
          const whipDiff=(hasSample && a.metrics.whip!=null && b.metrics.whip!=null)?formatSignedNumber((a.metrics.whip||0)-(b.metrics.whip||0),3):'-';
          let kbbDiff='-';
          if(a.metrics.kbb===Infinity || b.metrics.kbb===Infinity){ kbbDiff='∞'; }
          else if(hasSample && a.metrics.kbb!=null && b.metrics.kbb!=null){ kbbDiff=formatSignedNumber((a.metrics.kbb||0)-(b.metrics.kbb||0),2); }
          list.append(
            el('span',{}, el('strong',{},'ERA Δ'), eraDiff),
            el('span',{}, el('strong',{},'FIP Δ'), fipDiff),
            el('span',{}, el('strong',{},'WHIP Δ'), whipDiff),
            el('span',{}, el('strong',{},'K/BB Δ'), kbbDiff)
          );
        }
        diffCard.append(list);
        grid.append(diffCard);
      }

      panel.append(grid);
      setTimeout(refreshIcons,0);
    }
  };

  function setActiveTab(key){
    viewState.tab=key;
    State.ui.statsView[tid]=viewState;
    tabButtons.forEach((btn,tabKey)=>btn.classList.toggle('active', tabKey===key));
    Object.entries(panels).forEach(([panelKey,node])=>{
      if(panelKey===key){
        node.classList.add('active');
        renderers[panelKey]();
      } else {
        node.classList.remove('active');
        node.innerHTML='';
      }
    });
    setTimeout(refreshIcons,0);
  }

  setActiveTab(viewState.tab||'overview');
  return frag;
}


// ====== Draft System (v12) ======
function draftOrderFromStandings(){
  const st = computeStandings(State.teams, State.results||[]);
  if(st && st.length){ return st.slice().sort((a,b)=> a.Pct-b.Pct || a.W-b.W).map(r=>r.team_id); }
  const ids = State.teams.map(t=>t.team_id); const rng=mulberry32(State.seed+999);
  for(let i=ids.length-1;i>0;i--){ const j=Math.floor(rng()*(i+1)); [ids[i],ids[j]]=[ids[j],ids[i]]; }
  return ids;
}
function gradeFromValue(val){ if(val>=90) return 'S'; if(val>=82) return 'A'; if(val>=74) return 'B'; if(val>=66) return 'C'; return 'D'; }
function pickRandom(arr, rng){ return arr[Math.floor((rng?.() ?? Math.random())*arr.length)]; }
function generateProspectEvents(type, ratings, rng=mulberry32(hashString(`${ratings.pot||70}:${type}`))){
  const events={};
  const roll=()=>rng();
  if(type==='BAT'){
    const dash=(6.75 - (ratings.spd-55)/190 + (roll()-0.5)*0.14).toFixed(2);
    const exit=(145 + (ratings.pwr-60)*0.8 + (roll()-0.5)*6).toFixed(1);
    const vert=(80 + (ratings.spd-55)*0.4 + (roll()-0.5)*6).toFixed(1);
    events.combine={
      summary:`60yd走${dash}秒、打球速度${exit}km/hを記録。柔軟性テストでも上位評価を獲得。`,
      metrics:[
        { label:'60yd走', value:`${dash}秒`, grade:gradeFromValue(ratings.spd) },
        { label:'打球速度', value:`${exit}km/h`, grade:gradeFromValue(ratings.pwr) },
        { label:'垂直跳び', value:`${vert}cm`, grade:gradeFromValue(ratings.spd) },
        { label:'選球スコア', value:`${(ratings.disc + (roll()*10|0))}`, grade:gradeFromValue(ratings.disc) }
      ]
    };
    const koshienTeams=['星陵学院','京南高校','北海学園','明東商業','鳳凰学園'];
    const stages=['甲子園準決勝','甲子園決勝','地方大会決勝','国体準々決勝'];
    const avg=(0.285 + (ratings.con-60)/600 + (roll()-0.5)*0.04).toFixed(3).slice(1);
    const hr=Math.max(0, Math.round((ratings.pwr-60)/8 + roll()*2));
    events.tournaments=[
      {
        stage: pickRandom(stages, rng),
        team: pickRandom(koshienTeams, rng),
        stat:`打率.${avg} / 本塁打${hr}本 / 盗塁${Math.max(0,Math.round((ratings.spd-55)/10 + roll()*1.5))}`,
        highlight: pickRandom([
          '終盤に勝ち越しとなる逆方向への2点適時打を放つ。',
          '大会通算で打率4割超えの活躍。',
          '決勝で3打数3安打と大暴れ。'
        ], rng)
      }
    ];
    events.notes=pickRandom([
      'ミートセンスが高く、打席での対応力が評価されています。体づくりが進めばさらに長打力が伸びそうです。',
      '広角への打ち分けが持ち味。守備では柔らかいグラブ捌きも見せており、将来的に内外野を任せられるとの声。',
      'コンバインではリーダーシップ面も高評価。クラブハウスを明るくするタイプでチームへのフィット感が期待されています。'
    ], rng);
  } else {
    const velo=(ratings.velo + 6 + (roll()-0.5)*4).toFixed(1);
    const spin=(2100 + (ratings.mov-55)*18 + (roll()-0.5)*120)|0;
    const ctrlScore=(ratings.ctrl + (roll()-0.5)*8)|0;
    events.combine={
      summary:`ブルペンで最速${velo}km/hを計測。スピンレートは${spin}rpmと上位水準。`,
      metrics:[
        { label:'最速球速', value:`${velo}km/h`, grade:gradeFromValue(ratings.velo) },
        { label:'スピンレート', value:`${spin}rpm`, grade:gradeFromValue(ratings.mov) },
        { label:'制球指数', value:`${ctrlScore}`, grade:gradeFromValue(ratings.ctrl) },
        { label:'スタミナテスト', value:`${(ratings.stam + (roll()-0.5)*6)|0}pt`, grade:gradeFromValue(ratings.stam) }
      ]
    };
    const schools=['浪速工業','青峰高校','仙北学院','修徳館','報徳大付属'];
    const tourneys=['春のセンバツ','甲子園決勝','都市対抗予選','U18代表強化合宿'];
    const era=(1.90 + (100-ratings.ctrl)/180 + (roll()-0.5)*0.6).toFixed(2);
    const so=Math.max(5, Math.round(12 + (ratings.mov-60)/3 + roll()*4));
    events.tournaments=[
      {
        stage: pickRandom(tourneys, rng),
        team: pickRandom(schools, rng),
        stat:`防御率${era} / 奪三振${so} / 与四球${Math.max(1,Math.round((100-ratings.ctrl)/15 + roll()*2))}`,
        highlight: pickRandom([
          '最速154km/hを計測し、7回1失点で完投勝利。',
          'スライダーとフォークのコンビネーションで奪三振ショーを披露。',
          '球数制限の中でもテンポよく投げ込み、打者を翻弄した。'
        ], rng)
      }
    ];
    events.notes=pickRandom([
      'スカウト陣からは「下半身主導の安定したフォーム」と評価。変化球の精度も向上余地あり。',
      '投球テンポが良く、打者を追い込んでからの決め球が光ります。スタミナ面を整えれば先発ローテ候補。',
      'フィールディングもそつなくこなし、牽制のタイミングが上手いとの評価。クラッチ場面で強さを見せます。'
    ], rng);
  }
  return events;
}

function resolveProspectLevel(prospect){
  const existing=(prospect?.level||'').trim();
  if(existing) return existing;
  const age=Number.isFinite(prospect?.age)?prospect.age:20;
  if(age<=19) return '高校';
  if(age<=21) return '大学';
  if(age<=24) return '社会人';
  return '独立リーグ';
}

function createScoutingProfile(trueRatings, type, level, rng){
  const attrs=type==='BAT'?['con','disc','pwr','spd','fld','pot']:['velo','ctrl','mov','stam','pot'];
  const baseGrades={}, errors={}, hiddenAttrs={}, revealThreshold={};
  const normalizedLevel=(level||'').trim();
  const spreadMultipliers={ 高校:1.35, 大学:1, 社会人:0.75, 独立リーグ:1.1, 海外:1.2 };
  attrs.forEach(attr=>{
    const trueVal=trueRatings[attr]??60;
    const baseSpread=attr==='pot'?14:10;
    const multiplier=spreadMultipliers[normalizedLevel]??1;
    const rawSpread=Math.round(baseSpread*multiplier);
    const spread=clamp(rawSpread, attr==='pot'?6:4, attr==='pot'?22:16);
    const err=Math.round(((rng?.()??Math.random())-0.5)*2*spread);
    const baseVal=clamp(trueVal+err,20,99);
    baseGrades[attr]=baseVal;
    errors[attr]=baseVal-trueVal;
    const hidden=((rng?.()??Math.random())< (attr==='pot'?0.55:0.35));
    hiddenAttrs[attr]=hidden;
    revealThreshold[attr]= hidden ? 0.3 + ((rng?.()??Math.random())*0.45) : 0;
  });
  return { baseGrades, errors, hiddenAttrs, revealThreshold, teams:{}, events: generateProspectEvents(type, trueRatings, rng) };
}

function generateProspects(){
  const seed = (State.seed||2025) + (State.season||1)*31 + 777;
  const rng=mulberry32(seed>>>0);
  const prospects=[]; const used=new Set();
  function makeIdentity(){ return makeFictionalIdentity(rng, used); }

  function assignGrowthCurve(pot) {
    const r = rng();
    if (pot >= 95) return 'prodigy';
    if (pot >= 88) return r < 0.6 ? 'late' : 'standard';
    if (pot >= 80) return r < 0.5 ? 'standard' : (r < 0.8 ? 'late' : 'early');
    if (pot >= 70) return r < 0.6 ? 'standard' : (r < 0.85 ? 'early' : 'bust');
    return r < 0.5 ? 'early' : 'bust';
  }

  function mkBat(){
    const trueRatings={
      con: clamp(40+Math.floor(rng()*35),30,90),
      disc: clamp(35+Math.floor(rng()*30),30,88),
      pwr: clamp(40+Math.floor(rng()*40),30,94),
      spd: clamp(40+Math.floor(rng()*40),30,94),
      fld: clamp(40+Math.floor(rng()*40),30,94),
      pot: clamp(70+Math.floor(rng()*26),60,99)
    };
    const pos = randPos(rng);
    const identity=makeIdentity();
    const age=18+Math.floor(rng()*5);
    const prospectLevel=resolveProspectLevel({ age });
    const prospect={
      pid:`PR-B-${Math.floor(rng()*1e9)}`,
      name:identity.name,
      type:'BAT',
      age,
      hand:randHand(rng),
      pos,
      growthCurve: assignGrowthCurve(trueRatings.pot),
      trueRatings,
      level:prospectLevel,
      isForeign: identity.isForeign,
      origin: identity.origin,
      scouting:createScoutingProfile(trueRatings, 'BAT', prospectLevel, rng)
    };
    return prospect;
  }
  function mkPit(){
    const trueRatings={
      velo:clamp(40+Math.floor(rng()*42),30,94),
      ctrl:clamp(35+Math.floor(rng()*34),30,90),
      mov:clamp(40+Math.floor(rng()*42),30,94),
      stam:clamp(40+Math.floor(rng()*38),30,92),
      pot:clamp(70+Math.floor(rng()*26),60,99)
    };
    const role=(rng()<0.65?"SP":"RP");
    const identity=makeIdentity();
    const age=18+Math.floor(rng()*5);
    const prospectLevel=resolveProspectLevel({ age });
    const prospect={
      pid:`PR-P-${Math.floor(rng()*1e9)}`,
      name:identity.name,
      type:'PIT',
      age,
      role,
      hand:randHand(rng),
      growthCurve: assignGrowthCurve(trueRatings.pot),
      isForeign: identity.isForeign,
      origin: identity.origin,
      trueRatings,
      level:prospectLevel,
      scouting:createScoutingProfile(trueRatings, 'PIT', prospectLevel, rng)
    };
    return prospect;
  }
  ensureTeamMeta();
  Object.values(State.teamMeta||{}).forEach(meta=>{ if(meta?.scouting){ meta.scouting.assignments={}; } });
  for(let i=0;i<60;i++) prospects.push(mkBat());
  for(let i=0;i<40;i++) prospects.push(mkPit());
  return prospects;
}
function ensureDraft(){
  const draft = ensureDraftStateRecord(State);
  if(!Array.isArray(draft.order) || draft.order.length===0){
    draft.order = draftOrderFromStandings();
  }
  if(draft.round === 1){
    const needsInit = !Array.isArray(draft.pendingFirstRound) || draft.pendingFirstRound.length===0;
    if(needsInit && draft.bids.length===0){
      draft.pendingFirstRound = draft.order.slice();
    }
  }
  if(!Array.isArray(draft.pool)) draft.pool = [];
  draft.prospects = draft.pool;
  if(typeof draft.completed!=='boolean') draft.completed=false;
  return draft;
}
function evaluateProspectBase(p){ ensureProspectStructure(p); const r=p.trueRatings||{}; if(p.type==='BAT'){ return r.pot*1.1 + r.pwr*0.4 + r.con*0.4 + r.spd*0.2; } else { return r.pot*1.1 + r.velo*0.35 + r.mov*0.35 + r.ctrl*0.25 + (p.role==='SP'?5:0); } }
function prospectNeedBucket(prospect){ ensureProspectStructure(prospect); const bucket=getDraftProspectNeedCategory(prospect); if(bucket) return bucket; if(prospect.type==='PIT'){ const role=(prospect.role||prospect.pos||'').toUpperCase(); return role==='SP'?'SP':'RP'; } const pos=(prospect.pos||'').toUpperCase(); if(pos==='C') return 'C'; if(['LF','CF','RF','OF'].includes(pos)) return 'OF'; return 'IF'; }
function evaluateProspectForTeam(prospect, teamId){ ensureProspectStructure(prospect); const base=evaluateProspectBase(prospect); if(teamId==null){ return base; } ensureTeamNeedsAll(); const team=State.teams?.find(t=>t.team_id===teamId); if(!team){ return base; } const bucket=prospectNeedBucket(prospect); const need=clamp((team.needs?.[bucket])??0,0,1.5); let score=base*(1+need*0.45); if(prospect.potRange){ const range=prospect.potRange; const spread=clamp((range.max-range.min),0,30); score+=spread*0.12; const mid=(range.min+range.max)/2; score+= (mid-base)*0.05; } if(typeof prospect.signWillingness==='number'){ score*=1+clamp((prospect.signWillingness-60)/220,-0.25,0.35); } if(typeof prospect.riskInjury==='number'){ score*=1-clamp((prospect.riskInjury-50)/220,-0.3,0.3); } return score; }
function handleDraftEvent(type, payload){
  draftView?.pushEvent?.(type, payload);
  if(type==='lottery'){
    const winnerName=id2name(payload.winner.teamId);
    const loserNames=(payload.losers||[]).map(id2name).join('、');
    const suffix=loserNames?`（敗者: ${loserNames}）`:'';
    State.devLogs.push(`【ドラフト抽選】${payload.prospect.name}の交渉権は${winnerName}が獲得${suffix}`);
    return;
  }
  if(type==='selection'){
    const { round, teamId, prospect } = payload;
    const prefix = round===1 ? '1巡目抽選結果' : `${round}巡目指名`;
    State.devLogs.push(`【ドラフト${prefix}】${id2name(teamId)} -> ${prospect.name}`);
    if(round===1){
      logHighlight('pen-tool', `【ドラフト1巡目】${id2name(teamId)}が${prospect.name}を指名！未来のチームを背負う逸材です。`);
    }
  }
}
function applyDraftSelection(team_id, prospect, selection){
  if(!prospect) return false;
  ensureProspectStructure(prospect);
  const ratings=prospect.trueRatings||{};
  if(prospect.type==='BAT'){
    const id=`B${team_id}-N${State.rosters[team_id].bats.length}`;
    const player={id,name:prospect.name,age:prospect.age,hand:prospect.hand,con:ratings.con,disc:ratings.disc,pwr:ratings.pwr,spd:ratings.spd,fld:ratings.fld,pos:prospect.pos,pot:ratings.pot,traits:[],morale:65,fatigue:15, injury: null, recentGains:[], isForeign:Boolean(prospect.isForeign), origin: prospect.origin || (prospect.isForeign?'international':'domestic')};
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale] };
    ensurePlayerPersona(player, mulberry32(hashString(id)));
    State.rosters[team_id].bats.push(player); if(!State.squads[team_id]) ensureSquads(); State.squads[team_id].ni.push(id);
  } else {
    const id=`P${team_id}-N${State.rosters[team_id].pits.length}`;
    const player={id,name:prospect.name,age:prospect.age,role:prospect.role,velo:ratings.velo,ctrl:ratings.ctrl,mov:ratings.mov,stam:ratings.stam,hand:prospect.hand,pot:ratings.pot,traits:[],morale:65,fatigue:15, sub_role: '中継ぎ', injury: null, recentGains:[], isForeign:Boolean(prospect.isForeign), origin: prospect.origin || (prospect.isForeign?'international':'domestic')};
    player.history = { overall: [getOverall(player)], fatigue: [player.fatigue], morale: [player.morale] };
    ensurePlayerPersona(player, mulberry32(hashString(id)));
    State.rosters[team_id].pits.push(player); if(!State.squads[team_id]) ensureSquads(); State.squads[team_id].ni.push(id);
  }
  Object.values(State.teamMeta||{}).forEach(meta=>{ if(meta?.scouting?.assignments){ delete meta.scouting.assignments[prospect.pid]; }});
  ensureTrainingDefaults(team_id);
  const teamObj = State.teams.find(t=>t.team_id===team_id);
  if(teamObj){
    recomputeTeamRatings(teamObj, State.rosters[team_id], new Set(State.squads[team_id].ichi));
  }
  updateTeamNeeds(team_id);
  return true;
}
function completeDraftSelection(team_id, selectionResult){
  if(!selectionResult) return false;
  const { prospect, selection } = selectionResult;
  const applied = applyDraftSelection(team_id, prospect, selection);
  if(applied) save();
  return applied;
}
function chooseBestProspectForTeam(){
  const draft=ensureDraft();
  const pool=draft.pool||[];
  let best=null, bestScore=-Infinity;
  for(const prospect of pool){
    const score=evaluateProspectForTeam(prospect, teamId)+Math.random()*3;
    if(score>bestScore){ bestScore=score; best=prospect; }
  }
  return best;
}
function getNextDraftActor(){
  const draft=ensureDraft();
  if(draft.round===1){
    const pending=getDraftPendingTeams(State);
    return pending.length>0?pending[0]:null;
  }
  return getDraftOnClockTeamId(State);
}
function processFirstRoundResolution(){
  const result=resolveDraftFirstRound(State,{ random:Math.random, onLog:handleDraftEvent });
  result.winners.forEach(entry=>{
    completeDraftSelection(entry.teamId,{ prospect:entry.prospect, selection:entry.selection });
  });
  return result;
}
function checkDraftCompletion(){
  const draft=ensureDraft();
  if(isDraftComplete(State) && !draft.completed){
    State.devLogs.push('ドラフト完了');
    draft.active=false;
    draft.completed=true;
    save();
    return true;
  }
  return false;
}
function autoDraftStep(stopTeamId){
  ensureDraft();
  if(!State.draft.active) return false;
  if(isDraftComplete(State)){
    checkDraftCompletion();
    return false;
  }
  if(State.draft.round===1){
    if(shouldResolveDraftFirstRound(State)){
      const result=processFirstRoundResolution();
      checkDraftCompletion();
      return result.winners.length>0;
    }
    const pending=getDraftPendingTeams(State);
    if(pending.length===0) return false;
    const teamId=pending[0];
    if(stopTeamId!=null && !State.commissioner && teamId===stopTeamId) return false;
    const best=chooseBestProspectForTeam(teamId);
    if(!best) return false;
    submitDraftBid(State, teamId, best.pid);
    save();
    if(shouldResolveDraftFirstRound(State)){
      processFirstRoundResolution();
      checkDraftCompletion();
    }
    return true;
  }
  const teamId=getDraftOnClockTeamId(State);
  if(teamId==null){
    checkDraftCompletion();
    return false;
  }
  if(stopTeamId!=null && !State.commissioner && teamId===stopTeamId) return false;
  const best=chooseBestProspectForTeam(teamId);
  if(!best){
    checkDraftCompletion();
    return false;
  }
  const result=selectDraftProspect(State, teamId, best.pid,{ onLog:handleDraftEvent });
  if(result){
    completeDraftSelection(teamId, result);
    checkDraftCompletion();
    return true;
  }
  return false;
}
function autoUntilUserTurn(userTid){
  let safety=1000;
  while(State.draft.active && !isDraftComplete(State) && safety-->0){
    const next=getNextDraftActor();
    if(next==null){
      if(State.draft.round===1 && shouldResolveDraftFirstRound(State)){
        processFirstRoundResolution();
        checkDraftCompletion();
        continue;
      }
      break;
    }
    if(!State.commissioner && next===userTid) break;
    if(!autoDraftStep(userTid)) break;
  }
}

// ====== Recompute & Render All ======
function recomputeAllRatingsAll(){
  State.teams.forEach(t=>recomputeTeamRatings(t, State.rosters[t.team_id], new Set(State.squads[t.team_id].ichi)));
  recomputeTeamModsAll();
}
function renderAll(){
  ensureNarrativeState();
  renderSeasonSettings();
  scheduleView.renderToday(State);
  const selT=$("#selTeamManage"); if(selT && selT.options.length===0){ teamOptions(selT); selT.selectedIndex=0; }
  renderUserControls();
  renderDashboardOverview();
  const activeTab=(State.ui && State.ui.dashboardTab) || 'season';
  renderDashboardTabs(activeTab);
  renderManagementView();
  refreshIcons();
  updateAdvanceButtonsState();
}

// ====== Progression: Day/Season Buttons ======
function advanceSeason() {
    if(!State.historicalStats) State.historicalStats = {};
    State.season = (State.season || 1) + 1;
    State.historicalStats[State.season - 1] = {};
    State.playoffs = defaultPlayoffState();
    normalizeLeagueState(State);
    State.seasonInfo = defaultSeasonInfo();
    normalizeSeasonInfo(State);
    State.gameRecaps = {};

    const rosters = Object.values(State.rosters || {});
    rosters.forEach(roster => {
        const bats = Array.isArray(roster?.bats) ? roster.bats : [];
        const pits = Array.isArray(roster?.pits) ? roster.pits : [];
        for (const p of [...bats, ...pits]) {
            // Archive last season's data
            State.historicalStats[State.season - 1][p.id] = { history: p.history };
            // Age players
            p.age++;
            // Reset for new season
            p.history = { overall: [getOverall(p)], fatigue: [p.fatigue], morale: [p.morale] };
        }
    });
    ensureTeamFinances();
    State.teams.forEach(team => {
        const tid = team.team_id;
        const finance = State.teamFinances[tid];
        if(!finance) return;
        finance.attendance.seasonTotal = 0;
        finance.attendance.average = 0;
        finance.attendance.homeGames = 0;
        finance.attendance.lastGame = 0;
        finance.revenue = { ticket:0, merch:0, media:0, other:0, total:0 };
        finance.expenses.total = 0;
        finance.ledger = [];
        const expired = [];
        finance.contracts.forEach(contract => {
            if(contract.yearsRemaining > 0) contract.yearsRemaining--;
            if(contract.yearsRemaining <= 0){
                expired.push(contract.playerId);
                contract.status = 'expired';
            } else {
                contract.status = 'active';
                if(contract.yearsRemaining <= 1) contract.daysRemaining = 90;
            }
        });
        expired.forEach(pid => releasePlayerToFreeAgency(tid, pid, '契約満了'));
        finance.contracts = finance.contracts.filter(c=>c.status!=='expired');
        updateFinancialSnapshots(tid);
    });
}

$("#btnGen").onclick=()=>{
  const hasSchedule = Array.isArray(State.schedule) && State.schedule.length > 0;
  const hasCurrDay = typeof State.curr_day === 'number';
  if (hasSchedule && hasCurrDay && State.curr_day <= maxDay()) {
      if (!confirm("シーズンがまだ終わっていません。本当に次のシーズンに進みますか？")) return;
  }
  advanceSeason();
  const seed=parseInt($("#seed").value)||2025;
  const reps=parseInt($("#repeats").value)||6;
  State.seed=seed;
  normalizeLeagueState(State);
  const rules = LeagueRules.ensureLeagueRules(State.league);
  const calendarResult = ScheduleBuilder.buildSeasonCalendar({ teams: State.teams, seed: seed + State.season, rules, repeats: reps });
  const derivedSchedule = ScheduleBuilder.calendarToSchedule(calendarResult.calendar);
  State.seasonInfo = {
    calendar: calendarResult.calendar,
    stage: calendarResult.calendar[0]?.stage || 'PRE',
    dayLookup: calendarResult.dayLookup,
    stageBounds: calendarResult.stageBounds,
    regularSeasonEnd: calendarResult.regularSeasonEnd,
    gamesPerTeam: calendarResult.gamesPerTeam,
    totalsByTeam: calendarResult.totalsByTeam
  };
  normalizeSeasonInfo(State);
  State.league.rules = {
    ...rules,
    gamesPerTeam: calendarResult.gamesPerTeam || rules.gamesPerTeam,
    interleague: { ...rules.interleague },
    allStarBreak: { ...rules.allStarBreak },
    roster: { ...rules.roster },
    postseason: {
      cs: { ...(rules.postseason?.cs||{}) },
      js: { ...(rules.postseason?.js||{}) }
    }
  };
  State.schedule=normalizeScheduleEntries(derivedSchedule);
  State.results=[];
  State.curr_day=1;
  State.weekXP={}; State.weekXPLog={};
  State.devLogs=[];
  State.squadsInit=false; 
  State.playerGameLogs = {};
  ensureSquads(); 
  recomputeAllRatingsAll(); 
  saveAndRerender(); 
};

$("#btnToday").onclick=()=>{
  const complianceMap = refreshRosterComplianceAll();
  const tid = State.userTeamId ?? 0;
  const compliance = complianceMap[tid] || State.rosterCompliance?.[tid] || null;
  if(compliance && Array.isArray(compliance.errors) && compliance.errors.length){
    showRosterViolationModal(compliance);
    save();
    renderManagementView();
    updateAdvanceButtonsState();
    return;
  }
  const hasSchedule=State.schedule.length>0;
  const seasonDone=hasSchedule && State.curr_day > maxDay();

  if(seasonDone){
    if(!State.playoffs?.started){
      startPlayoffs();
      saveAndRerender();
      return;
    }
    if(State.playoffs.active){
      const progressed=playNextPlayoffGame();
      if(progressed){
        saveAndRerender();
        return;
      }
    }
    checkPlayoffStageCompletion();
    saveAndRerender();
    return;
  }

  if(!hasSchedule){
    if(State.playoffs?.active){
      if(playNextPlayoffGame()){
        saveAndRerender();
      }
    }
    return;
  }

  const {events, restDay}=tickDay();

  ensureSquads();
  recomputeAllRatingsAll();
  const day=State.curr_day||1;
  const gamesToday=events.filter(evt=>(evt?.type||'game')==='game');
  State.home_adv=clamp((parseInt($("#homeAdv").value)||5)/100,0,0.2);

  if(!restDay){
    for(const row of gamesToday){
      const seed=State.seed+day*97+row.home_id*17+row.away_id*13;
      const res=simulateGameDetailed(row,seed);
      State.results.push(res);
      dpGain(res.winner_id, 0.3);
      const loser=(res.winner_id===row.home_id?row.away_id:row.home_id);
      dpGain(loser,0.1);
      allocateGameStats(res);
      applyGameFinancials(res);
    }
  }

  if(day%7===0){
    State.teams.forEach(t=> applyTrainingWeek(t.team_id,1,"自動週次育成"));
    recomputeAllRatingsAll();
    runScoutingTask('weekly');
  }
  updateDailyFinancials(day, gamesToday, restDay);
  processContractCountdown(day);
  runScoutingTask('daily');
  const resultsToday = (State.results||[]).filter(r=>r.day===day);
  const narrativeEvents = evaluateDailyNarrativeEvents({ day, restDay, gamesToday, resultsToday });
  let abilityChanged=false;
  narrativeEvents.forEach(evt=>{ if(applyNarrativeEvent(evt)) abilityChanged=true; });
  captureDailyMoraleSnapshot(day);
  if(abilityChanged) recomputeAllRatingsAll();
  State.curr_day=day+1;
  saveAndRerender();
};
$("#btnEnd").onclick=()=>{
  if(!State.schedule.length) return;
  if(hasBlockingRosterViolations()){
    const tid=State.userTeamId ?? 0;
    const compliance=getRosterCompliance(tid,{ refresh:true });
    if(compliance && Array.isArray(compliance.errors) && compliance.errors.length){
      showRosterViolationModal(compliance);
      save();
      renderManagementView();
      updateAdvanceButtonsState();
      return;
    }
  }
  const end=maxDay();
  for(let d=State.curr_day||1; d<=end; d++){
    if(State.curr_day>end) break;
    $("#btnToday").click();
    if(hasBlockingRosterViolations()) break;
  }
};
$("#btnReset").onclick=()=>{ if(confirm("本当に全データをリセットしますか？この操作は元に戻せません。")){ localStorage.removeItem(SAVE_KEY); window.location.reload(); } };

// ====== Save/Load ======
function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(State)); }
function saveAndRerender(){ refreshRosterComplianceAll(); save(); renderAll(); }

// ====== Tabs/Listeners ======
$$('.tab').forEach(tab=> tab.onclick=()=>{ $$('.tab').forEach(t=>t.classList.remove('active')); tab.classList.add('active'); renderManagementView(); });
$$('#dashboard-tabs .dashboard-tab').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const tab=btn.dataset.tab;
    if(!tab) return;
    if(!State.ui) State.ui={};
    const changed=State.ui.dashboardTab!==tab;
    State.ui.dashboardTab=tab;
    if(changed) save();
    renderDashboardTabs(tab);
  });
});
$("#selTeamManage").onchange=()=>{ renderDashboardOverview(); renderDashboardTabs((State.ui && State.ui.dashboardTab) || 'season'); renderManagementView(); };

// ====== Boot ======
(function init(){ 
  // Custom confirm dialog replacement
  window.confirm = function(message) {
      // For this environment, we can't show a real modal dialog.
      // We will proceed as if the user clicked "OK".
      // In a real application, you would implement a custom modal here.
      console.log("Confirmation requested: ", message);
      return true;
  };
  
  // Modal Listeners
  $('#modalCloseBtn').onclick = hidePlayerDetailModal;
  $('#playerDetailModal').onclick = (e) => {
      if (e.target === $('#playerDetailModal')) {
          hidePlayerDetailModal();
      }
  };
  $('#gameRecapCloseBtn').onclick = hideGameRecapModal;
  $('#gameRecapModal').onclick = (e) => {
      if (e.target === $('#gameRecapModal')) {
          hideGameRecapModal();
      }
  };
  $('#scoutReportCloseBtn').onclick = hideScoutReportModal;
  $('#scoutReportModal').onclick = (e) => {
      if (e.target === $('#scoutReportModal')) {
          hideScoutReportModal();
      }
  };
  $('#narrativeLogCloseBtn').onclick = hideNarrativeLogModal;
  $('#narrativeLogModal').onclick = (e) => {
      if (e.target === $('#narrativeLogModal')) {
          hideNarrativeLogModal();
      }
  };
  $('#rosterViolationCloseBtn').onclick = hideRosterViolationModal;
  $('#rosterViolationModal').onclick = (e) => {
      if (e.target === $('#rosterViolationModal')) {
          hideRosterViolationModal();
      }
  };

  document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
          if ($('#playerDetailModal').style.display === 'flex') hidePlayerDetailModal();
          if ($('#gameRecapModal').style.display === 'flex') hideGameRecapModal();
          if ($('#narrativeLogModal').style.display === 'flex') hideNarrativeLogModal();
          if ($('#rosterViolationModal').style.display === 'flex') hideRosterViolationModal();
      }
  });

   // Sound event listener
  document.body.addEventListener('click', (e) => {
      try {
          setupSound().catch(err => {
              console.warn('Sound setup failed on click:', err);
          });
      } catch (err) {
          console.warn('Sound setup threw an unexpected synchronous error; continuing without audio.', err);
      }

      const target = e.target.closest('button, .tab, select');
      if (target) {
          if (target.matches('button')) {
              const button = target;
              if (button.id === 'btnReset') {
                  playSound('G2', '8n');
              } else if (button.classList.contains('primary')) {
                  playSound('G4', '16n');
              } else if (button.id === 'btnToday' || button.id === 'btnEnd') {
                  playSound('C5', '16n');
              } else if (button.textContent.includes('特訓')) {
                  playSound('A4', '16n');
              }
              else {
                  playSound('C4', '16n');
              }
          } else if (target.matches('.tab')) {
              playSound('E4', '16n');
          } else if (target.matches('select')) {
                playSound('D4', '16n');
          }
      }
  }, true); // Use capture phase

  ensureSquads();
  refreshRosterComplianceAll();
  save();
  renderAll();
})();
</script>

<!-- ==== Debug Helper injected by ChatGPT ==== -->
<style>
  .debug-floating-btn { position: fixed; right: 16px; bottom: 16px; z-index: 5000; 
    border: 2px solid #334155; background: #111827; color: #fff; padding: 10px 14px; 
    border-radius: 12px; font-size: 12px; cursor: pointer; box-shadow: 0 6px 16px rgba(0,0,0,.3); }
  .debug-panel { position: fixed; right: 16px; bottom: 70px; width: 380px; max-height: 50vh; 
    overflow: auto; background: #0f172a; color: #e2e8f0; border: 2px solid #334155; 
    border-radius: 12px; padding: 10px; z-index: 5000; display: none; }
  .debug-panel h4 { margin: 0 0 8px; font-size: 13px; }
  .debug-panel pre { white-space: pre-wrap; word-break: break-word; font-size: 12px; }
  .debug-panel button { margin-right: 8px; }
</style>
<div id="__debug_panel" class="debug-panel">
  <h4>Debug Console</h4>
  <div style="margin-bottom:8px;">
    <button id="__dbg_reset" class="mini">セーブ削除 &amp; リロード</button>
    <button id="__dbg_copy" class="mini">ログをコピー</button>
  </div>
  <pre id="__debug_log"></pre>
</div>
<button id="__debug_toggle" class="debug-floating-btn">🛠 Debug</button>
<script>
(function(){
  const LOG = [];
  const logEl = () => document.getElementById("__debug_log");

  function addLog(kind, msg) { 
    const line = `[${new Date().toLocaleString()}] ${kind}: ${msg}`;
    LOG.push(line);
    if (logEl()) logEl().textContent = LOG.join("\n");
    try { console[kind === 'ERROR' ? 'error' : 'log'](line); } catch (e) {}
  }

  window.addEventListener("error", (ev)=>{
    addLog("ERROR", (ev.message||"") + " @ " + (ev.filename||"") + ":" + (ev.lineno||""));
  });
  window.addEventListener("unhandledrejection", (ev)=>{
    addLog("ERROR", "Unhandled Rejection: " + (ev.reason && (ev.reason.stack||ev.reason.message) || ev.reason));
  });

  document.getElementById("__debug_toggle").onclick = ()=>{
    const p = document.getElementById("__debug_panel");
    p.style.display = (p.style.display === "none" || !p.style.display) ? "block" : "none";
  };
  document.getElementById("__dbg_reset").onclick = ()=>{
    try { localStorage.removeItem("pennantsim-lite-web-v12-training-plus"); } catch(e) {}
    location.reload();
  };
  document.getElementById("__dbg_copy").onclick = async ()=>{
    try { await navigator.clipboard.writeText(LOG.join("\n")); addLog("INFO", "Copied to clipboard"); } catch(e) { addLog("ERROR", e.message||e); }
  };

  addLog("INFO", "Debug helper ready. SAVE_KEY=pennantsim-lite-web-v12-training-plus");
})();
</script>
<!-- ==== /Debug Helper ==== -->

</body>
</html>

